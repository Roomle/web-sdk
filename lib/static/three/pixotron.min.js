!function(e){var t={};function i(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=e,i.c=t,i.d=function(e,t,a){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:a})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=3)}([function(e,t,i){function a(e){const t=Math.floor(Math.random()*e.length),i=e[t];return e.splice(t,1),i}function r(e,t,i){this.width=e,this.height=t,this.cellSize=i,this.array=new Array(e);for(let i=0;i<e;i++)this.array[i]=new Array(t)}function o(e,t){const i=t*(Math.random()+1),a=6.283185307178*Math.random(),r=e.x+i*Math.cos(a),o=e.y+i*Math.sin(a);return new THREE.Vector2(r,o)}i(2),r.prototype={constructor:r,t:function(e){const t=Math.floor(e.x/this.cellSize),i=Math.floor(e.y/this.cellSize);this.array[t][i]=e},h:function(e,t){const i=Math.floor(e.x/this.cellSize),a=Math.floor(e.y/this.cellSize);for(let r=i-5;r<i+5;r++)for(let i=a-5;i<a+5;i++)if(r>=0&&r<this.width&&i>=0&&i<this.height){const a=this.array[r][i];let o=1e10;if(void 0!==a&&(o=a.distanceTo(e)),o<t)return!0}return!1}},e.exports=(PIXOTRON.lerpDistribution=function(e,t,i){return(t=t||.47)*(1-e)+(i=i||7)*e},PIXOTRON.uniformDistribution=function(){return 1},PIXOTRON.cosineDistribution=function(e){const t=e*Math.PI/2,i=Math.cos(t);return.47*(1-i)+7*i},PIXOTRON.generateQuasiRandomPoints=function(e,t,i,s){i=i||PIXOTRON.uniformDistribution,s=s||PIXOTRON.insideCircle,t<0&&(t=Math.sqrt(e)/e);const n=[],l=[],h=t/Math.sqrt(2),c=new r(Math.ceil(1/h),Math.ceil(1/h),h),u=new THREE.Vector2(.5,.5);let d=!1;do{u.x=Math.random(),u.y=Math.random(),d=s(u.x,u.y)}while(!d);for(l.push(u),n.push(u),c.t(u);0!==l.length&&n.length<e;){const e=a(l);for(let a=0;a<30;a++){const a=e.x-.5,r=e.y-.5,h=i(Math.sqrt(a*a+r*r)),u=o(e,h*t);!s(u.x,u.y)||c.h(u,h*t)||(l.push(u),n.push(u),c.t(u))}}return n})},function(e,t){e.exports=PIXOTRON.SmoothTransitionAOShader={uniforms:{saoAccumulationBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["varying vec2 vUv;","uniform float transition;","uniform sampler2D saoAccumulationBuffer;","void main() {","float aoValue = texture2D( saoAccumulationBuffer, vUv).r;","gl_FragColor = vec4(mix(0., aoValue, transition));","}"].join("\n")},e.exports=PIXOTRON.SmoothTransitionShadowShader={uniforms:{shadowAccumulationBuffer:{value:null},firstFrameShadowBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["#include <packing>","varying vec2 vUv;","uniform float transition;","uniform sampler2D shadowAccumulationBuffer;","uniform sampler2D firstFrameShadowBuffer;","void main() {","float shadowValueFirstFrame = unpackRGBAToDepth(texture2D( firstFrameShadowBuffer, vUv));","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","gl_FragColor = vec4(mix(shadowValueFirstFrame, shadowValue, pow(transition, 4.)));","}"].join("\n")},e.exports=PIXOTRON.SmoothTransitionSoftShadowShadowShader={uniforms:{shadowAccumulationBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["#include <packing>","varying vec2 vUv;","uniform float transition;","uniform sampler2D shadowAccumulationBuffer;","void main() {","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","float mask = 1. - shadowValue;","mask = pow(mask, 2.5);","gl_FragColor =  vec4(mix(vec4(0.), vec4(vec3(0.), mask), pow(transition, 1.)));","}"].join("\n")}},function(e,t){function i(e){return 0==(e&e-1)&&0!==e}THREE.ShaderChunk.utilshader=["vec2 pack16(float value){","float sMax = 65535.0;","int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);","int digit0 = v/256;","int digit1 = v-digit0*256;","return vec2(float(digit0)/255.0, float(digit1)/255.0);","}","vec2 packNormal(vec3 n){","float p = sqrt(n.z*8.0+8.0);","return vec2(n.xy/p + 0.5);","}","vec3 unpackNormal(vec2 enc){","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","vec3 getViewNormal(const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormalDepth, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linstep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","vec3 packFloatToRGB(const in float x) {","const vec3 code = vec3(1.0, 255.0, 65025.0);","vec3 pack = vec3(code * x);","pack.gb = fract(pack.gb);","pack.rg -= pack.gb * (1.0 / 256.0);","return pack;","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth;","#if DEPTH_PACKING_MODE == 2","uncodedDepth = texture2D( tNormalDepth, uv );","#else","uncodedDepth = texture2D( tDepth, uv );","#endif","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow2(unpackRGBAToDepth(uncodedDepth));","#else","return unpackRGBAToDepth( uncodedDepth );","#endif","#else","return pow2(unpack16(uncodedDepth.xy));","#endif","}"].join("\n"),function(){const e=THREE.CopyShader;PIXOTRON.u=THREE.UniformsUtils.clone(e.uniforms),PIXOTRON.v=new THREE.ShaderMaterial({uniforms:PIXOTRON.u,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader}),PIXOTRON.R=new THREE.Scene,PIXOTRON.T=new THREE.OrthographicCamera(-1,1,1,-1,0,1),PIXOTRON.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),PIXOTRON.v),PIXOTRON.quad.frustumCulled=!1,PIXOTRON.R.add(PIXOTRON.quad)}(),e.exports=PIXOTRON.randomizeArray=function(e){let t,i,a=e.length;for(;0!==a;)i=Math.floor(Math.random()*a),t=e[a-=1],e[a]=e[i],e[i]=t;return e},e.exports=PIXOTRON.createTextureFromRawData=function(e,t){(t=t||{}).type=t.type||THREE.FloatType,t.format=t.format||THREE.LuminanceAlphaFormat,t.minFilter=t.minFilter||THREE.NearestFilter,t.magFilter=t.magFilter||THREE.NearestFilter;const i=new Float32Array(2*e.length);for(let t=0;t<2*e.length;t+=2)i[t]=e[t/2].x-.5,i[t+1]=e[t/2].y-.5;const a=new THREE.DataTexture(i,e.length,1);return a.format=t.format,a.type=t.type,a.minFilter=t.minFilter,a.magFilter=t.magFilter,a.generateMipmaps=!1,a.needsUpdate=!0,a},e.exports=PIXOTRON.jitterCamera=function(e,t,i,a,r){r=void 0!==r?r:.5;const o=(2*t.x-1)*r,s=(2*t.y-1)*r;e.setViewOffset(i,a,o,s,i,a)},e.exports=PIXOTRON.insideCircle=function(e,t,i){const a=e-.5,r=t-.5;return a*a+r*r<=(i=void 0!==i?i:.5)*i},e.exports=PIXOTRON.insideRectangle=function(e,t,i,a){return i=void 0!==i?i:1,a=void 0!==a?a:1,e>=0&&t>=0&&e<=i&&t<=a},e.exports=PIXOTRON.blit=function(e,t,i,a){a=void 0!==a&&a,PIXOTRON.u.tDiffuse.value=t,PIXOTRON.quad.material=PIXOTRON.v,e.render(PIXOTRON.R,PIXOTRON.T,i,a)},e.exports=PIXOTRON.renderPass=function(e,t,i,a){a=void 0!==a&&a,PIXOTRON.quad.material=t,e.render(PIXOTRON.R,PIXOTRON.T,i,a)},e.exports=PIXOTRON.calculateFOV=function(e,t,i){let a;e.isBox3?a=e:(a=new THREE.Box3).setFromObject(e);const r=new THREE.Vector3;a.getCenter(r);const o=new THREE.Vector3;a.getSize(o);const s=new THREE.Vector3;s.set(o.x/2,o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize();let n=i.dot(s);return s.set(-o.x/2,o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(o.x/2,-o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(o.x/2,o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(-o.x/2,-o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(-o.x/2,o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(o.x/2,-o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(-o.x/2,-o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),180*Math.acos(n)/Math.PI*2},e.exports=PIXOTRON.isPowerOfTwo=function(e){return i(e.width)&&i(e.height)},e.exports=PIXOTRON.makePowerOfTwo=function(e){function t(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}if(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageBitmap){const i=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return i.width=t(e.width),i.height=t(e.height),i.getContext("2d").drawImage(e,0,0,i.width,i.height),i}return e},e.exports=PIXOTRON.getDataFromImage=function(e,t){const i=document.createElement("canvas"),a=t,r=t/(e.width/e.height);i.width=a,i.height=r;const o=i.getContext("2d");return o.drawImage(e,0,0,a,r),o.getImageData(0,0,a,r)},e.exports=PIXOTRON.getPixelFromImageData=function(e,t,i){const a=4*(t+e.width*i),r=e.data;return{r:r[a],g:r[a+1],b:r[a+2],a:r[a+3]}},e.exports=PIXOTRON.squareToUniformDiskConcentric=function(){const e=new THREE.Vector2;return function(t){const i=2*t.x-1,a=2*t.y-1;let r,o;0===i&&0===a?o=r=0:i*i>a*a?(o=i,r=Math.PI/4*(a/i)):(o=a,r=Math.PI/2-i/a*(Math.PI/4));const s=Math.sin(r),n=Math.cos(r);return e.x=o*n,e.y=o*s,e}}(),e.exports=PIXOTRON.squareToCosineHemisphere=function(){const e=new THREE.Vector3;return function(t){const i=PIXOTRON.squareToUniformDiskConcentric(t),a=Math.sqrt(1-i.x*i.x-i.y*i.y);return e.set(i.x,i.y,a),e}}()},function(e,t,i){e.exports=PIXOTRON={},i(2),i(4),i(6),i(0),i(7),i(9),i(11),i(13),i(15),i(18),i(20),i(22),i(24),i(26),i(27),e.exports=PIXOTRON.Pixotron=class{constructor(e){(e=e||{}).saoparams=e.saoparams||{},e.shadowparams=e.shadowparams||{},e.gbufferparams=e.gbufferparams||{},this.needsUpdate=!0,this.autoSAOClear=!0,this.autoShadowsClear=!0,this.enableAA=!0,this.D=new PIXOTRON.BilateralFilterPass(3,1),this.N=new PIXOTRON.GBufferPass(e.gbufferparams);const t=e.giParams||{};this.enableGI=!!t.enable,this.enableGI&&this.initializeGI(t),this.P=new PIXOTRON.BVHManager;const i=void 0===e.saoparams.accumulative||e.saoparams.accumulative;this.O=i?new PIXOTRON.AccumulativeSAOPass(e.saoparams):new PIXOTRON.SAOPass(e.saoparams),this.M=new PIXOTRON.ShadowPass(e.shadowparams),e.groundShadow&&(this.C=new PIXOTRON.PlaneShadowBakePass(e.groundShadow)),this.S=new PIXOTRON.SuperSampleAAPass,this.H=PIXOTRON.generateQuasiRandomPoints(30,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle);const a={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this._=new THREE.WebGLRenderTarget(1,1,a),this.I=new THREE.WebGLRenderTarget(1,1,a),this.A=0,this.F=null,this.V=null}addNodeToAccelerationStructure(e,t){t?this.P.add(e):e.traverse(e=>{e.isMesh&&e.castShadow&&(e.updateMatrixWorld(),this.P.add(e))})}addRenderCompleteCallback(e){this.renderCompleteCallback=e}removeRenderCompleteCallback(){this.renderCompleteCallback=null}blit(e){this.U&&PIXOTRON.blit(this.renderer,this.U,e,!1)}enableVPLGeneration(){this.X&&(this.X.L=!0)}getBloomPass(){return this.B}getHighLightPass(){return this.k}getRenderPass(){return this.W}getSAOPass(){return this.O}getShadowPass(){return this.M}getVPLGenerationPass(){return this.X}getShadowPlanePass(){return this.C}highlightObjects(e){this.k&&(this.k.selectedObjects=e)}initializeGI(e){this.X=new PIXOTRON.VPLGenerationPass(500),this.Z=new PIXOTRON.InstantRadiosityPass}insertPass(e,t){this.j.insertPass(e,t)}isAccumulationConverged(){const e=this.M.enableAccumulation,t=this.O.convergenceMetric()>=1,i=!e||this.M.convergenceMetric()>=1,a=!this.enableGI||this.Z.convergenceMetric()>=1;return i&&t&&a}isSuperSamplingConverged(){return this.A/this.H.length>=1}render(e,t,i,a){if(this.needsUpdate&&(this.G(),this.A=0,this.jitterIndex=0,this.needsUpdate=!1,this.autoSAOClear=!0,this.autoShadowsClear=!0),!this.F||this.F.uuid===i.uuid&&this.V.uuid===t.uuid||(this.F=i,this.V=t,this.W.camera=this.F,this.W.scene=this.V,this.K.F=this.F,this.K.J.copy(this.F.projectionMatrix)),this.bInitialized||this.Y(e,t,i,a),this.q(t),this.enableGI&&this.X.generateVPLs(t,this.areaLights[0],10,this.P),this.C&&this.C.render(this.renderer,t,i),this.isSuperSamplingConverged())return void this.$();this.tt(e,t,i),this.et();const r=this.isAccumulationConverged();this.S.enabled=r,this.K.enabled=!r&&this.enableAA,this.it(i),this.j.writeBuffer=this.j.renderTarget2,this.j.readBuffer=this.j.renderTarget1,this.j.render(),i.clearViewOffset(),this.jitterIndex++,this.S.enabled&&this.A++}setSize(e,t){this.renderer&&(e*=this.renderer.getPixelRatio(),t*=this.renderer.getPixelRatio(),this.renderer.screenBufferSize=new THREE.Vector2(e,t)),this.N.setSize(e,t),this.O.setSize(e,t),this.M.setSize(e,t),this.j&&this.j.setSize(e,t),this.needsUpdate=!0}setAntiAliasingFeedBackParams(e,t){this.K&&(this.K.feedBack.x=e,this.K.feedBack.y=t)}updateShadowPlane(e){this.C&&this.C.update(e)}it(e){if(this.enableAA||this.isAccumulationConverged()){const t=this.renderer.getDrawingBufferSize().width,i=this.renderer.getDrawingBufferSize().height,a=this.H[this.jitterIndex%this.H.length];PIXOTRON.jitterCamera(e,a,t,i)}if(this.isAccumulationConverged()){const e=this.H[this.jitterIndex%this.H.length];this.ot(e)}}et(){this.O.enabled||(this.renderer.saoBuffer=this.I.texture);const e=this,t=!this.M.enabled,i=!function(){let t=!0;return e.areaLights.forEach(e=>{e.castShadow||(t=!1)}),t}(),a=0===this.areaLights.length;(t||i||a)&&this.M.lights.forEach(e=>{e.shadow.map=this._})}$(){this.renderCompleteCallback&&!this.renderCompleteCallbackCalled&&(this.renderCompleteCallback(),this.renderCompleteCallbackCalled=!0)}q(e){const t=this;this.punctualLights=[],this.areaLights=[],e.traverseVisible(function(e){(e instanceof THREE.DirectionalLight||e instanceof THREE.SpotLight)&&e.castShadow&&t.punctualLights.push(e),e instanceof THREE.RectAreaLight&&e.castShadow&&(e.shadow=e.shadow?e.shadow:{},e.A=e.A?e.A:0,t.areaLights.push(e))}),this.M.lights=this.areaLights}ot(e){this.punctualLights.forEach(t=>{PIXOTRON.jitterCamera(t.shadow.camera,e,t.shadow.mapSize.x,t.shadow.mapSize.y)})}Y(e,t,i,a){this.renderer=e,this.F=i,this.V=t,this.U=a,this.W=new THREE.RenderPass(t,i),this.j=new THREE.EffectComposer(this.renderer,a);const r=e.getDrawingBufferSize();this.S.setSize(r.width,r.height),this.renderer.screenBufferSize=new THREE.Vector2(r.width,r.height),this.K=new PIXOTRON.TemporalAAPass(i,this.N),this.st=new THREE.ShaderPass(THREE.CopyShader),this.st.needsSwap=!1,this.st.renderToScreen=!a,this.j.addPass(this.W),THREE.OutlinePass&&(this.k=new THREE.OutlinePass(new THREE.Vector2(r.width,r.height),t,i),this.j.addPass(this.k)),this.B=new PIXOTRON.UnrealBloomPass(this.N,new THREE.Vector2(r.width,r.height),.86,1,.98),this.j.addPass(this.B),this.j.addPass(this.S),this.j.addPass(this.K),this.B.enabled=!1,this.j.addPass(this.st),this.bInitialized=!0;const o=new THREE.MeshBasicMaterial({color:16777215}),s=new THREE.MeshBasicMaterial({color:0});PIXOTRON.renderPass(e,o,this._),PIXOTRON.renderPass(e,s,this.I),this.punctualLights=[],this.areaLights=[],this.jitterIndex=0}tt(e,t,i){const a=e.getDrawingBufferSize().width,r=e.getDrawingBufferSize().height,o=this.H[this.jitterIndex%this.H.length];PIXOTRON.jitterCamera(i,o,a,r),this.N.render(e,t,i),this.O.render(e,i,this.N,this.D),this.M.render(e,t,i),this.enableGI&&this.Z.render(e,t,i,this.X,this.areaLights[0]),i.clearViewOffset(),!this.j.renderTarget1.depthTexture&&this.N.at&&(this.j.renderTarget1.depthTexture=this.N.at,this.j.renderTarget2.depthTexture=this.N.at)}G(){this.O.needsUpdate=!!this.autoSAOClear,this.M.needsUpdate=!!this.autoShadowsClear,this.S.needsUpdate=!0,this.enableGI&&(this.Z.needsUpdate=!0),this.renderCompleteCallbackCalled=!1}}},function(e,t,i){i(5),e.exports=PIXOTRON.TextureAreaLightFilter=class{constructor(e){this.rt=e,PIXOTRON.isPowerOfTwo(this.rt.image)||(this.rt.image=PIXOTRON.makePowerOfTwo(this.rt.image));const t={format:THREE.RGBAFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter,type:this.rt.type,generateMipmaps:!1,anisotropy:this.rt.anisotropy,encoding:this.rt.encoding},i={x:e.image.width,y:e.image.height},a=Math.max(i.x,i.y);this.nt=Math.log(a)/Math.log(2)+1,this.ht=[],this.lt=[],this.ct=[],this.ct.push(.1);for(let e=0;e<this.nt;e++){let a=new THREE.WebGLRenderTarget(i.x,i.y,t);this.ht.push(a),a=new THREE.WebGLRenderTarget(i.x,i.y,t),this.lt.push(a),i.x=Math.ceil(i.x/2),i.y=Math.ceil(i.y/2),e<2&&this.ct.push(1),e<5&&this.ct.push(2),e>5&&this.ct.push(3)}const r=PIXOTRON.AreaLightTextureFilterShader;this.ut=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,defines:{NUM_SAMPLES:16}})}update(e){let t=this.rt;const i=new THREE.DataTexture(null,this.rt.image.width,this.rt.image.height);i.minFilter=THREE.LinearMipMapLinearFilter;for(let a=0;a<this.nt;a++){this.ut.uniforms.filterRadius.value=this.ct[a],this.ut.uniforms.texSize.value.set(this.ht[a].width,this.ht[a].height),this.ut.uniforms.direction.value.set(1,0),this.ut.uniforms.colorTexture.value=t,PIXOTRON.renderPass(e,this.ut,this.ht[a],!0),this.ut.uniforms.direction.value.set(0,1),this.ut.uniforms.colorTexture.value=this.ht[a].texture,PIXOTRON.renderPass(e,this.ut,this.lt[a],!0),t=this.lt[a];const r=new Uint8Array(4*t.width*t.height);e.setRenderTarget(t),e.readRenderTargetPixels(t,0,0,t.width,t.height,r),i.mipmaps[a]={data:r,width:t.width,height:t.height}}return i.generateMipmaps=!1,i.needsUpdate=!0,this.dt(),i}dt(){for(let e=0;e<this.nt;e++)this.ht[e].dispose(),this.ht[e]=null,this.lt[e].dispose(),this.lt[e]=null}}},function(e,t){e.exports=PIXOTRON.AreaLightTextureFilterShader={uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)},filterRadius:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D colorTexture;","uniform float filterRadius;","uniform vec2 texSize;","uniform vec2 direction;","void main() {","float INV_NUM_SAMPLES = 1.0/float(NUM_SAMPLES - 1);","vec2 delta = direction * filterRadius * INV_NUM_SAMPLES/ texSize;","float fSigma = filterRadius;","float weightSum = 1.;","vec4 colorSum = texture2D( colorTexture, vUv) * weightSum;","for( int i = 1; i < NUM_SAMPLES; i ++ ) {","float x = float(i);","vec2 uvOffset = delta * x;","vec2 vUv1 = vUv + uvOffset;","float w = 1.;","if( vUv1.x < 0.0 || vUv1.x > 1.0 || vUv1.y < 0.0 || vUv1.y > 1.0 ) {","w = 0.0;","}","colorSum += texture2D( colorTexture, vUv1) * w;","weightSum += w;","vec2 vUv2 = vUv - uvOffset;","w = 1.;","if( vUv2.x < 0.0 || vUv2.x > 1.0 || vUv2.y < 0.0 || vUv2.y > 1.0 ) {","w = 0.0;","}","colorSum += texture2D( colorTexture, vUv2) * w;","weightSum += w;","}","gl_FragColor = vec4(colorSum/weightSum);","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.BVHManager=class{constructor(){this.meshes=[]}buildBVHTree(e){let t=null;e.geometry.index&&(t=e.geometry.index.array);let a=e.geometry.attributes.position.array,u=e.geometry.attributes.uv?e.geometry.attributes.uv.array:void 0;if(t){const e=new Float32Array(3*t.length);for(let i=0;i<t.length;i++){const r=3*t[i];e[3*i]=a[r],e[3*i+1]=a[r+1],e[3*i+2]=a[r+2]}if(a=e,u){const e=new Float32Array(2*t.length);for(let i=0;i<t.length;i++){const a=2*t[i];e[2*i]=u[a],e[2*i+1]=u[a+1]}u=e}}return new class{constructor(e,t,a){this.positions=e,this.uvs=t,this._maxTrianglesPerNode=a||10,this._bboxArray=function(e){let t,i,a,r,o,s,n,l,c,u,d,m,f,v,p;const x=e.length/9,w=new Float32Array(7*x);for(let g=0;g<x;g++)t=e[9*g],i=e[9*g+1],a=e[9*g+2],r=e[9*g+3],o=e[9*g+4],s=e[9*g+5],n=e[9*g+6],l=e[9*g+7],c=e[9*g+8],h(w,g,g,u=Math.min(Math.min(t,r),n),d=Math.min(Math.min(i,o),l),m=Math.min(Math.min(a,s),c),f=Math.max(Math.max(t,r),n),v=Math.max(Math.max(i,o),l),p=Math.max(Math.max(a,s),c));return w}(e),this._bboxHelper=new Float32Array(this._bboxArray.length),this._bboxHelper.set(this._bboxArray);const r=e.length/9,o=this.calcExtents(0,r,i);for(this._rootNode=new c(o[0],o[1],0,r,0),this._nodesToSplit=[this._rootNode];this._nodesToSplit.length>0;){const e=this._nodesToSplit.pop();this.splitNode(e)}}calcExtents(e,t,i){if(i=i||0,e>=t)return[{x:0,y:0,z:0},{x:0,y:0,z:0}];let a=Number.MAX_VALUE,r=Number.MAX_VALUE,o=Number.MAX_VALUE,s=-Number.MAX_VALUE,n=-Number.MAX_VALUE,l=-Number.MAX_VALUE;for(let i=e;i<t;i++)a=Math.min(this._bboxArray[7*i+1],a),r=Math.min(this._bboxArray[7*i+2],r),o=Math.min(this._bboxArray[7*i+3],o),s=Math.max(this._bboxArray[7*i+4],s),n=Math.max(this._bboxArray[7*i+5],n),l=Math.max(this._bboxArray[7*i+6],l);return[{x:a-i,y:r-i,z:o-i},{x:s+i,y:n+i,z:l+i}]}splitNode(e){if(e.elementCount()<=this._maxTrianglesPerNode||0===e.elementCount())return;const t=e._startIndex,a=e._endIndex,r=[[],[],[]],o=[[],[],[]],s=[e.centerX(),e.centerY(),e.centerZ()],n=[e._extentsMax.x-e._extentsMin.x,e._extentsMax.y-e._extentsMin.y,e._extentsMax.z-e._extentsMin.z],h=[];h.length=3;for(let e=t;e<a;e++){h[0]=.5*(this._bboxArray[7*e+1]+this._bboxArray[7*e+4]),h[1]=.5*(this._bboxArray[7*e+2]+this._bboxArray[7*e+5]),h[2]=.5*(this._bboxArray[7*e+3]+this._bboxArray[7*e+6]);for(let t=0;t<3;t++)h[t]<s[t]?r[t].push(e):o[t].push(e)}const u=[];if(u.length=3,u[0]=0===r[0].length||0===o[0].length,u[1]=0===r[1].length||0===o[1].length,u[2]=0===r[2].length||0===o[2].length,u[0]&&u[1]&&u[2])return;const d=[0,1,2];let m,f;d.sort(function(e,t){return n[t]-n[e]});for(let e=0;e<3;e++){const t=d[e];if(!u[t]){m=r[t],f=o[t];break}}const v=t,p=v+m.length,x=p,w=a;let g,T=e._startIndex;const R=m.concat(f);for(let e=0;e<R.length;e++)g=R[e],l(this._bboxArray,g,this._bboxHelper,T),T++;const E=this._bboxHelper.subarray(7*e._startIndex,7*e._endIndex);this._bboxArray.set(E,7*e._startIndex);const D=this.calcExtents(v,p,i),M=this.calcExtents(x,w,i),P=new c(D[0],D[1],v,p,e._level+1),S=new c(M[0],M[1],x,w,e._level+1);e._node0=P,e._node1=S,e.clearShapes(),this._nodesToSplit.push(P),this._nodesToSplit.push(S)}intersectRay(e,t,i){const a=[this._rootNode],l=[],h=[];let c;const u=new THREE.Vector3(1/t.x,1/t.y,1/t.z);for(;a.length>0;){const t=a.pop();if(o(e,u,t))for(t._node0&&a.push(t._node0),t._node1&&a.push(t._node1),c=t._startIndex;c<t._endIndex;c++)l.push(this._bboxArray[7*c])}const d=new THREE.Vector3,m=new THREE.Vector3,f=new THREE.Vector3,v=new THREE.Vector2,p=new THREE.Vector2,x=new THREE.Vector2,w=new THREE.Vector3,g=new THREE.Vector3,T=new THREE.Vector2,R=new THREE.Vector3(e.x,e.y,e.z),E=new THREE.Vector3(t.x,t.y,t.z);for(c=0;c<l.length;c++){const e=l[c];d.fromArray(this.positions,9*e),m.fromArray(this.positions,9*e+3),f.fromArray(this.positions,9*e+6);const t=r(d,m,f,R,E,i);t&&(this.uvs&&(v.fromArray(this.uvs,6*e),p.fromArray(this.uvs,6*e+2),x.fromArray(this.uvs,6*e+4),s(t,d,m,f,v,p,x,w,T)),n(d,m,f,g),h.push({point:t,uv:T,face:{index:e,a:d.clone(),b:m.clone(),c:f.clone(),normal:g}}))}return h}}(a,u,7)}add(e){this.meshes[e.uuid]||(this.meshes.push({id:e.uuid,val:e}),e.bvh=this.buildBVHTree(e))}intersectRay(e){const t=new THREE.Ray,i=new THREE.Matrix4;let a=[];for(let r=0;r<this.meshes.length;r++){const o=this.meshes[r].val;t.origin.copy(e.origin),t.direction.copy(e.direction),i.getInverse(o.matrixWorld),t.origin.applyMatrix4(i),t.direction.transformDirection(i);const s=o.bvh.intersectRay(t.origin,t.direction,!0);s.length>0&&s.forEach(function(t){t.object=o,t.point.applyMatrix4(o.matrixWorld),t.distance=e.origin.distanceToSquared(t.point)}),a=a.concat(s)}return a.sort(function(e,t){return e.distance>t.distance}),a}};const i=1e-6;function a(e,t,i,a){const r={min:0,max:0};return a>=0?(r.min=(e-i)*a,r.max=(t-i)*a):(r.min=(t-i)*a,r.max=(e-i)*a),r}const r=function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Vector3;return function(r,o,s,n,l,h){t.subVectors(o,r),i.subVectors(s,r),a.crossVectors(t,i);let c,u=l.dot(a);if(u>0){if(h)return null;c=1}else{if(!(u<0))return null;c=-1,u=-u}e.subVectors(n,r);const d=c*l.dot(i.crossVectors(e,i));if(d<0)return null;const m=c*l.dot(t.cross(e));if(m<0)return null;if(d+m>u)return null;const f=-c*e.dot(a);if(f<0)return null;const v=f/u;return(new THREE.Vector3).copy(l).multiplyScalar(v).add(n)}}();function o(e,t,i){const r=a(i._extentsMin.x,i._extentsMax.x,e.x,t.x),o=a(i._extentsMin.y,i._extentsMax.y,e.y,t.y);if(r.min>o.max||o.min>r.max)return!1;(o.min>r.min||r.min!=r.min)&&(r.min=o.min),(o.max<r.max||r.max!=r.max)&&(r.max=o.max);const s=a(i._extentsMin.z,i._extentsMax.z,e.z,t.z);return!(r.min>s.max||s.min>r.max||((s.min>r.min||r.min!=r.min)&&(r.min=s.min),(s.max<r.max||r.max!=r.max)&&(r.max=s.max),r.max<0))}function s(e,t,i,a,r,o,s,n,l){return THREE.Triangle.getBarycoord(e,t,i,a,n),r.multiplyScalar(n.x),o.multiplyScalar(n.y),s.multiplyScalar(n.z),r.add(o).add(s),l.copy(r),l}function n(e,t,i,a){const r=a||new THREE.Vector3,o=new THREE.Vector3;r.subVectors(i,t),o.subVectors(e,t),r.cross(o);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}function l(e,t,i,a){i[7*a]=e[7*t],i[7*a+1]=e[7*t+1],i[7*a+2]=e[7*t+2],i[7*a+3]=e[7*t+3],i[7*a+4]=e[7*t+4],i[7*a+5]=e[7*t+5],i[7*a+6]=e[7*t+6]}function h(e,t,i,a,r,o,s,n,l){e[7*t]=i,e[7*t+1]=a,e[7*t+2]=r,e[7*t+3]=o,e[7*t+4]=s,e[7*t+5]=n,e[7*t+6]=l}class c{constructor(e,t,i,a,r){this._extentsMin=e,this._extentsMax=t,this._startIndex=i,this._endIndex=a,this._level=r,this._node0=null,this._node1=null}elementCount(){return this._endIndex-this._startIndex}centerX(){return.5*(this._extentsMin.x+this._extentsMax.x)}centerY(){return.5*(this._extentsMin.y+this._extentsMax.y)}centerZ(){return.5*(this._extentsMin.z+this._extentsMax.z)}clearShapes(){this._startIndex=-1,this._endIndex=-1}}},function(e,t,i){i(8),e.exports=PIXOTRON.GBufferPass=class{constructor(e){e=e||{},this.forceDepthAndNormalPass=void 0===e.forceDepthAndNormalPass||e.forceDepthAndNormalPass,this.packingMode=void 0!==e.packingMode?e.packingMode:PIXOTRON.GBufferPass.DEPTH_NORMAL_16,this.vt=new THREE.MeshNormalMaterial,this.ft=new THREE.ShaderMaterial(PIXOTRON.PackingShader_DepthNormal16),this.pt=void 0===e.linearDepth||e.linearDepth,this.pt?(this.wt=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.forceDepthAndNormalPass=!0):(this.wt=new THREE.MeshDepthMaterial,this.wt.depthPacking=THREE.RGBADepthPacking)}dispose(){this.Et&&this.Et.dispose(),this.Rt&&this.Rt.dispose(),this.Tt&&this.Tt.dispose()}setSize(e,t){this.Et&&this.Et.setSize(e,t),this.Rt&&this.Rt.setSize(e,t),this.Tt&&this.Tt.setSize(e,t)}render(e,t,i){this.xt||this.Y(e);const a=e.getClearColor(),r=e.getClearAlpha(),o=e.autoClear,s=e.shadowMap.enabled;e.shadowMap.enabled=!1,e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.Dt(e,t,i),e.autoClear=o,e.shadowMap.enabled=s,e.setClearColor(a,r)}Y(e){const t=e.extensions.get("WEBGL_depth_texture"),i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height;if(!this.forceDepthAndNormalPass&&t&&!this.Tt){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.Tt=new THREE.WebGLRenderTarget(i,a,e),this.at||(this.at=new THREE.DepthTexture,this.at.type=THREE.UnsignedShortType),this.Tt.depthTexture=this.at}if(!t||this.forceDepthAndNormalPass){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.packingMode===PIXOTRON.GBufferPass.NONE&&(this.Rt||(this.Rt=new THREE.WebGLRenderTarget(i,a,e),this.Rt.depthTexture=this.at),this.Tt||(this.Tt=new THREE.WebGLRenderTarget(i,a,e),this.Tt.depthTexture=this.at)),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(this.Et||(this.Et=new THREE.WebGLRenderTarget(i,a,e),this.Et.depthTexture=this.at))}this.xt=!0}Dt(e,t,i){t.traverse(function(e){if(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints){let t=e.material&&e.material.transparent||e.castAO;(t=(t=e.material&&e.material.transparent&&!e.material.isShadowMaterial||!!e.castAO)||e.material.alphaTest>0)&&(e.aoVisibility=e.visible,e.visible=!1)}});const a=e.extensions.get("WEBGL_depth_texture");a&&!this.forceDepthAndNormalPass&&(t.overrideMaterial=this.vt,e.render(t,i,this.Tt,!0),t.overrideMaterial=null),a&&!this.forceDepthAndNormalPass||(this.packingMode===PIXOTRON.GBufferPass.NONE&&(t.overrideMaterial=this.vt,e.render(t,i,this.Tt,!0),t.overrideMaterial=null,t.overrideMaterial=this.wt,this.wt.isMeshDepthMaterial||(this.wt.uniforms.cameraNearFar.value.x=i.near,this.wt.uniforms.cameraNearFar.value.y=i.far),e.render(t,i,this.Rt,!0),t.overrideMaterial=null),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(t.overrideMaterial=this.ft,this.ft.uniforms.cameraNearFar.value.x=i.near,this.ft.uniforms.cameraNearFar.value.y=i.far,e.render(t,i,this.Et,!0),t.overrideMaterial=null)),t.traverse(function(e){e.aoVisibility&&(e.visible=e.aoVisibility,e.aoVisibility=void 0)})}},PIXOTRON.GBufferPass.NONE=0,PIXOTRON.GBufferPass.DEPTH_NORMAL_16=1},function(e,t){e.exports=PIXOTRON.PackingShader_DepthNormal16={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewNormal;      varying vec3 viewPosition;      void main() {        viewNormal = normalMatrix * normal;        viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      }",fragmentShader:"varying vec3 viewNormal;    uniform vec2 cameraNearFar;    varying vec3 viewPosition;      vec2 pack16(float value){          float sMax = 65535.0;          int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);          int digit0 = v/256;          int digit1 = v-digit0*256;          return vec2(float(digit0)/255.0, float(digit1)/255.0);      }            vec2 packNormal(vec3 n){          float p = sqrt(n.z*8.0+8.0);          return vec2(n.xy/p + 0.5);      }            float linstep(float edge0, float edge1, float value){        return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);      }            void main() {        float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);        vec2 packedZ = pack16(pow(linearZ, 0.5));        vec2 packedNormal = packNormal(normalize(viewNormal));        gl_FragColor = vec4(packedZ.x, packedZ.y, packedNormal.x, packedNormal.y);      }"},e.exports=PIXOTRON.PackingShader_Depth32={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewPosition;    void main() {      viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"#include <packing>  uniform vec2 cameraNearFar;  varying vec3 viewPosition;    float linstep(float edge0, float edge1, float value){      return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);    }        void main() {      float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);      vec4 packedZ = packDepthToRGBA(pow(linearZ, 0.5));      gl_FragColor = packedZ;    }"}},function(e,t,i){i(0),i(10),i(1),e.exports=PIXOTRON.AccumulativeSAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.bias=void 0!==e.bias?e.bias:.001,this.numSamples=void 0!==e.numSamples?e.numSamples:600,this.Nt=void 0!==e.samplesPerFrame?e.samplesPerFrame:4,this.blurEnabled=!0,this.edgeSharpness=10,this.enabled=!0,this.needsUpdate=!0,this.gt=0,this.Pt(this.numSamples),this.Ot=new THREE.ShaderMaterial(PIXOTRON.AccumulativeSAOShader),this.Ot.uniforms=THREE.UniformsUtils.clone(this.Ot.uniforms),this.Ot.defines.SAMPLES_PER_FRAME=this.Nt,this.Mt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionAOShader),this.A=0}convergenceMetric(){return this.enabled?this.A*this.Nt/(this.Ct-1):1}dispose(){this.St&&(this.St.dispose(),this.Ht.dispose())}render(e,t,i,a){if(this.needsUpdate&&(this.A=0,this.needsUpdate=!1),this.convergenceMetric()>=1)return;this.A++,this.A=Math.min(this.A,this.Ct-1),this.St||this.Y(e),this.Pt(this.numSamples);const r=e.getClearColor(),o=e.getClearAlpha(),s=e.autoClear;e.autoClear=!1;const n=e.getDrawingBufferSize().width,l=e.getDrawingBufferSize().height;this.Ot.uniforms.size.value.set(n,l),this.yt(t,i);const h=this.A%2==0?this.Ht:this.St,c=this.A%2==0?this.St:this.Ht;this._t(e,h,c),this.blurEnabled&&this.convergenceMetric()>0&&(a.edgeSharpness=this.edgeSharpness,a.render(e,c,t,i)),this.zt(e,h,c),e.autoClear=s,e.setClearColor(r),e.setClearAlpha(o),e.saoBuffer=this.smoothTransition?h:c}setSize(e,t){this.Ht&&this.Ht.setSize(e,t),this.St&&this.St.setSize(e,t),this.Ot.uniforms.size.value.set(e,t)}Y(e){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height;if(!this.St){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.St=new THREE.WebGLRenderTarget(t,i,e),this.Ht=new THREE.WebGLRenderTarget(t,i,e)}}_t(e,t,i){this.Ot.uniforms.tAOSumPrevious.value=t,PIXOTRON.renderPass(e,this.Ot,i)}zt(e,t,i){this.smoothTransition&&(this.Mt.uniforms.saoAccumulationBuffer.value=i,this.Mt.uniforms.transition.value=this.convergenceMetric(),PIXOTRON.renderPass(e,this.Mt,t))}yt(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),a=this.Ot.uniforms.saoData.value;a.x=i,a.y=this.intensity,a.z=this.occlusionWorldRadius,a.w=this.A;const r=this.Ot.uniforms.saoBiasEpsilon.value;r.x=this.bias,r.y=.001;const o=this.Ot.uniforms.cameraNearFar.value;let s;o.x=e.near,o.y=e.far,this.Ot.uniforms.ProjectionMatrix.value=e.projectionMatrix,s=t.at?t.at:t.Rt?t.Rt.texture:null;const n=t.Tt?t.Tt.texture:null;let l;t.Rt||(l=t.Et?t.Et.texture:null);let h=t.at?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(h=2),this.Ot.defines.DEPTH_PACKING_MODE=h,this.Ot.defines.DEPTH_NORMAL_TEXTURE=l?1:0,this.Ot.defines.LINEAR_DEPTH=t.pt?1:0,l?this.Ot.uniforms.tNormalDepth.value=l:(this.Ot.uniforms.tNormal.value=n,this.Ot.uniforms.tDepth.value=s),this.Ot.uniforms.tQuasiRandomSamples.value=this.It,this.Ot.uniforms.numQuasiSamples.value=this.It.image.width}Pt(e){e!==this.gt&&(this.gt=e,this.At=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.lerpDistribution,PIXOTRON.insideCircle),this.It=PIXOTRON.createTextureFromRawData(PIXOTRON.randomizeArray(this.At)),this.Ct=this.At.length)}}},function(e,t){e.exports=PIXOTRON.AccumulativeSAOShader={blending:THREE.NoBlending,defines:{SAMPLES_PER_FRAME:4,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1},uniforms:{tQuasiRandomSamples:{type:"t",value:null},tAOSumPrevious:{type:"t",value:null},tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},numQuasiSamples:{type:"f",value:0},saoBiasEpsilon:{type:"v2",value:new THREE.Vector2},size:{type:"v2",value:new THREE.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tAOSumPrevious;","uniform sampler2D tQuasiRandomSamples;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec4 saoBiasEpsilon;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform float numQuasiSamples;","const float f_sampleCount = float( SAMPLES_PER_FRAME );","#include <utilshader>","float getViewDepth( const in float ndcDepth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float getOcclusionFromPositionNormal( const in vec3 centerPosition, const in vec3 centerNormal, const in vec3 samplePosition ) {","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","return max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( d2 + saoBiasEpsilon.y ), 0.0 );","}","vec4 getOcclusion( const in vec3 centerPosition ) {","vec3 centerNormal = getViewNormal( vUv );","float screenOcclusionRadius = 200. * saoData.z * saoData.x / -centerPosition.z;","if( screenOcclusionRadius < 1. ) {","discard;","}","float random = rand( vUv );","float randomAngle = random * PI2 + 2. * PI2 * (saoData.w - 1.0);","float cosAngle = cos(randomAngle); float sinAngle = sin(randomAngle);","mat2 randomRotationMatrix = mat2(cosAngle, sinAngle, -sinAngle, cosAngle);","float texelSize = 1.0/numQuasiSamples;","float occlusionSum = 0.0;","for( int i = 0; i < SAMPLES_PER_FRAME; i ++ ) {","float offset = (mod((float(i) + (saoData.w - 1.) * f_sampleCount), numQuasiSamples) + 0.5 ) * texelSize;","vec2 randomSample = randomRotationMatrix * texture2D( tQuasiRandomSamples, vec2(offset, 0.5)).xw * screenOcclusionRadius/size;","vec2 sampleUv = vUv + randomSample;","float sampleDepthNDC = decodeDepth( sampleUv );","if( sampleDepthNDC >= ( 1.0 - EPSILON ) ) {","continue;","}","#if LINEAR_DEPTH == 0","float sampleViewDepth = getViewDepth( sampleDepthNDC );","vec3 samplePosition = getViewPositionFromViewZ( sampleUv, sampleViewDepth );","#else","sampleDepthNDC = mix(-cameraNearFar.x, -cameraNearFar.y, sampleDepthNDC);","vec3 samplePosition = getViewPositionFromViewZ(sampleUv, sampleDepthNDC);","#endif","float occlusion = getOcclusionFromPositionNormal( centerPosition, centerNormal, samplePosition );","occlusionSum += occlusion;","}","float occlusion = occlusionSum * saoData.y * 2.0 / f_sampleCount;","return vec4(clamp(occlusion,0., 1.));","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewDepth = getViewDepth( centerDepth );","#else","float centerViewDepth = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 viewPosition = getViewPositionFromViewZ(vUv, centerViewDepth);","float occlusion = getOcclusion( viewPosition ).r;","float prevOcclusionSum = texture2D(tAOSumPrevious, vUv).r;","float finalOcclusion = mix(prevOcclusionSum, occlusion, 1./saoData.w);","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = clamp(finalOcclusion, 0., 1.);","}"].join("\n")}},function(e,t,i){i(0),i(12),e.exports=PIXOTRON.SAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.bias=void 0!==e.bias?e.bias:.001,this.blurEnabled=!0,this.edgeSharpness=1,this.needsUpdate=!0,this.Ft=new THREE.ShaderMaterial(PIXOTRON.SAOShader),this.Ft.uniforms=THREE.UniformsUtils.clone(this.Ft.uniforms),this.Ft.defines=Object.assign({},this.Ft.defines),this.A=0}dispose(){this.St&&(this.St.dispose(),this.St=null)}setSize(e,t){this.St&&this.St.setSize(e,t),this.Ft.uniforms.size.value.set(e,t)}yt(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),a=this.Ft.uniforms.saoData.value;a.x=i,a.y=this.intensity,a.z=this.occlusionWorldRadius,a.w=this.A++;const r=this.Ft.uniforms.saoBiasEpsilon.value;r.x=this.bias,r.y=.001;const o=this.Ft.uniforms.cameraNearFar.value;let s;o.x=e.near,o.y=e.far,this.Ft.uniforms.ProjectionMatrix.value=e.projectionMatrix,s=t.at?t.at:t.Rt?t.Rt.texture:null;const n=t.Tt?t.Tt.texture:null;let l;t.Rt||(l=t.Et?t.Et.texture:null);let h=t.at?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(h=2),this.Ft.defines.DEPTH_PACKING_MODE=h,this.Ft.defines.DEPTH_NORMAL_TEXTURE=l?1:0,this.Ft.defines.LINEAR_DEPTH=t.pt?1:0,l?this.Ft.uniforms.tNormalDepth.value=l:(this.Ft.uniforms.tNormal.value=n,this.Ft.uniforms.tDepth.value=s)}convergenceMetric(){return this.A>1?1:0}render(e,t,i,a){this.needsUpdate&&(this.A=0,this.needsUpdate=!1),this.convergenceMetric(),this.St||this.Y(e);const r=e.getDrawingBufferSize().width,o=e.getDrawingBufferSize().height;this.Ft.uniforms.size.value.set(r,o),this.yt(t,i);const s=e.getClearColor(),n=e.getClearAlpha(),l=e.autoClear;e.autoClear=!1,PIXOTRON.renderPass(e,this.Ft,this.St),this.blurEnabled&&(a.edgeSharpness=this.edgeSharpness,a.render(e,this.St,t,i)),e.autoClear=l,e.setClearColor(s),e.setClearAlpha(n),e.saoBuffer=this.St}Y(e){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height;if(!this.St){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.St=new THREE.WebGLRenderTarget(t,i,e)}}}},function(e,t){e.exports=PIXOTRON.SAOShader={defines:{NUM_SAMPLES:11,NUM_SPIRAL_TURNS:3,DEPTH_NORMAL_TEXTURE:0,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},size:{type:"v2",value:new THREE.Vector2(512,512)},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},saoBiasEpsilon:{type:"v2",value:new THREE.Vector2}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform vec2 cameraNearFar;","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec2 saoBiasEpsilon;","uniform vec2 size;","#include <utilshader>","const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );","float getViewZFromNDCZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float random3(vec3 v) { ","v  = fract(v * 443.8975);","v += dot(v, v.yzx + 19.19);","return fract((v.x + v.y) * v.z);","}","vec3 getPositionFromOffset(const in vec2 uv, const in vec2 offset, const in float screenSpaceRadius) {","vec2 uvOffset = uv + floor(screenSpaceRadius * offset)/size;","float d = decodeDepth(uvOffset);","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( d );","return getViewPositionFromViewZ( uvOffset, centerViewZ );","#else","d = mix(-cameraNearFar.x, -cameraNearFar.y, d);","return getViewPositionFromViewZ(uvOffset, d);","#endif","}","float getOcclusion(const in vec2 uv, const in int id, const in float randomAngle, const in float occlusionSphereRadius, const in vec3 centerPosition, const in vec3 centerNormal) {","float screenSpaceRadius = (float(id) + mod(randomAngle, 1.) + 0.5) * INV_NUM_SAMPLES; ","float angle = screenSpaceRadius * (float(NUM_SPIRAL_TURNS) * 6.28) + randomAngle; ","screenSpaceRadius = (screenSpaceRadius * occlusionSphereRadius);","vec2 offset = vec2(cos(angle), sin(angle));","vec3 samplePosition = getPositionFromOffset(uv, offset, screenSpaceRadius);","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","float ao = max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( d2 + saoBiasEpsilon.y ), 0.0 );","return ao;","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( centerDepth );","#else","float centerViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 centerPosition = getViewPositionFromViewZ( vUv, centerViewZ );","vec3 centerNormal = getViewNormal(vUv);","float occlusionSphereScreenRadius = 200. * saoData.z/ (-centerPosition.z);","if( occlusionSphereScreenRadius < 1. ) {","discard;","}","float randomAngle = 6.2 * random3( vec3( vUv, saoData.w * 0.1 ) );","float sum = 0.0;","sum += getOcclusion(vUv, 0, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 1, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 2, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 3, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 4, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 5, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 6, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 7, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 8, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 9, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 10, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","float aoValue = sum * saoData.y * INV_NUM_SAMPLES;","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = max( aoValue, 0.0 );","}"].join("\n")}},function(e,t,i){function a(e,t){e.traverse(function(e){(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints)&&((t?e.castShadow:e.receiveShadow)||(e.oldVisibility=e.visible,e.visible=!1))})}function r(e){e.traverse(function(e){e.oldVisibility&&(e.visible=e.oldVisibility,e.oldVisibility=void 0)})}i(0),i(1),i(14),e.exports=PIXOTRON.ShadowPass=class{constructor(e){e=e||{},this.linearDepth=void 0!==e.linearDepth?e.linearDepth:1,this.shadowMapResolution=void 0!==e.shadowMapResolution?e.shadowMapResolution:1024,this.shadowRadius=void 0!==e.shadowRadius?e.shadowRadius:1,this.shadowQuality=void 0!==e.shadowQuality?e.shadowQuality:1,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.shadowBiasMultiplier=void 0!==e.shadowBiasMultiplier?e.shadowBiasMultiplier:1,this.numSamples=void 0!==e.numSamples?e.numSamples:100,this.side=void 0!==e.side?e.side:THREE.FrontSide;const t=void 0!==e.nearPlane?e.nearPlane:.1,i=void 0!==e.farPlane?e.farPlane:10,a=void 0!==e.fov?e.fov:110;this.Vt=new THREE.PerspectiveCamera(a,1,t,i),this.gt=0,this.Ut(this.numSamples),this.A=0,this.Xt=0,this.bt=new THREE.Vector3,this.Lt=new THREE.Vector3(0,-1,0),this.Bt=new THREE.Vector3,this.kt=new THREE.Matrix4,this.lights=[],this.enabled=!0,this.enableAccumulation=!0,this.needsUpdate=!0,this.shadowRecieverBBox=null}convergenceMetric(){if(!this.enabled)return 1;let e=0;return this.lights.forEach(t=>{t.castShadow&&e++}),0!==e?this.A/(e*this.Wt.length):1}render(e,t,i){if(this.needsUpdate&&(this.A=0,this.Xt=0,this.needsUpdate=!1,this.lights.forEach(e=>{e.A=0})),!this.enableAccumulation&&this.A>0)return;if(this.convergenceMetric()>=1)return;const a=e.getDrawingBufferSize().width,r=e.getDrawingBufferSize().height;this.Zt||(this.Vt.layers.mask=i.layers.mask,this.jt(a,r)),this.Ut(this.numSamples);const o=e.getClearColor(),s=e.getClearAlpha(),n=e.autoClear;let l,h;this.lights.forEach(a=>{this.A=Math.min(this.A,this.lights.length*this.Wt.length),this.A++,a.A++,this.Xt+=a.intensity,this.Gt(a),this.Qt(e,t,this.bt,this.Zt),l=this.A%2==0?this.Kt:this.Jt,h=this.A%2==0?this.Jt:this.Kt,this.Yt(e,t,i,l,h,a),this.smoothTransition&&this.A===this.lights.length&&PIXOTRON.blit(e,h,this.qt)}),this.smoothTransition&&(this.Mt.uniforms.shadowAccumulationBuffer.value=h,this.Mt.uniforms.firstFrameShadowBuffer.value=this.qt,this.Mt.uniforms.transition.value=this.convergenceMetric(),PIXOTRON.renderPass(e,this.Mt,l)),e.autoClear=n,e.setClearColor(o),e.setClearAlpha(s),this.lights.forEach(e=>{e.shadow.map=this.smoothTransition?l:h})}setSize(e,t){this.Kt&&this.Kt.setSize(e,t),this.Jt&&this.Jt.setSize(e,t),this.Zt&&this.Zt.setSize(e,t),this.qt&&this.qt.setSize(e,t),this.$t&&this.$t.uniforms.shadowBufferSize.value.set(e,t)}jt(e,t){const i={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.Zt=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,i),this.Kt=new THREE.WebGLRenderTarget(e,t,i),this.Jt=new THREE.WebGLRenderTarget(e,t,i),this.qt=new THREE.WebGLRenderTarget(e,t,i),this.Zt.texture.generateMipmaps=!1,this.Kt.texture.generateMipmaps=!1,this.Jt.texture.generateMipmaps=!1,this.qt.texture.generateMipmaps=!1,this.linearDepth?(this.wt=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.wt.uniforms=THREE.UniformsUtils.clone(this.wt.uniforms),this.wt.side=this.side):this.wt=new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking,side:this.side}),this.$t=new THREE.ShaderMaterial(PIXOTRON.AccumulativeShadowsShader),this.$t.uniforms=THREE.UniformsUtils.clone(this.$t.uniforms),this.$t.uniforms.shadowBufferSize.value=new THREE.Vector2(e,t),this.$t.uniforms.shadowMap.value=this.Zt,this.$t.uniforms.shadowData.value=new THREE.Vector4(0,1,1,1),this.$t.uniforms.shadowMapResolution.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.$t.defines.SHADOW_QUALITY=this.shadowQuality,this.$t.defines.LINEAR_DEPTH=this.linearDepth,this.Mt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionShadowShader),this.Mt.uniforms=THREE.UniformsUtils.clone(this.Mt.uniforms)}Yt(e,t,i,o,s,n){this.Vt.matrixWorldInverse.getInverse(this.Vt.matrixWorld),this.kt.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.kt.multiply(this.Vt.projectionMatrix),this.kt.multiply(this.Vt.matrixWorldInverse),this.$t.uniforms.shadowMatrix.value.copy(this.kt),this.$t.uniforms.shadowData.value.x=this.Xt,this.$t.uniforms.shadowData.value.y=this.shadowRadius,this.$t.uniforms.shadowData.value.z=this.shadowBiasMultiplier,this.$t.uniforms.shadowData.value.w=n.intensity,this.$t.uniforms.shadowAccumulationBuffer.value=o,this.$t.uniforms.vplPosition.value=this.Vt.position,this.$t.uniforms.cameraNearFar.value.x=this.Vt.near,this.$t.uniforms.cameraNearFar.value.y=this.Vt.far,e.setClearColor(0),a(t,!1);const l=e.shadowMap.enabled;e.shadowMap.enabled=!1,t.overrideMaterial=this.$t,e.render(t,i,s,!0),t.overrideMaterial=null,r(t),e.shadowMap.enabled=l}Qt(e,t,i,o){a(t,!0),this.Vt.position.copy(i),this.Bt.copy(i),this.Bt.addScaledVector(this.Lt,10),this.Vt.lookAt(this.Bt),this.Vt.updateMatrixWorld(),t.overrideMaterial=this.wt,this.linearDepth&&(this.wt.uniforms.cameraNearFar.value.x=this.Vt.near,this.wt.uniforms.cameraNearFar.value.y=this.Vt.far),e.setClearColor(0),e.render(t,this.Vt,o,!0),t.overrideMaterial=null,r(t)}Gt(e){let t=e.A-1;const i=e.matrixWorld;t%=this.Wt.length-1;const a=this.Wt[t];if(this.bt.x=(a.x-.5)*e.width,this.bt.z=0,this.bt.y=(a.y-.5)*e.height,this.bt.applyMatrix4(i),this.Lt.set(0,0,1),this.Lt.transformDirection(i),this.shadowRecieverBBox){const e=PIXOTRON.calculateFOV(this.shadowRecieverBBox,this.bt,this.Lt);this.setFOV(e)}}setShadowRecieverBBox(e){this.shadowRecieverBBox=e}setFOV(e){this.Vt.fov=e,this.Vt.updateProjectionMatrix()}Ut(e){e!==this.gt&&(this.gt=e,this.Wt=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.Wt=PIXOTRON.randomizeArray(this.Wt),this.Wt.splice(0,0,new THREE.Vector2(.5,.5)))}}},function(e,t){e.exports=PIXOTRON.AccumulativeShadowsShader={defines:{SHADOW_QUALITY:1,LINEAR_DEPTH:1},uniforms:{shadowMap:{value:null},shadowAccumulationBuffer:{value:null},shadowBufferSize:{value:null},shadowMatrix:{value:new THREE.Matrix4},vplPosition:{value:new THREE.Vector3},shadowData:{value:new THREE.Vector4},cameraNearFar:{value:new THREE.Vector2},shadowMapResolution:{value:null},normalBias:{value:1}},vertexShader:["varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec3 vplPosition;","uniform mat4 shadowMatrix;","uniform float normalBias;","void main() {","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","viewNormal = normalize(normalMatrix * normal);","vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;","lightVector = vplPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;","lightVector = normalize(lightVector);","shadowCoord = shadowMatrix * worldPosition;","float nDotL = clamp( dot(lightVector, viewNormal), 0.0, 1.0);","worldPosition.xyz += normalize((modelMatrix * vec4( normal, 0.0 )).xyz) * 0.02 * normalBias * pow( 1.0 -  nDotL * nDotL, 4.);","shadowCoord.xy = (shadowMatrix * worldPosition).xy;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec2 shadowBufferSize;","uniform vec2 shadowMapResolution;","uniform sampler2D shadowMap;","uniform sampler2D shadowAccumulationBuffer;","uniform vec4 shadowData;","uniform vec2 cameraNearFar;","float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {","#if LINEAR_DEPTH == 0","float shadowDepth = unpackRGBAToDepth( texture2D( depths, uv ) );","#else","float nDotL = clamp( dot(normalize(lightVector), normalize(viewNormal)), 0.0, 1.0);","float shadowDepth = pow2(unpackRGBAToDepth(texture2D( depths, uv ))) + 0.01 * shadowData.z;","shadowDepth = shadowDepth * ( cameraNearFar.y - cameraNearFar.x ) + cameraNearFar.x;","#endif","return step( compare, shadowDepth );","}","float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {","const vec2 offset = vec2( 0.0, 1.0 );","vec2 texelSize = vec2( 1.0 ) / size;","vec2 centroidUV = floor( uv * size + 0.5 ) / size;","float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );","float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );","float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );","float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );","vec2 f = fract( uv * size + 0.5 );","float a = mix( lb, lt, f.y );","float b = mix( rb, rt, f.y );","float c = mix( a, b, f.x );","return c;","}","void main() {","float shadowValue = 1.0;","float shadowRadius = shadowData.y;","float shadowBiasMultiplier = shadowData.z;","float nDotL = clamp( dot(lightVector, normalize(viewNormal)), 0.0, 1.0);","float shadowBias = 0.02 *  sqrt( 1.0 -  nDotL * nDotL) / clamp(nDotL, 0.0006,  1.0);","shadowBias = clamp(shadowBias, 0.0001,  0.0003) * shadowBiasMultiplier;","vec3 shadowCoordNDC = shadowCoord.xyz/shadowCoord.w;","shadowCoordNDC.z -= shadowBias;","#if LINEAR_DEPTH == 1","float linearDepth = shadowCoord.z + 2.0*cameraNearFar.y*cameraNearFar.x/(cameraNearFar.y - cameraNearFar.x);","linearDepth *= -((cameraNearFar.y - cameraNearFar.x)/(cameraNearFar.y + cameraNearFar.x));","linearDepth = -linearDepth;","#endif","bvec4 inFrustumVec = bvec4 ( shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoordNDC.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","#if LINEAR_DEPTH == 1","shadowCoordNDC.z = linearDepth;","#endif","if(frustumTest) {","#if SHADOW_QUALITY == 0","shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);","#elif SHADOW_QUALITY == 1","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = (","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#elif SHADOW_QUALITY == 2","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = ( ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#endif","}","float previousAccumulation = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, gl_FragCoord.xy/shadowBufferSize ));","float t = shadowData.w/shadowData.x;","float shadowAccumulation = mix(previousAccumulation, shadowValue, t);","gl_FragColor = packDepthToRGBA(shadowAccumulation);","}"].join("\n")}},function(e,t,i){i(0),i(1),i(16),i(17),e.exports=PIXOTRON.PlaneShadowBakePass=class{constructor(e){e=e||{},this.linearDepth=void 0!==e.linearDepth?e.linearDepth:1,this.shadowMapResolution=void 0!==e.shadowMapResolution?e.shadowMapResolution:1024,this.shadowRadius=void 0!==e.shadowRadius?e.shadowRadius:1,this.shadowQuality=void 0!==e.shadowQuality?e.shadowQuality:1,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.shadowBiasMultiplier=void 0!==e.shadowBiasMultiplier?e.shadowBiasMultiplier:1,this.numSamples=void 0!==e.numSamples?e.numSamples:2e3,this.numSamplesPerFrame=void 0!==e.numSamplesPerFrame?e.numSamplesPerFrame:2,this.onComplete=e.onComplete,this.onProgress=e.onProgress,this.enable=void 0===e.enable||e.enable;const t=void 0!==e.nearPlane?e.nearPlane:.1,i=void 0!==e.farPlane?e.farPlane:10;this.Vt=new THREE.OrthographicCamera(-3,3,3,-3,t,i),this.boundingRadius=10,this.gt=0,this.Ut(this.numSamples),this.A=0,this.bt=new THREE.Vector3,this.Lt=new THREE.Vector3(0,-1,0),this.Bt=new THREE.Vector3,this.kt=new THREE.Matrix4,this.needsUpdate=!0,this.te=new THREE.Mesh(new THREE.PlaneBufferGeometry(1,1),new THREE.MeshBasicMaterial({color:16777215})),this.te.rotation.x=-Math.PI/2,this.te.receiveShadow=!0,this.ee=new THREE.Scene,this.ee.add(this.te),this.ie=new THREE.Mesh(new THREE.PlaneBufferGeometry(1,1),new THREE.MeshBasicMaterial({color:16777215,transparent:!0})),this.ie.rotation.x=-Math.PI/2,this.ie.receiveShadow=!0,this.oe=!1,this.se=!1}convergenceMetric(){return this.A/this.Wt.length}getShadowPlane(){return this.ie}update(e){this.ae=new THREE.Box3,e.traverse(e=>{e.isMesh&&e.castShadow&&this.ae.expandByObject(e)});const t=new THREE.Sphere;this.ae.getBoundingSphere(t);const i=2.5*t.radius;if(0===i)return;this.te.scale.set(i,i,i);const a=new THREE.Vector3;this.ae.getCenter(a),this.te.position.set(a.x,this.ae.min.y,a.z),this.ie.position.set(a.x,this.ae.min.y,a.z),this.ie.scale.copy(this.te.scale),this.boundingRadius=2*t.radius,this.Vt.left=-t.radius,this.Vt.right=t.radius,this.Vt.bottom=-t.radius,this.Vt.top=t.radius,this.Vt.far=this.boundingRadius+10,this.Vt.updateProjectionMatrix(),this.needsUpdate=!0,this.se=!1}render(e,t,i){if(!this.enable)return;this.ae||this.update(t),this.needsUpdate&&(this.A=0,this.needsUpdate=!1);const a=this.convergenceMetric();if(a>=1)return void(this.onComplete&&!this.se&&(this.onComplete(),this.se=!0));this.onProgress&&this.onProgress(a),this.Zt||(this.Vt.layers.mask=i.layers.mask,this.jt()),this.Ut(this.numSamples);const r=e.getClearColor(),o=e.getClearAlpha(),s=e.autoClear;let n,l;for(let a=0;a<this.numSamplesPerFrame;a++)this.A=Math.min(this.A,this.Wt.length-1),this.A++,this.re(),this.Qt(e,t,this.bt,this.Zt),n=this.A%2==0?this.Kt:this.Jt,l=this.A%2==0?this.Jt:this.Kt,this.Yt(e,t,i,n,l);this.oe&&this.ne(e,l,n),this.Mt.uniforms.shadowAccumulationBuffer.value=l,this.Mt.uniforms.transition.value=this.smoothTransition?this.convergenceMetric():1,PIXOTRON.renderPass(e,this.Mt,n),e.autoClear=s,e.setClearColor(r),e.setClearAlpha(o),this.ie.material.map=n.texture}setSize(e,t){this.Kt&&this.Kt.setSize(e,t),this.Jt&&this.Jt.setSize(e,t),this.Zt&&this.Zt.setSize(e,t),this.$t.uniforms.shadowBufferSize.value.set(e,t)}ne(e,t,i){this.he||(this.he=new THREE.ShaderMaterial(PIXOTRON.BlurShader)),this.he.uniforms.tDiffuse.value=t,this.he.uniforms.direction.value=new THREE.Vector3(1,0),this.he.uniforms.size.value.x=i.width,this.he.uniforms.size.value.y=i.height,PIXOTRON.renderPass(e,this.he,i),this.he.uniforms.tDiffuse.value=i,this.he.uniforms.direction.value=new THREE.Vector3(0,1),this.he.uniforms.size.value.x=i.width,this.he.uniforms.size.value.y=i.height,PIXOTRON.renderPass(e,this.he,t)}jt(){const e={format:THREE.RGBAFormat,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter};this.Zt=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.Kt=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.Jt=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.Zt.texture.generateMipmaps=!1,this.Kt.texture.generateMipmaps=!1,this.Jt.texture.generateMipmaps=!1,this.linearDepth?(this.wt=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.wt.uniforms=THREE.UniformsUtils.clone(this.wt.uniforms)):this.wt=new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking}),this.$t=new THREE.ShaderMaterial(PIXOTRON.SoftShadowPlaneShader),this.$t.uniforms=THREE.UniformsUtils.clone(this.$t.uniforms),this.$t.uniforms.shadowBufferSize.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.$t.uniforms.shadowMap.value=this.Zt,this.$t.uniforms.shadowData.value=new THREE.Vector4(0,1,1,1),this.$t.uniforms.shadowMapResolution.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.$t.defines.SHADOW_QUALITY=this.shadowQuality,this.$t.defines.LINEAR_DEPTH=this.linearDepth,this.Mt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionSoftShadowShadowShader),this.Mt.uniforms=THREE.UniformsUtils.clone(this.Mt.uniforms)}Yt(e,t,i,a,r){this.Vt.matrixWorldInverse.getInverse(this.Vt.matrixWorld),this.kt.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.kt.multiply(this.Vt.projectionMatrix),this.kt.multiply(this.Vt.matrixWorldInverse),this.$t.uniforms.shadowMatrix.value.copy(this.kt),this.$t.uniforms.shadowData.value.x=this.A,this.$t.uniforms.shadowData.value.y=this.shadowRadius,this.$t.uniforms.shadowData.value.z=this.shadowBiasMultiplier,this.$t.uniforms.shadowAccumulationBuffer.value=a,this.$t.uniforms.vplPosition.value=this.Vt.position,this.$t.uniforms.cameraNearFar.value.x=this.Vt.near,this.$t.uniforms.cameraNearFar.value.y=this.Vt.far,this.$t.uniforms.lightVector.value.x=-this.Lt.x,this.$t.uniforms.lightVector.value.y=-this.Lt.y,this.$t.uniforms.lightVector.value.z=-this.Lt.z,e.setClearColor(0);const o=e.shadowMap.enabled;e.shadowMap.enabled=!1,this.ee.overrideMaterial=this.$t,e.render(this.ee,i,r,!0),this.ee.overrideMaterial=null,e.shadowMap.enabled=o}Qt(e,t,i,a){!function(e,t){e.traverse(function(e){(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints)&&(e.castShadow||(e.oldVisibility=e.visible,e.visible=!1))})}(t),this.Vt.position.copy(i),this.Bt.copy(i),this.Bt.addScaledVector(this.Lt,10),this.Vt.lookAt(this.Bt),this.Vt.updateMatrixWorld(),t.overrideMaterial=this.wt,this.linearDepth&&(this.wt.uniforms.cameraNearFar.value.x=this.Vt.near,this.wt.uniforms.cameraNearFar.value.y=this.Vt.far),e.setClearColor(0),e.render(t,this.Vt,a,!0),t.overrideMaterial=null,t.traverse(function(e){e.oldVisibility&&(e.visible=e.oldVisibility,e.oldVisibility=void 0)})}re(){const e=this.boundingRadius,t=this.Wt[this.A-1],i=2*t.x-1,a=2*t.y-1,r=Math.sqrt(1-i*i-a*a),o=new THREE.Vector3(e*i,e*r,e*a);this.bt.copy(o),this.Lt.copy(o),this.Lt.multiplyScalar(-1),this.Lt.normalize(),this.bt.add(this.te.position)}Ut(e){e!==this.gt&&(this.gt=e,this.Wt=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideCircle),this.Wt=PIXOTRON.randomizeArray(this.Wt))}}},function(e,t){e.exports=PIXOTRON.SoftShadowPlaneShader={defines:{SHADOW_QUALITY:0,LINEAR_DEPTH:1},uniforms:{shadowMap:{value:null},shadowAccumulationBuffer:{value:null},shadowBufferSize:{value:null},shadowMatrix:{value:new THREE.Matrix4},vplPosition:{value:new THREE.Vector3},lightVector:{value:new THREE.Vector3},shadowData:{value:new THREE.Vector4},cameraNearFar:{value:new THREE.Vector2},shadowMapResolution:{value:null},normalBias:{value:1},weightSum:{value:0}},vertexShader:["varying vec3 viewNormal;","varying vec4 shadowCoord;","uniform vec3 vplPosition;","uniform mat4 shadowMatrix;","uniform float normalBias;","void main() {","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","viewNormal = normalize(normalMatrix * normal);","vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;","//lightVector = vplPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;","//lightVector = normalize(lightVector);","shadowCoord = shadowMatrix * worldPosition;","// nDotL = clamp( dot(lightVector, viewNormal), 0.0, 1.0);","//worldPosition.xyz += normalize((modelMatrix * vec4( normal, 0.0 )).xyz) * 0.02 * normalBias * pow( 1.0 -  nDotL * nDotL, 4.);","//shadowCoord.xy = (shadowMatrix * worldPosition).xy;","//gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","gl_Position = vec4( 2. * uv.x - 1., 2. * uv.y - 1., 0., 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec3 viewNormal;","uniform vec3 lightVector;","varying vec4 shadowCoord;","uniform vec2 shadowBufferSize;","uniform vec2 shadowMapResolution;","uniform sampler2D shadowMap;","uniform sampler2D shadowAccumulationBuffer;","uniform vec4 shadowData;","uniform vec2 cameraNearFar;","uniform float weightSum;","float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {","#if LINEAR_DEPTH == 0","float shadowDepth = unpackRGBAToDepth( texture2D( depths, uv ) );","#else","float shadowDepth = pow2(unpackRGBAToDepth(texture2D( depths, uv ))) + 0.01 * shadowData.z;","shadowDepth = shadowDepth * ( cameraNearFar.y - cameraNearFar.x ) + cameraNearFar.x;","#endif","return step( compare, shadowDepth );","}","float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {","const vec2 offset = vec2( 0.0, 1.0 );","vec2 texelSize = vec2( 1.0 ) / size;","vec2 centroidUV = floor( uv * size + 0.5 ) / size;","float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );","float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );","float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );","float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );","vec2 f = fract( uv * size + 0.5 );","float a = mix( lb, lt, f.y );","float b = mix( rb, rt, f.y );","float c = mix( a, b, f.x );","return c;","}","void main() {","float shadowValue = 1.0;","float shadowRadius = shadowData.y;","float shadowBiasMultiplier = shadowData.z;","float nDotL = clamp( dot(lightVector, normalize(viewNormal)), 0.0, 1.0);","float shadowBias = 0.02 *  sqrt( 1.0 -  nDotL * nDotL) / clamp(nDotL, 0.0006,  1.0);","shadowBias = clamp(shadowBias, 0.0001,  0.0003) * shadowBiasMultiplier;","vec3 shadowCoordNDC = shadowCoord.xyz;///shadowCoord.w;","shadowCoordNDC.z -= shadowBias;","#if LINEAR_DEPTH == 1","float linearDepth = shadowCoord.z + (cameraNearFar.y + cameraNearFar.x)/(cameraNearFar.y - cameraNearFar.x);","linearDepth *= -(cameraNearFar.y - cameraNearFar.x) * 0.5;","linearDepth = -linearDepth;","#endif","bvec4 inFrustumVec = bvec4 ( shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoordNDC.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","#if LINEAR_DEPTH == 1","shadowCoordNDC.z = linearDepth;","#endif","if(frustumTest) {","#if SHADOW_QUALITY == 0","shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);","#elif SHADOW_QUALITY == 1","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = (","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#elif SHADOW_QUALITY == 2","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = ( ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#endif","}","float previousAccumulation = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, gl_FragCoord.xy/shadowBufferSize ));","float shadowAccumulation = mix(previousAccumulation, shadowValue, 1./shadowData.x);","gl_FragColor = packDepthToRGBA(shadowAccumulation);","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.BlurShader={uniforms:{tDiffuse:{value:null},size:{value:new THREE.Vector3},direction:{value:new THREE.Vector3(1,0)},step:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <packing>","uniform sampler2D tDiffuse;","uniform vec2 size;","uniform vec2 direction;","uniform float step;","varying vec2 vUv;","void main() {","float sum = 0.0;","vec2 uvDelta = step * direction / size;","//sum += texture2D( tDiffuse, vUv - 3. * uvDelta ) * 0.0918;","//sum += texture2D( tDiffuse, vUv - 2. * uvDelta ) * 0.2;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vUv - 1. * uvDelta )) * 0.3333;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vec2( vUv.x, vUv.y ) )) * 0.3333;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vUv + 1. * uvDelta )) * 0.3333;","//sum += texture2D( tDiffuse, vUv + 2. * uvDelta ) * 0.2;","//sum += texture2D( tDiffuse, vUv + 3. * uvDelta ) * 0.0918;","gl_FragColor = packDepthToRGBA(sum);//texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );","}"].join("\n")}},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),i(19),t.default=PIXOTRON.SuperSampleAAPass=class extends THREE.Pass{constructor(){super(),this.needsSwap=!0,this.needsUpdate=!0,this.A=0,this.le=new THREE.ShaderMaterial(PIXOTRON.SuperSampleAAShader)}dispose(){this.pingpongRT&&this.pingpongRT.dispose()}render(e,t,i){const a=e.getClearColor(),r=e.getClearAlpha(),o=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.needsUpdate&&(this.A=0,this.needsUpdate=!1),this.ce||this.Y(e),this.A++,this.le.uniforms.tCurrent.value=i.texture,this.le.uniforms.tSumPrevious.value=this.ce.texture,this.le.uniforms.accIndex.value=this.A,PIXOTRON.renderPass(e,this.le,t),PIXOTRON.blit(e,t,this.ce),e.autoClear=o,e.setClearColor(a,r)}setSize(e,t){this.ce&&this.ce.setSize(e,t)}Y(e){const t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height;this.ce=new THREE.WebGLRenderTarget(i,a,t)}}},function(e,t,i){PIXOTRON.SuperSampleAAShader={uniforms:{tCurrent:{type:"t",value:null},tSumPrevious:{type:"t",value:null},accIndex:{type:"f",value:0}},vertexShader:"varying vec2 vUv;    void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"varying vec2 vUv;    uniform sampler2D tCurrent;    uniform sampler2D tSumPrevious;    uniform float accIndex;    void main() {      vec4 currentColor = texture2D(tCurrent, vUv);      vec4 previousSum = texture2D(tSumPrevious, vUv);      gl_FragColor = mix(previousSum, currentColor, 1./accIndex);    }    "}},function(e,t,i){i(21),e.exports=PIXOTRON.TemporalAAPass=class extends THREE.Pass{constructor(e,t){super(),this.feedBack=new THREE.Vector2(.8,.9),this.F=e,this.N=t,this.ue=new THREE.ShaderMaterial(PIXOTRON.TemporalAAShader),this.de=new THREE.Matrix4,this.ve=new THREE.Matrix4,this.J=new THREE.Matrix4,this.J.copy(this.F.projectionMatrix)}dispose(){this.me&&this.me.dispose()}setSize(e,t){this.me&&this.me.setSize(e,t),this.J.copy(this.F.projectionMatrix)}render(e,t,i){this.Y(e);const a=e.getClearColor(),r=e.getClearAlpha(),o=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.ve.multiplyMatrices(this.J,this.F.matrixWorldInverse),this.fe(e,i),PIXOTRON.renderPass(e,this.ue,t),PIXOTRON.blit(e,t,this.me),e.setClearColor(a,r),e.autoClear=o,this.de.copy(this.ve)}Y(e){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height;if(!this.me){const e={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.me=new THREE.WebGLRenderTarget(t,i,e)}}fe(e,t){let i,a;i=this.N.at?this.N.at:this.N.Rt?this.N.Rt.texture:null,this.N.Rt||(a=this.N.Et?this.N.Et.texture:null),this.ue.uniforms.currentRT.value=t.texture,this.ue.uniforms.previousRT.value=this.me.texture,this.ue.uniforms.tDepth.value=i||a;let r=this.N.at?0:1;this.N.forceDepthAndNormalPass&&this.N.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(r=2),this.ue.defines.DEPTH_PACKING_MODE=r,this.ue.uniforms.currentProjectionViewMatrix.value.copy(this.ve),this.ue.uniforms.lastProjectionViewMatrix.value.copy(this.de),this.ue.uniforms.ProjectionMatrix.value.copy(this.J),this.ue.uniforms.InverseViewMatrix.value.copy(this.F.matrixWorld),this.ue.uniforms.feedBack.value.x=this.feedBack.x,this.ue.uniforms.feedBack.value.y=this.feedBack.y;const o=this.ue.uniforms.cameraNearFar.value;o.x=this.F.near,o.y=this.F.far;const s=e.getDrawingBufferSize().width,n=e.getDrawingBufferSize().height,l=this.ue.uniforms.textureSize.value;l.x=s,l.y=n,this.ue.defines.LINEAR_DEPTH=this.N.pt?1:0}}},function(e,t){e.exports=PIXOTRON.TemporalAAShader={defines:{DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1,QUALITY:1,UNJITTER:0},uniforms:{currentRT:{value:null},previousRT:{value:null},tDepth:{value:null},cameraNearFar:{value:new THREE.Vector2},textureSize:{value:new THREE.Vector2},lastProjectionViewMatrix:{value:new THREE.Matrix4},currentProjectionViewMatrix:{value:new THREE.Matrix4},ProjectionMatrix:{value:new THREE.Matrix4},InverseViewMatrix:{value:new THREE.Matrix4},jitterSample:{value:new THREE.Vector2},feedBack:{value:new THREE.Vector2(.88,.97)}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );        }",fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D currentRT;","uniform sampler2D previousRT;","uniform sampler2D tDepth;","uniform vec2 textureSize;","uniform mat4 lastProjectionViewMatrix;","uniform mat4 currentProjectionViewMatrix;","uniform mat4 ProjectionMatrix;","uniform mat4 InverseViewMatrix;","uniform vec2 cameraNearFar;","uniform vec2 jitterSample;","uniform vec2 feedBack;","#include <packing>","float unpack16(vec2 value) {","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","#if DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 0","return unpackRGBAToDepth( texture2D( tDepth, uv ) );","#else","return pow2(unpackRGBAToDepth(texture2D( tDepth, uv )));","#endif","#elif DEPTH_PACKING_MODE == 2","#if LINEAR_DEPTH == 1","return pow2(unpack16(texture2D( tDepth, uv ).xy));","#else","return pow2(unpack16( texture2D( tDepth, uv ).xy ));","#endif","#else","return texture2D( tDepth, uv ).x;","#endif","}","float getViewZ( const in float depth ) {","\t#if PERSPECTIVE_CAMERA == 1","\treturn perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#else","\treturn orthoDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#endif","}","vec3 find_closest_fragment_3x3(const in vec2 uv) { ","const vec3 offset = vec3(-1.0, 1.0, 0.0);","vec2 texelSize = 1.0/textureSize; ","vec3 dtr = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtc = vec3( 0, 1, decodeDepth( uv + offset.zx * texelSize) );","vec3 dtl = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dml = vec3(-1, 0, decodeDepth( uv + offset.yz * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv ) );","vec3 dmr = vec3( 1, 0, decodeDepth( uv + offset.xz * texelSize) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbc = vec3( 0, -1, decodeDepth( uv + offset.zy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtc.z ) dmin = dtc;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dml.z ) dmin = dml;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dmr.z ) dmin = dmr;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbc.z ) dmin = dbc;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + texelSize.xy * dmin.xy, dmin.z);","}","vec3 find_closest_fragment_5tap(const in vec2 uv) ","{ ","vec2 texelSize = 1.0/textureSize; ","vec2 offset = vec2(1.0, -1.0);","vec3 dtl = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtr = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + dmin.xy * texelSize, dmin.z);","}","vec4 clip_aabb(const in vec4 aabb_min, const in vec4 aabb_max, vec4 p )","{ ","const float FLT_EPS = 1e-8;","vec4 p_clip = 0.5 * (aabb_max + aabb_min); ","vec4 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS; ","vec4 v_clip = p - p_clip;","vec4 v_unit = abs(v_clip / e_clip);","float ma_unit = max(v_unit.x, max(v_unit.y, v_unit.z));","if (ma_unit > 1.0) ","return p_clip + v_clip / ma_unit;","else ","return p;","}","vec2 computeScreenSpaceVelocity(const in vec3 worldPosition) {","vec4 currentPositionClip = currentProjectionViewMatrix * vec4(worldPosition, 1.0);","vec4 prevPositionClip = lastProjectionViewMatrix * vec4(worldPosition, 1.0);","vec2 currentPositionNDC = currentPositionClip.xy / currentPositionClip.w;","vec2 prevPositionNDC = prevPositionClip.xy / prevPositionClip.w;","if(prevPositionNDC.x >= 1.0 || prevPositionNDC.x <= -1.0 || prevPositionNDC.x >= 1.0 || prevPositionNDC.y <= -1.0) {","return vec2(0.0);","}","return 0.5 * (currentPositionNDC - prevPositionNDC);","}","vec4 computeTAA(const in vec2 uv, const in vec2 screenSpaceVelocity) {","vec2 jitterOffset = jitterSample/textureSize;","vec2 uvUnJitter = uv;","vec4 currentColor = texture2D(currentRT, uvUnJitter);","vec4 previousColor = texture2D(previousRT, uv - screenSpaceVelocity);","const vec3 offset = vec3(1., -1., 0.);","vec2 texelSize = 1./textureSize;","float texelSpeed = length( screenSpaceVelocity );","vec4 tl = texture2D(currentRT, uvUnJitter + offset.yx * texelSize);","vec4 tc = texture2D(currentRT, uvUnJitter + offset.zx * texelSize);","vec4 tr = texture2D(currentRT, uvUnJitter + offset.xx * texelSize);","vec4 ml = texture2D(currentRT, uvUnJitter + offset.yz * texelSize);","vec4 mc = currentColor;","vec4 mr = texture2D(currentRT, uvUnJitter + offset.xz * texelSize);","vec4 bl = texture2D(currentRT, uvUnJitter + offset.yy * texelSize);","vec4 bc = texture2D(currentRT, uvUnJitter + offset.zy * texelSize);","vec4 br = texture2D(currentRT, uvUnJitter + offset.xy * texelSize);","vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * mc;","mc += (mc - (corners * 0.166667)) * 2.718282 * 0.3;","mc = max(vec4(0.0), mc);","vec4 min5 = min(tc, min(ml, min(mc, min(mr, bc))));","vec4 max5 = max(tc, max(ml, max(mc, max(mr, bc))));","vec4 cmin = min(min5, min(tl, min(tr, min(bl, br))));","vec4 cmax = max(min5, max(tl, max(tr, max(bl, br))));;","cmin = 0.5 * (cmin + min5);","cmax = 0.5 * (cmax + max5);","previousColor = clip_aabb(cmin, cmax, previousColor);","float lum0 = linearToRelativeLuminance(currentColor.rgb);","float lum1 = linearToRelativeLuminance(previousColor.rgb);","float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));","float unbiased_weight = 1.0 - unbiased_diff;","float unbiased_weight_sqr = unbiased_weight * unbiased_weight;","float k_feedback = mix(feedBack.x, feedBack.y, unbiased_weight_sqr);","return mix(currentColor, previousColor, k_feedback);","}","vec3 getWorldPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return (InverseViewMatrix * vec4(xe, ye, viewDepth, 1.)).xyz;","}","void main() {","vec2 jitterOffset = jitterSample/textureSize;","#if QUALITY == 1","vec3 c_frag = find_closest_fragment_3x3(vUv);","#else","vec3 c_frag = find_closest_fragment_5tap(vUv);","#endif","if( c_frag.z >= 0.999 ) {","gl_FragColor = texture2D(currentRT, vUv - jitterOffset);","}","else {","#if LINEAR_DEPTH == 0","float sampleViewZ = getViewZ( c_frag.z );","#else","float sampleViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, c_frag.z);","#endif","vec3 worldPosition = getWorldPositionFromViewZ(c_frag.xy, sampleViewZ);","vec2 screenSpaceVelocity = computeScreenSpaceVelocity(worldPosition);","gl_FragColor = computeTAA(vUv, screenSpaceVelocity);","//gl_FragColor = vec4(10. * length(screenSpaceVelocity));","}","}"].join("\n")}},function(e,t,i){i(23),e.exports=PIXOTRON.BilateralFilterPass=class{constructor(){this.blurKernelSize=3,this.edgeSharpness=1,this.bilateralFilterMaterial=new THREE.ShaderMaterial(PIXOTRON.SAOBilateralFilterShader),this.bilateralFilterMaterial.uniforms=THREE.UniformsUtils.clone(this.bilateralFilterMaterial.uniforms),this.bilateralFilterMaterial.defines=Object.assign({},this.bilateralFilterMaterial.defines)}render(e,t,i,a){this.Y(e),this.pe(e,t,i,a)}setSize(e,t){this.we&&this.we.setSize(e,t),this.bilateralFilterMaterial.uniforms.size.value.set(e,t)}dispose(){this.we&&(this.we.dispose(),this.we=null)}Y(e){if(!this.we){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height,a={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.we=new THREE.WebGLRenderTarget(t,i,a)}}pe(e,t,i,a){const r=e.getDrawingBufferSize().width,o=e.getDrawingBufferSize().height;this.bilateralFilterMaterial.uniforms.size.value.set(r,o);const s=a.Tt?a.Tt.texture:null;let n;a.Rt||(n=a.Et?a.Et.texture:null),n?(this.bilateralFilterMaterial.defines.DEPTH_NORMAL_TEXTURE=1,this.bilateralFilterMaterial.uniforms.tNormal.value=n):this.bilateralFilterMaterial.uniforms.tNormal.value=s,this.bilateralFilterMaterial.defines.KERNEL_SAMPLE_RADIUS=this.blurKernelSize,this.bilateralFilterMaterial.defines.LINEAR_DEPTH=a.pt?1:0,this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=t.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(1,0),this.bilateralFilterMaterial.uniforms.edgeSharpness.value=this.edgeSharpness;const l=this.bilateralFilterMaterial.uniforms.cameraNearFar.value;l.x=i.near,l.y=i.far,PIXOTRON.renderPass(e,this.bilateralFilterMaterial,this.we),this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=this.we.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(0,1),PIXOTRON.renderPass(e,this.bilateralFilterMaterial,t)}}},function(e,t){e.exports=PIXOTRON.SAOBilateralFilterShader={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SAMPLE_RADIUS:4,LINEAR_DEPTH:1,DEPTH_NORMAL_TEXTURE:0},uniforms:{tOcclusionDepth:{type:"t",value:null},tNormal:{type:"t",value:null},size:{type:"v2",value:new THREE.Vector2(256,256)},kernelDirection:{type:"v2",value:new THREE.Vector2(1,0)},cameraNearFar:{type:"v2",value:new THREE.Vector2(1,0)},edgeSharpness:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D tOcclusionDepth;","uniform sampler2D tNormal;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform float edgeSharpness;","uniform vec2 kernelDirection;","#include <packing>","float getViewZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 unpackNormal(vec2 enc) {","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","vec3 getViewNormal( const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormal, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linearStep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","float unpackRGBToFloat(const in vec3 x) {","const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);","return dot(x, decode);","}","void calculateBilateralWeight( const in vec2 uv, const in vec3 centreNormal, const in float centerDepth,","const in float kernelWeight, inout float totalOcclusion, inout float totalBilateralWeight ) {","vec4 aoDepth = texture2D( tOcclusionDepth, uv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","return;","}","vec3 normal = getViewNormal(uv);","#if LINEAR_DEPTH == 0","depth = -getViewZ( depth );","depth = linearStep(cameraNearFar.x, cameraNearFar.y, depth);","#endif","float normalCloseness = dot(normal, centreNormal);","normalCloseness *= normalCloseness;","float normalError = (1.0 - normalCloseness) * 8.;","float normalWeight = max((1.0 - normalError * edgeSharpness), 0.00);","float depthWeight = max(0.0, 1.0 - edgeSharpness * 4000. * abs(depth - centerDepth)) * kernelWeight;","float bilateralWeight = depthWeight * normalWeight;","totalOcclusion += occlusion * bilateralWeight;","totalBilateralWeight += bilateralWeight;","}","void main() {","vec4 aoDepth = texture2D( tOcclusionDepth, vUv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","discard;","}","vec3 centreNormal = getViewNormal(vUv);","#if LINEAR_DEPTH == 0","float centerViewZ = -getViewZ( depth );","centerViewZ = linearStep(cameraNearFar.x, cameraNearFar.y, centerViewZ);","#else","float centerViewZ = depth;","#endif","float gaussianWeights[4];","gaussianWeights[0] = 0.153170;","gaussianWeights[1] = 0.144893;","gaussianWeights[2] = 0.122649;","gaussianWeights[3] = 0.092902;","float totalBilateralWeight = gaussianWeights[0] + 0.03;","float totalOcclusion = occlusion * totalBilateralWeight;","vec2 uvDelta = 2.0 * kernelDirection / size;","float kernelWeight = gaussianWeights[1] + 0.03;","calculateBilateralWeight( vUv + uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[2] + 0.03;","calculateBilateralWeight( vUv + 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[3] + 0.03;","calculateBilateralWeight( vUv + 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","occlusion = totalOcclusion / totalBilateralWeight;","gl_FragColor = vec4( occlusion, aoDepth.gba );","}"].join("\n")}},function(e,t,i){i(25),e.exports=PIXOTRON.UnrealBloomPass=class extends THREE.Pass{constructor(e,t,i,a,r){super(),this.N=e,this.strength=void 0!==i?i:1,this.radius=a,this.threshold=r,this.resolution=void 0!==t?new THREE.Vector2(t.x,t.y):new THREE.Vector2(256,256);const o={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let s=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(s,n,o),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){let t=new THREE.WebGLRenderTarget(s,n,o);t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t),(t=new THREE.WebGLRenderTarget(s,n,o)).texture.name="UnrealBloomPass.v"+e,t.texture.generateMipmaps=!1,this.renderTargetsVertical.push(t),s=Math.round(s/2),n=Math.round(n/2)}const l=PIXOTRON.BloomExtractShader;this.bloomExtractUniforms=THREE.UniformsUtils.clone(l.uniforms),this.bloomExtractUniforms.bloomThreshold.value=r,this.materialBloomExtract=new THREE.ShaderMaterial({uniforms:this.bloomExtractUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{DEPTH_PACKING_MODE:0,LINEAR_DEPTH:1}}),this.separableBlurMaterials=[];const h=[3,5,7,9,11];s=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(h[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(s,n),s=Math.round(s/2),n=Math.round(n/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=i,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const c=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(c.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.basic=new THREE.MeshBasicMaterial,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let i=Math.round(e/2),a=Math.round(t/2);this.renderTargetBright.setSize(i,a);for(let e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(i,a),this.renderTargetsVertical[e].setSize(i,a),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(i,a),i=Math.round(i/2),a=Math.round(a/2)}render(e,t,i,a,r){this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha();const o=e.autoClear;let s,n;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),r&&e.context.disable(e.context.STENCIL_TEST),this.renderToScreen&&(this.quad.material=this.basic,this.basic.map=i.texture,e.render(this.scene,this.camera,void 0,!0)),s=this.N.at?this.N.at:this.N.Rt?this.N.Rt.texture:null,this.N.Rt||(n=this.N.Et?this.N.Et.texture:null),this.materialBloomExtract.uniforms.tDepth.value=s||n;let l=this.N.at?0:1;this.N.forceDepthAndNormalPass&&this.N.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(l=2),this.materialBloomExtract.defines.DEPTH_PACKING_MODE=l,this.materialBloomExtract.defines.LINEAR_DEPTH=this.N.pt?1:0,this.bloomExtractUniforms.tColor.value=i.texture,this.bloomExtractUniforms.bloomThreshold.value=this.threshold,this.quad.material=this.materialBloomExtract,e.render(this.scene,this.camera,this.renderTargetBright,!0);let h=this.renderTargetBright;for(let t=0;t<this.nMips;t++)this.quad.material=this.separableBlurMaterials[t],this.separableBlurMaterials[t].uniforms.colorTexture.value=h.texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionX,e.render(this.scene,this.camera,this.renderTargetsHorizontal[t],!0),this.separableBlurMaterials[t].uniforms.colorTexture.value=this.renderTargetsHorizontal[t].texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionY,e.render(this.scene,this.camera,this.renderTargetsVertical[t],!0),h=this.renderTargetsVertical[t];this.quad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.render(this.scene,this.camera,this.renderTargetsHorizontal[0],!0),this.quad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&e.context.enable(e.context.STENCIL_TEST),this.renderToScreen?e.render(this.scene,this.camera,void 0,!1):e.render(this.scene,this.camera,i,!1),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=o}getSeperableBlurMaterial(e){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum);\n\t\t\t\t}"})}getCompositeMaterial(e){return new THREE.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"})}},PIXOTRON.UnrealBloomPass.BlurDirectionX=new THREE.Vector2(1,0),PIXOTRON.UnrealBloomPass.BlurDirectionY=new THREE.Vector2(0,1)},function(e,t){e.exports=PIXOTRON.BloomExtractShader={uniforms:{tColor:{type:"t",value:null},tDepth:{type:"t",value:null},bloomThreshold:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <packing>","uniform sampler2D tColor;","uniform sampler2D tDepth;","uniform float bloomThreshold;","varying vec2 vUv;","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth = texture2D( tDepth, uv );","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow(unpackRGBAToDepth(uncodedDepth), 2.);","#else","return unpackRGBAToDepth(uncodedDepth );","#endif","#else","return pow(unpack16(uncodedDepth.xy), 2.);","#endif","}","void main() {","vec4 color = texture2D( tColor, vUv );","float depth = decodeDepth(vUv);","const vec3 c = vec3( 0.299, 0.587, 0.114 );","float luminance = dot( color.xyz, c );","float alpha = smoothstep( bloomThreshold, bloomThreshold + 0.01, luminance );","alpha = depth > 1. - 0.001 ? 0. : alpha;","gl_FragColor = color * alpha;","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.VPLGenerationPass=class{constructor(e){this.maxVPL=e,this.Ee=0,this.Re=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.Te=[];for(let e=0;e<this.Re.length;e++){const t=this.Re[e];this.Te.push(new THREE.Vector2(t.x,t.y))}this.xe=new THREE.Ray,this.De=new THREE.Raycaster,this.A=0,this.Ne=!1,this.ge=[],this.Pe=new THREE.SphereBufferGeometry(.05,5,5),this.Oe=[],this.L=!1,this.needsUpdate=!0}getVPLBuffer(){return this.Oe}getNumVPL(){return this.Re.length}generateVPLs(e,t,i,a){if(!this.L)return;if(this.needsUpdate&&(this.G(),this.needsUpdate=!1),this.Ee>=this.getNumVPL())return this.needsUpdate=!1,void(this.Me.visible=!0);this.Me||(this.Me=new THREE.Object3D,this.Me.visible=!1,e.add(this.Me)),performance.now();let r=0;for(let o=0;o<i;o++){const s=this.xe.origin,n=this.xe.direction;if(this.De.set(this.xe.origin,this.xe.direction),!this.Ce(t,s,n,this.A*i+o))break;const l=a?a.intersectRay(this.xe,e):this.De.intersectObject(e,!0);if(l.length>0){const e=l[0];if(e.object instanceof THREE.Mesh){const t=new THREE.Color,i=new THREE.Vector3,a=new THREE.Vector3;i.copy(e.point),a.copy(e.face.normal),a.transformDirection(e.object.matrixWorld);const o=this.Se(e.object.material.map,e.uv,64);t.copy(e.object.material.color),t.multiply(o),this.Oe.push({position:i,normal:a,intensity:new THREE.Vector3(t.r,t.g,t.b)}),this.Ne&&this.He(i,t),r++}}}this.A++,this.Ee+=r,this.Ne&&r>0&&(performance.now(),this.Ee)}He(e,t){const i=new THREE.MeshBasicMaterial;i.color.copy(t);const a=new THREE.Mesh(this.Pe,i);a.position.copy(e),this.Me.add(a)}G(){this.A=0,this.Ee=0,this.Oe=[]}Se(e,t,i){if(!e||!e.image)return new THREE.Color(16777215);let a=this.ge[e.uuid];a||(i=i||32,a=PIXOTRON.getDataFromImage(e.image,i),this.ge[e.uuid]=a);let r=t.x,o=t.y;void 0!==e.repeat&&(r*=e.repeat.x,o*=e.repeat.y),r*=a.width,o*=a.height,e.wrapS===THREE.RepeatWrapping&&(r%=a.width),e.wrapS===THREE.ClampToEdgeWrapping&&(r=Math.min(r,a.width-1)),e.wrapT===THREE.RepeatWrapping&&(o%=a.height),e.wrapT===THREE.ClampToEdgeWrapping&&(o=Math.min(o,a.height-1));const s=Math.floor(r),n=Math.floor(o),l=PIXOTRON.getPixelFromImageData(a,s,n);return l.r=Math.pow(l.r/255,1),l.g=Math.pow(l.g/255,1),l.b=Math.pow(l.b/255,1),new THREE.Color(l.r,l.g,l.b)}Ce(e,t,i,a){if(a<this.Re.length){const r=this.Re[a];t.x=(2*r.x-1)*e.width*.5,t.z=0,t.y=(2*r.y-1)*e.height*.5,t.applyMatrix4(e.matrixWorld);const o=this.Te[a],s=PIXOTRON.squareToCosineHemisphere(o);return i.copy(s),i.transformDirection(e.matrixWorld),!0}return!1}}},function(e,t,i){i(28),e.exports=PIXOTRON.InstantRadiosityPass=class{constructor(){this.ye=10,this._e=0,this.A=0,this.ze=!1,this.needsUpdate=!0,this.enabled=!0}convergenceMetric(){const e=this.vplGenarationPass.getNumVPL();return this.enabled?this.A*this.ye/e:1}render(e,t,i,a,r){this.needsUpdate&&(this.G(),this.A=0,this.needsUpdate=!1),this.vplGenarationPass=a;const o=a.getNumVPL(),s=a.getVPLBuffer();if(0===s.length)return;if(this.convergenceMetric()>=1)return;if(!this.bbox){this.bbox=new THREE.Box3,this.bbox.setFromObject(t);const e=new THREE.Vector3;this.bbox.getSize(e),this.minDistance=Math.max(Math.max(e.x,e.y),e.z)/9}this.indirectDiffuseRenderTarget||this.Y(e),this.A++,t.overrideMaterial=this.lightAccumulationMaterial;const n=this.A%2==0?this.indirectDiffuseRenderTarget:this.indirectDiffuseRenderTargetPingPong,l=this.A%2==0?this.indirectDiffuseRenderTargetPingPong:this.indirectDiffuseRenderTarget;this.lightAccumulationMaterial.uniforms.accumulationBuffer.value=n.texture,this.lightAccumulationMaterial.uniforms.currentFrameCount.value=this.A,this.Ie(s,o,r),e.render(t,i,l,!0),t.overrideMaterial=null,e.indirectDiffuseBuffer=l.texture}Y(e){const t=e.getDrawingBufferSize(),i=t.width,a=t.height;let r=THREE.UnsignedByteType;if(!this.ze){const t=e.extensions,i=t.get("OES_texture_half_float");r=i?THREE.HalfFloatType:r,i||(r=t.get("OES_texture_float")?THREE.FloatType:r)}const o={type:r,format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter};this.indirectDiffuseRenderTarget=new THREE.WebGLRenderTarget(i,a,o),this.indirectDiffuseRenderTarget.texture.generateMipmaps=!1,this.indirectDiffuseRenderTargetPingPong=new THREE.WebGLRenderTarget(i,a,o),this.indirectDiffuseRenderTargetPingPong.texture.generateMipmaps=!1,this.lightAccumulationMaterial=new THREE.ShaderMaterial(PIXOTRON.VPLAccumulationShader),this.lightAccumulationMaterial.defines.VPL_COUNT=this.ye,this.lightAccumulationMaterial.uniforms.viewPort.value=new THREE.Vector2(i,a),this.lightAccumulationMaterial.uniforms.currentFrameCount.value=this.A,this.lightAccumulationMaterial.uniforms.minDistance.value=this.minDistance,(r===THREE.UnsignedByteType||this.ze)&&(this.lightAccumulationMaterial.dithering=!0)}G(){this.A=0,this._e=0}Ie(e,t,i){let a=e.length-this._e;a=Math.min(a,this.ye);const r=new THREE.Vector3(0,0,0),o=[];for(let s=0;s<a;s++){const a=e[s+this._e];if(s>=e.length)o.push({position:r,direction:r,intensity:r});else{const e=new THREE.Vector3;e.copy(a.intensity),e.multiplyScalar(i.intensity/t),o.push({position:a.position,direction:a.normal,intensity:e})}}for(let e=0;e<this.ye-a;e++)o.push({position:r,direction:r,intensity:r});this._e+=a,this.lightAccumulationMaterial.uniforms.vplLights.value=o}}},function(e,t){e.exports=PIXOTRON.VPLAccumulationShader={vertexShader:["varying vec3 worldPosition;","varying vec3 worldNormal;","void main() {","   worldPosition = (modelMatrix * vec4( position.xyz, 1.0)).xyz;","   worldNormal = (modelMatrix * vec4(normal, 0.0)).xyz;","   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <dithering_pars_fragment>","varying vec3 worldPosition;","varying vec3 worldNormal;","uniform vec2 viewPort;","uniform sampler2D accumulationBuffer;","uniform float currentFrameCount;","uniform float minDistance;","struct VPL {","   vec3 position;","   vec3 direction;","   vec3 intensity;","};","uniform VPL vplLights[VPL_COUNT];","float getLightIrradiance(const in vec3 lightPos, const in vec3 lightDir) {","vec3 lightVector = lightPos - worldPosition;","vec3 direction = normalize( lightVector );","float lightDistance = length( lightVector );","float distanceFalloff = 1.0 /max( lightDistance * lightDistance, minDistance * minDistance );","float csTheta_i = dot( direction, -lightDir );","float csTheta_o = dot( normalize(worldNormal), direction );","return max(csTheta_i, 0.) * max( csTheta_o, 0.0 ) * distanceFalloff / PI;","}","void main() {","vec3 colorSum = vec3(0.0);","for( int i = 0; i < VPL_COUNT; i++) {","VPL vpl = vplLights[i];","vec3 lightPosition = vpl.position;","vec3 lightDirection = vpl.direction;","vec3 lightIntensity = vpl.intensity;","vec3 lightColor = lightIntensity * getLightIrradiance( lightPosition, lightDirection );","colorSum += lightColor;","}","vec3 previousColor = texture2D( accumulationBuffer, gl_FragCoord.xy/viewPort ).rgb;","if( currentFrameCount == 1. ){","previousColor = vec3(0.);","}","vec3 newColor = previousColor + colorSum;","gl_FragColor = vec4( newColor , 1.0);","#include <dithering_fragment>","}"].join("\n"),uniforms:{vplLights:{value:null},viewPort:{value:null},accumulationBuffer:{value:null},currentFrameCount:{value:0},minDistance:{value:0}},defines:{VPL_COUNT:0}}}]);