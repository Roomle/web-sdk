!function(e){var t={};function i(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=e,i.c=t,i.d=function(e,t,a){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:a})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=3)}([function(e,t,i){function a(e){const t=Math.floor(Math.random()*e.length),i=e[t];return e.splice(t,1),i}function r(e,t,i){this.width=e,this.height=t,this.cellSize=i,this.array=new Array(e);for(let i=0;i<e;i++)this.array[i]=new Array(t)}function o(e,t){const i=t*(Math.random()+1),a=6.283185307178*Math.random(),r=e.x+i*Math.cos(a),o=e.y+i*Math.sin(a);return new THREE.Vector2(r,o)}i(1),r.prototype={constructor:r,t:function(e){const t=Math.floor(e.x/this.cellSize),i=Math.floor(e.y/this.cellSize);this.array[t][i]=e},h:function(e,t){const i=Math.floor(e.x/this.cellSize),a=Math.floor(e.y/this.cellSize);for(let r=i-5;r<i+5;r++)for(let i=a-5;i<a+5;i++)if(r>=0&&r<this.width&&i>=0&&i<this.height){const a=this.array[r][i];let o=1e10;if(void 0!==a&&(o=a.distanceTo(e)),o<t)return!0}return!1}},e.exports=(PIXOTRON.lerpDistribution=function(e,t,i){return(t=t||.47)*(1-e)+(i=i||7)*e},PIXOTRON.uniformDistribution=function(){return 1},PIXOTRON.generateQuasiRandomPoints=function(e,t,i,s){i=i||PIXOTRON.uniformDistribution,s=s||PIXOTRON.insideCircle,t<0&&(t=Math.sqrt(e)/e);const n=[],l=[],h=t/Math.sqrt(2),c=new r(Math.ceil(1/h),Math.ceil(1/h),h),u=new THREE.Vector2(.5,.5);let d=!1;do{u.x=Math.random(),u.y=Math.random(),d=s(u.x,u.y)}while(!d);for(l.push(u),n.push(u),c.t(u);0!==l.length&&n.length<e;){const e=a(l);for(let a=0;a<30;a++){const a=e.x-.5,r=e.y-.5,h=i(Math.sqrt(a*a+r*r)),u=o(e,h*t);!s(u.x,u.y)||c.h(u,h*t)||(l.push(u),n.push(u),c.t(u))}}return n})},function(e,t){THREE.ShaderChunk.utilshader=["vec2 pack16(float value){","float sMax = 65535.0;","int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);","int digit0 = v/256;","int digit1 = v-digit0*256;","return vec2(float(digit0)/255.0, float(digit1)/255.0);","}","vec2 packNormal(vec3 n){","float p = sqrt(n.z*8.0+8.0);","return vec2(n.xy/p + 0.5);","}","vec3 unpackNormal(vec2 enc){","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","vec3 getViewNormal(const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormalDepth, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linstep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","vec3 packFloatToRGB(const in float x) {","const vec3 code = vec3(1.0, 255.0, 65025.0);","vec3 pack = vec3(code * x);","pack.gb = fract(pack.gb);","pack.rg -= pack.gb * (1.0 / 256.0);","return pack;","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth;","#if DEPTH_PACKING_MODE == 2","uncodedDepth = texture2D( tNormalDepth, uv );","#else","uncodedDepth = texture2D( tDepth, uv );","#endif","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow2(unpackRGBAToDepth(uncodedDepth));","#else","return unpackRGBAToDepth( uncodedDepth );","#endif","#else","return pow2(unpack16(uncodedDepth.xy));","#endif","}"].join("\n"),function(){const e=THREE.CopyShader;PIXOTRON.u=THREE.UniformsUtils.clone(e.uniforms),PIXOTRON.v=new THREE.ShaderMaterial({uniforms:PIXOTRON.u,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader}),PIXOTRON.R=new THREE.Scene,PIXOTRON.T=new THREE.OrthographicCamera(-1,1,1,-1,0,1),PIXOTRON.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),PIXOTRON.v),PIXOTRON.quad.frustumCulled=!1,PIXOTRON.R.add(PIXOTRON.quad)}(),e.exports=PIXOTRON.randomizeArray=function(e){let t,i,a=e.length;for(;0!==a;)i=Math.floor(Math.random()*a),t=e[a-=1],e[a]=e[i],e[i]=t;return e},e.exports=PIXOTRON.createTextureFromRawData=function(e,t){(t=t||{}).type=t.type||THREE.FloatType,t.format=t.format||THREE.LuminanceAlphaFormat,t.minFilter=t.minFilter||THREE.NearestFilter,t.magFilter=t.magFilter||THREE.NearestFilter;const i=new Float32Array(2*e.length);for(let t=0;t<2*e.length;t+=2)i[t]=e[t/2].x-.5,i[t+1]=e[t/2].y-.5;const a=new THREE.DataTexture(i,e.length,1);return a.format=t.format,a.type=t.type,a.minFilter=t.minFilter,a.magFilter=t.magFilter,a.generateMipmaps=!1,a.needsUpdate=!0,a},e.exports=PIXOTRON.jitterCamera=function(e,t,i,a,r){r=void 0!==r?r:.5;const o=(2*t.x-1)*r,s=(2*t.y-1)*r;e.setViewOffset(i,a,o,s,i,a)},e.exports=PIXOTRON.insideCircle=function(e,t,i){const a=e-.5,r=t-.5;return a*a+r*r<=(i=void 0!==i?i:.5)*i},e.exports=PIXOTRON.insideRectangle=function(e,t,i,a){return i=void 0!==i?i:1,a=void 0!==a?a:1,e>=0&&t>=0&&e<=i&&t<=a},e.exports=PIXOTRON.blit=function(e,t,i,a){a=void 0!==a&&a,PIXOTRON.u.tDiffuse.value=t,PIXOTRON.quad.material=PIXOTRON.v,e.render(PIXOTRON.R,PIXOTRON.T,i,a)},e.exports=PIXOTRON.renderPass=function(e,t,i,a){a=void 0!==a&&a,PIXOTRON.quad.material=t,e.render(PIXOTRON.R,PIXOTRON.T,i,a)},e.exports=PIXOTRON.calculateFOV=function(e,t,i){let a;e.isBox3?a=e:(a=new THREE.Box3).setFromObject(e);const r=new THREE.Vector3;a.getCenter(r);const o=new THREE.Vector3;a.getSize(o);const s=new THREE.Vector3;s.set(o.x/2,o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize();let n=i.dot(s);return s.set(-o.x/2,o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(o.x/2,-o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(o.x/2,o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(-o.x/2,-o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(-o.x/2,o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(o.x/2,-o.y/2,-o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),s.set(-o.x/2,-o.y/2,o.z/2),s.add(r),s.sub(t),s.normalize(),n=Math.min(i.dot(s),n),180*Math.acos(n)/Math.PI*2}},function(e,t){e.exports=PIXOTRON.SmoothTransitionAOShader={uniforms:{saoAccumulationBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["varying vec2 vUv;","uniform float transition;","uniform sampler2D saoAccumulationBuffer;","void main() {","float aoValue = texture2D( saoAccumulationBuffer, vUv).r;","gl_FragColor = vec4(mix(0., aoValue, transition));","}"].join("\n")},e.exports=PIXOTRON.SmoothTransitionShadowShader={uniforms:{shadowAccumulationBuffer:{value:null},firstFrameShadowBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["#include <packing>","varying vec2 vUv;","uniform float transition;","uniform sampler2D shadowAccumulationBuffer;","uniform sampler2D firstFrameShadowBuffer;","void main() {","float shadowValueFirstFrame = unpackRGBAToDepth(texture2D( firstFrameShadowBuffer, vUv));","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","gl_FragColor = vec4(mix(shadowValueFirstFrame, shadowValue, pow(transition, 4.)));","}"].join("\n")}},function(e,t,i){e.exports=PIXOTRON={},i(1),i(0),i(4),i(6),i(8),i(10),i(12),i(14),i(16),i(18),e.exports=PIXOTRON.Pixotron=class{constructor(e){(e=e||{}).saoparams=e.saoparams||{},e.shadowparams=e.shadowparams||{},e.gbufferparams=e.gbufferparams||{},this.needsUpdate=!0,this.autoSAOClear=!0,this.autoShadowsClear=!0,this.enableAA=!0,this.D=new PIXOTRON.BilateralFilterPass(3,1),this.N=new PIXOTRON.GBufferPass(e.gbufferparams);const t=void 0===e.saoparams.accumulative||e.saoparams.accumulative;this.g=t?new PIXOTRON.AccumulativeSAOPass(e.saoparams):new PIXOTRON.SAOPass(e.saoparams),this.P=new PIXOTRON.ShadowPass(e.shadowparams),this.O=new PIXOTRON.SuperSampleAAPass,this.S=PIXOTRON.generateQuasiRandomPoints(30,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle);const i={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.M=new THREE.WebGLRenderTarget(1,1,i),this.C=new THREE.WebGLRenderTarget(1,1,i),this.H=0}addRenderCompleteCallback(e){this.renderCompleteCallback=e}removeRenderCompleteCallback(){this.renderCompleteCallback=null}blit(e){this._&&PIXOTRON.blit(this.renderer,this._,e,!1)}getBloomPass(){return this.I}getHighLightPass(){return this.F}getSAOPass(){return this.g}getShadowPass(){return this.P}highlightObjects(e){this.F&&(this.F.selectedObjects=e)}isAccumulationConverged(){const e=this.P.enableAccumulation,t=this.g.convergenceMetric()>=1;return(!e||this.P.convergenceMetric()>=1)&&t}isSuperSamplingConverged(){return this.H/this.S.length>=1}render(e,t,i,a){this.needsUpdate&&(this.A(),this.H=0,this.jitterIndex=0,this.needsUpdate=!1,this.autoSAOClear=!0,this.autoShadowsClear=!0),this.bInitialized||this.V(e,t,i,a),this.isSuperSamplingConverged()?this.U():(this.X(t),this.B(t,i),this.k(),this.O.enabled=this.isAccumulationConverged(),this.L.enabled=!this.isAccumulationConverged()&&this.enableAA,this.Z(i),this.W.writeBuffer=this.W.renderTarget2,this.W.readBuffer=this.W.renderTarget1,this.W.render(),i.clearViewOffset(),this.jitterIndex++,this.O.enabled&&this.H++)}setSize(e,t){this.renderer&&(e*=this.renderer.getPixelRatio(),t*=this.renderer.getPixelRatio(),this.renderer.screenBufferSize=new THREE.Vector2(e,t)),this.N.setSize(e,t),this.g.setSize(e,t),this.P.setSize(e,t),this.W.setSize(e,t),this.needsUpdate=!0}setAntiAliasingFeedBackParams(e,t){this.L&&(this.L.feedBack.x=e,this.L.feedBack.y=t)}Z(e){if(this.enableAA||this.isAccumulationConverged()){const t=this.renderer.getDrawingBufferSize().width,i=this.renderer.getDrawingBufferSize().height,a=this.S[this.jitterIndex%this.S.length];PIXOTRON.jitterCamera(e,a,t,i)}if(this.isAccumulationConverged()){const e=this.S[this.jitterIndex%this.S.length];this.j(e)}}k(){this.g.enabled||(this.renderer.saoBuffer=this.C.texture);const e=this,t=!this.P.enabled,i=!function(){let t=!0;return e.areaLights.forEach(e=>{e.castShadow||(t=!1)}),t}(),a=0===this.areaLights.length;(t||i||a)&&this.P.lights.forEach(e=>{e.shadow.map=this.M})}U(){this.renderCompleteCallback&&!this.renderCompleteCallbackCalled&&(this.renderCompleteCallback(),this.renderCompleteCallbackCalled=!0)}X(e){const t=this;this.punctualLights=[],this.areaLights=[],e.traverseVisible(function(e){(e instanceof THREE.DirectionalLight||e instanceof THREE.SpotLight)&&e.castShadow&&t.punctualLights.push(e),e instanceof THREE.RectAreaLight&&e.castShadow&&(e.shadow=e.shadow?e.shadow:{},t.areaLights.push(e))}),this.P.lights=this.areaLights}j(e){this.punctualLights.forEach(t=>{PIXOTRON.jitterCamera(t.shadow.camera,e,t.shadow.mapSize.x,t.shadow.mapSize.y)})}V(e,t,i,a){this.renderer=e,this._=a;const r=new THREE.RenderPass(t,i);this.W=new THREE.EffectComposer(this.renderer,a);const o=e.getDrawingBufferSize();this.O.setSize(o.width,o.height),this.renderer.screenBufferSize=new THREE.Vector2(o.width,o.height),this.L=new PIXOTRON.TemporalAAPass(i,this.N),this.G=new THREE.ShaderPass(THREE.CopyShader),this.G.needsSwap=!1,this.G.renderToScreen=!a,this.W.addPass(r),THREE.OutlinePass&&(this.F=new THREE.OutlinePass(new THREE.Vector2(o.width,o.height),t,i),this.W.addPass(this.F)),this.I=new PIXOTRON.UnrealBloomPass(this.N,new THREE.Vector2(o.width,o.height),.86,1,.98),this.W.addPass(this.I),this.W.addPass(this.O),this.W.addPass(this.L),this.I.enabled=!1,this.W.addPass(this.G),this.bInitialized=!0;const s=new THREE.MeshBasicMaterial({color:16777215}),n=new THREE.MeshBasicMaterial({color:0});PIXOTRON.renderPass(e,s,this.M),PIXOTRON.renderPass(e,n,this.C),this.punctualLights=[],this.areaLights=[],this.jitterIndex=0}B(e,t){const i=this.renderer.getDrawingBufferSize().width,a=this.renderer.getDrawingBufferSize().height,r=this.S[this.jitterIndex%this.S.length];PIXOTRON.jitterCamera(t,r,i,a),this.N.render(this.renderer,e,t),this.g.render(this.renderer,t,this.N,this.D),this.P.render(this.renderer,e,t),t.clearViewOffset(),!this.W.renderTarget1.depthTexture&&this.N.K&&(this.W.renderTarget1.depthTexture=this.N.K,this.W.renderTarget2.depthTexture=this.N.K)}A(){this.g.needsUpdate=!!this.autoSAOClear,this.P.needsUpdate=!!this.autoShadowsClear,this.O.needsUpdate=!0,this.renderCompleteCallbackCalled=!1}}},function(e,t,i){i(5),e.exports=PIXOTRON.GBufferPass=class{constructor(e){e=e||{},this.forceDepthAndNormalPass=void 0===e.forceDepthAndNormalPass||e.forceDepthAndNormalPass,this.packingMode=void 0!==e.packingMode?e.packingMode:PIXOTRON.GBufferPass.DEPTH_NORMAL_16,this.J=new THREE.MeshNormalMaterial,this.q=new THREE.ShaderMaterial(PIXOTRON.PackingShader_DepthNormal16),this.Y=void 0===e.linearDepth||e.linearDepth,this.Y?(this.$=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.forceDepthAndNormalPass=!0):(this.$=new THREE.MeshDepthMaterial,this.$.depthPacking=THREE.RGBADepthPacking)}dispose(){this.tt&&this.tt.dispose(),this.et&&this.et.dispose(),this.it&&this.it.dispose()}setSize(e,t){this.tt&&this.tt.setSize(e,t),this.et&&this.et.setSize(e,t),this.it&&this.it.setSize(e,t)}render(e,t,i){this.ot||this.V(e);const a=e.getClearColor(),r=e.getClearAlpha(),o=e.autoClear,s=e.shadowMap.enabled;e.shadowMap.enabled=!1,e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.at(e,t,i),e.autoClear=o,e.shadowMap.enabled=s,e.setClearColor(a,r)}V(e){const t=e.extensions.get("WEBGL_depth_texture"),i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height;if(!this.forceDepthAndNormalPass&&t&&!this.it){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.it=new THREE.WebGLRenderTarget(i,a,e),this.K||(this.K=new THREE.DepthTexture,this.K.type=THREE.UnsignedShortType),this.it.depthTexture=this.K}if(!t||this.forceDepthAndNormalPass){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.packingMode===PIXOTRON.GBufferPass.NONE&&(this.et||(this.et=new THREE.WebGLRenderTarget(i,a,e),this.et.depthTexture=this.K),this.it||(this.it=new THREE.WebGLRenderTarget(i,a,e),this.it.depthTexture=this.K)),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(this.tt||(this.tt=new THREE.WebGLRenderTarget(i,a,e),this.tt.depthTexture=this.K))}this.ot=!0}at(e,t,i){t.traverse(function(e){if(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints){let t=e.material&&e.material.transparent||e.castAO;(t=(t=e.material&&e.material.transparent&&!e.material.isShadowMaterial||!!e.castAO)||e.material.alphaTest>0)&&(e.aoVisibility=e.visible,e.visible=!1)}});const a=e.extensions.get("WEBGL_depth_texture");a&&!this.forceDepthAndNormalPass&&(t.overrideMaterial=this.J,e.render(t,i,this.it,!0),t.overrideMaterial=null),a&&!this.forceDepthAndNormalPass||(this.packingMode===PIXOTRON.GBufferPass.NONE&&(t.overrideMaterial=this.J,e.render(t,i,this.it,!0),t.overrideMaterial=null,t.overrideMaterial=this.$,this.$.isMeshDepthMaterial||(this.$.uniforms.cameraNearFar.value.x=i.near,this.$.uniforms.cameraNearFar.value.y=i.far),e.render(t,i,this.et,!0),t.overrideMaterial=null),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(t.overrideMaterial=this.q,this.q.uniforms.cameraNearFar.value.x=i.near,this.q.uniforms.cameraNearFar.value.y=i.far,e.render(t,i,this.tt,!0),t.overrideMaterial=null)),t.traverse(function(e){e.aoVisibility&&(e.visible=e.aoVisibility,e.aoVisibility=void 0)})}},PIXOTRON.GBufferPass.NONE=0,PIXOTRON.GBufferPass.DEPTH_NORMAL_16=1},function(e,t){e.exports=PIXOTRON.PackingShader_DepthNormal16={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewNormal;      varying vec3 viewPosition;      void main() {        viewNormal = normalMatrix * normal;        viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      }",fragmentShader:"varying vec3 viewNormal;    uniform vec2 cameraNearFar;    varying vec3 viewPosition;      vec2 pack16(float value){          float sMax = 65535.0;          int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);          int digit0 = v/256;          int digit1 = v-digit0*256;          return vec2(float(digit0)/255.0, float(digit1)/255.0);      }            vec2 packNormal(vec3 n){          float p = sqrt(n.z*8.0+8.0);          return vec2(n.xy/p + 0.5);      }            float linstep(float edge0, float edge1, float value){        return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);      }            void main() {        float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);        vec2 packedZ = pack16(pow(linearZ, 0.5));        vec2 packedNormal = packNormal(normalize(viewNormal));        gl_FragColor = vec4(packedZ.x, packedZ.y, packedNormal.x, packedNormal.y);      }"},e.exports=PIXOTRON.PackingShader_Depth32={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewPosition;    void main() {      viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"#include <packing>  uniform vec2 cameraNearFar;  varying vec3 viewPosition;    float linstep(float edge0, float edge1, float value){      return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);    }        void main() {      float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);      vec4 packedZ = packDepthToRGBA(pow(linearZ, 0.5));      gl_FragColor = packedZ;    }"}},function(e,t,i){i(0),i(7),i(2),e.exports=PIXOTRON.AccumulativeSAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.bias=void 0!==e.bias?e.bias:.001,this.numSamples=void 0!==e.numSamples?e.numSamples:600,this.st=void 0!==e.samplesPerFrame?e.samplesPerFrame:4,this.blurEnabled=!0,this.edgeSharpness=10,this.enabled=!0,this.needsUpdate=!0,this.rt=0,this.nt(this.numSamples),this.ht=new THREE.ShaderMaterial(PIXOTRON.AccumulativeSAOShader),this.ht.uniforms=THREE.UniformsUtils.clone(this.ht.uniforms),this.ht.defines.SAMPLES_PER_FRAME=this.st,this.lt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionAOShader),this.H=0}convergenceMetric(){return this.enabled?this.H*this.st/(this.ct-1):1}dispose(){this.ut&&(this.ut.dispose(),this.vt.dispose())}render(e,t,i,a){if(this.needsUpdate&&(this.H=0,this.needsUpdate=!1),this.convergenceMetric()>=1)return;this.H++,this.H=Math.min(this.H,this.ct-1),this.ut||this.V(e),this.nt(this.numSamples);const r=e.getClearColor(),o=e.getClearAlpha(),s=e.autoClear;e.autoClear=!1;const n=e.getDrawingBufferSize().width,l=e.getDrawingBufferSize().height;this.ht.uniforms.size.value.set(n,l),this.dt(t,i);const h=this.H%2==0?this.vt:this.ut,c=this.H%2==0?this.ut:this.vt;this.ft(e,h,c),this.blurEnabled&&this.convergenceMetric()>0&&(a.edgeSharpness=this.edgeSharpness,a.render(e,c,t,i)),this.pt(e,h,c),e.autoClear=s,e.setClearColor(r),e.setClearAlpha(o),e.saoBuffer=this.smoothTransition?h:c}setSize(e,t){this.vt&&this.vt.setSize(e,t),this.ut&&this.ut.setSize(e,t),this.ht.uniforms.size.value.set(e,t)}V(e){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height;if(!this.ut){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.ut=new THREE.WebGLRenderTarget(t,i,e),this.vt=new THREE.WebGLRenderTarget(t,i,e)}}ft(e,t,i){this.ht.uniforms.tAOSumPrevious.value=t,PIXOTRON.renderPass(e,this.ht,i)}pt(e,t,i){this.smoothTransition&&(this.lt.uniforms.saoAccumulationBuffer.value=i,this.lt.uniforms.transition.value=this.convergenceMetric(),PIXOTRON.renderPass(e,this.lt,t))}dt(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),a=this.ht.uniforms.saoData.value;a.x=i,a.y=this.intensity,a.z=this.occlusionWorldRadius,a.w=this.H;const r=this.ht.uniforms.saoBiasEpsilon.value;r.x=this.bias,r.y=.001;const o=this.ht.uniforms.cameraNearFar.value;let s;o.x=e.near,o.y=e.far,this.ht.uniforms.ProjectionMatrix.value=e.projectionMatrix,s=t.K?t.K:t.et?t.et.texture:null;const n=t.it?t.it.texture:null;let l;t.et||(l=t.tt?t.tt.texture:null);let h=t.K?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(h=2),this.ht.defines.DEPTH_PACKING_MODE=h,this.ht.defines.DEPTH_NORMAL_TEXTURE=l?1:0,this.ht.defines.LINEAR_DEPTH=t.Y?1:0,l?this.ht.uniforms.tNormalDepth.value=l:(this.ht.uniforms.tNormal.value=n,this.ht.uniforms.tDepth.value=s),this.ht.uniforms.tQuasiRandomSamples.value=this.Et,this.ht.uniforms.numQuasiSamples.value=this.Et.image.width}nt(e){e!==this.rt&&(this.rt=e,this.Rt=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.lerpDistribution,PIXOTRON.insideCircle),this.Et=PIXOTRON.createTextureFromRawData(PIXOTRON.randomizeArray(this.Rt)),this.ct=this.Rt.length)}}},function(e,t){e.exports=PIXOTRON.AccumulativeSAOShader={blending:THREE.NoBlending,defines:{SAMPLES_PER_FRAME:4,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1},uniforms:{tQuasiRandomSamples:{type:"t",value:null},tAOSumPrevious:{type:"t",value:null},tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},numQuasiSamples:{type:"f",value:0},saoBiasEpsilon:{type:"v2",value:new THREE.Vector2},size:{type:"v2",value:new THREE.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tAOSumPrevious;","uniform sampler2D tQuasiRandomSamples;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec4 saoBiasEpsilon;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform float numQuasiSamples;","const float f_sampleCount = float( SAMPLES_PER_FRAME );","#include <utilshader>","float getViewDepth( const in float ndcDepth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float getOcclusionFromPositionNormal( const in vec3 centerPosition, const in vec3 centerNormal, const in vec3 samplePosition ) {","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","return max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( d2 + saoBiasEpsilon.y ), 0.0 );","}","vec4 getOcclusion( const in vec3 centerPosition ) {","vec3 centerNormal = getViewNormal( vUv );","float screenOcclusionRadius = 200. * saoData.z * saoData.x / -centerPosition.z;","if( screenOcclusionRadius < 1. ) {","discard;","}","float random = rand( vUv );","float randomAngle = random * PI2 + 2. * PI2 * (saoData.w - 1.0);","float cosAngle = cos(randomAngle); float sinAngle = sin(randomAngle);","mat2 randomRotationMatrix = mat2(cosAngle, sinAngle, -sinAngle, cosAngle);","float texelSize = 1.0/numQuasiSamples;","float occlusionSum = 0.0;","for( int i = 0; i < SAMPLES_PER_FRAME; i ++ ) {","float offset = (mod((float(i) + (saoData.w - 1.) * f_sampleCount), numQuasiSamples) + 0.5 ) * texelSize;","vec2 randomSample = randomRotationMatrix * texture2D( tQuasiRandomSamples, vec2(offset, 0.5)).xw * screenOcclusionRadius/size;","vec2 sampleUv = vUv + randomSample;","float sampleDepthNDC = decodeDepth( sampleUv );","if( sampleDepthNDC >= ( 1.0 - EPSILON ) ) {","continue;","}","#if LINEAR_DEPTH == 0","float sampleViewDepth = getViewDepth( sampleDepthNDC );","vec3 samplePosition = getViewPositionFromViewZ( sampleUv, sampleViewDepth );","#else","sampleDepthNDC = mix(-cameraNearFar.x, -cameraNearFar.y, sampleDepthNDC);","vec3 samplePosition = getViewPositionFromViewZ(sampleUv, sampleDepthNDC);","#endif","float occlusion = getOcclusionFromPositionNormal( centerPosition, centerNormal, samplePosition );","occlusionSum += occlusion;","}","float occlusion = occlusionSum * saoData.y * 2.0 / f_sampleCount;","return vec4(clamp(occlusion,0., 1.));","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewDepth = getViewDepth( centerDepth );","#else","float centerViewDepth = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 viewPosition = getViewPositionFromViewZ(vUv, centerViewDepth);","float occlusion = getOcclusion( viewPosition ).r;","float prevOcclusionSum = texture2D(tAOSumPrevious, vUv).r;","float finalOcclusion = mix(prevOcclusionSum, occlusion, 1./saoData.w);","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = clamp(finalOcclusion, 0., 1.);","}"].join("\n")}},function(e,t,i){i(0),i(9),e.exports=PIXOTRON.SAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.bias=void 0!==e.bias?e.bias:.001,this.blurEnabled=!0,this.edgeSharpness=1,this.needsUpdate=!0,this.Tt=new THREE.ShaderMaterial(PIXOTRON.SAOShader),this.Tt.uniforms=THREE.UniformsUtils.clone(this.Tt.uniforms),this.Tt.defines=Object.assign({},this.Tt.defines),this.H=0}dispose(){this.ut&&(this.ut.dispose(),this.ut=null)}setSize(e,t){this.ut&&this.ut.setSize(e,t),this.Tt.uniforms.size.value.set(e,t)}dt(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),a=this.Tt.uniforms.saoData.value;a.x=i,a.y=this.intensity,a.z=this.occlusionWorldRadius,a.w=this.H++;const r=this.Tt.uniforms.saoBiasEpsilon.value;r.x=this.bias,r.y=.001;const o=this.Tt.uniforms.cameraNearFar.value;let s;o.x=e.near,o.y=e.far,this.Tt.uniforms.ProjectionMatrix.value=e.projectionMatrix,s=t.K?t.K:t.et?t.et.texture:null;const n=t.it?t.it.texture:null;let l;t.et||(l=t.tt?t.tt.texture:null);let h=t.K?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(h=2),this.Tt.defines.DEPTH_PACKING_MODE=h,this.Tt.defines.DEPTH_NORMAL_TEXTURE=l?1:0,this.Tt.defines.LINEAR_DEPTH=t.Y?1:0,l?this.Tt.uniforms.tNormalDepth.value=l:(this.Tt.uniforms.tNormal.value=n,this.Tt.uniforms.tDepth.value=s)}convergenceMetric(){return this.H>1?1:0}render(e,t,i,a){this.needsUpdate&&(this.H=0,this.needsUpdate=!1),this.convergenceMetric(),this.ut||this.V(e);const r=e.getDrawingBufferSize().width,o=e.getDrawingBufferSize().height;this.Tt.uniforms.size.value.set(r,o),this.dt(t,i);const s=e.getClearColor(),n=e.getClearAlpha(),l=e.autoClear;e.autoClear=!1,PIXOTRON.renderPass(e,this.Tt,this.ut),this.blurEnabled&&(a.edgeSharpness=this.edgeSharpness,a.render(e,this.ut,t,i)),e.autoClear=l,e.setClearColor(s),e.setClearAlpha(n),e.saoBuffer=this.ut}V(e){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height;if(!this.ut){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.ut=new THREE.WebGLRenderTarget(t,i,e)}}}},function(e,t){e.exports=PIXOTRON.SAOShader={defines:{NUM_SAMPLES:11,NUM_SPIRAL_TURNS:3,DEPTH_NORMAL_TEXTURE:0,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},size:{type:"v2",value:new THREE.Vector2(512,512)},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},saoBiasEpsilon:{type:"v2",value:new THREE.Vector2}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform vec2 cameraNearFar;","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec2 saoBiasEpsilon;","uniform vec2 size;","#include <utilshader>","const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );","float getViewZFromNDCZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float random3(vec3 v) { ","v  = fract(v * 443.8975);","v += dot(v, v.yzx + 19.19);","return fract((v.x + v.y) * v.z);","}","vec3 getPositionFromOffset(const in vec2 uv, const in vec2 offset, const in float screenSpaceRadius) {","vec2 uvOffset = uv + floor(screenSpaceRadius * offset)/size;","float d = decodeDepth(uvOffset);","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( d );","return getViewPositionFromViewZ( uvOffset, centerViewZ );","#else","d = mix(-cameraNearFar.x, -cameraNearFar.y, d);","return getViewPositionFromViewZ(uvOffset, d);","#endif","}","float getOcclusion(const in vec2 uv, const in int id, const in float randomAngle, const in float occlusionSphereRadius, const in vec3 centerPosition, const in vec3 centerNormal) {","float screenSpaceRadius = (float(id) + mod(randomAngle, 1.) + 0.5) * INV_NUM_SAMPLES; ","float angle = screenSpaceRadius * (float(NUM_SPIRAL_TURNS) * 6.28) + randomAngle; ","screenSpaceRadius = (screenSpaceRadius * occlusionSphereRadius);","vec2 offset = vec2(cos(angle), sin(angle));","vec3 samplePosition = getPositionFromOffset(uv, offset, screenSpaceRadius);","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","float ao = max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( d2 + saoBiasEpsilon.y ), 0.0 );","return ao;","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( centerDepth );","#else","float centerViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 centerPosition = getViewPositionFromViewZ( vUv, centerViewZ );","vec3 centerNormal = getViewNormal(vUv);","float occlusionSphereScreenRadius = 200. * saoData.z/ (-centerPosition.z);","if( occlusionSphereScreenRadius < 1. ) {","discard;","}","float randomAngle = 6.2 * random3( vec3( vUv, saoData.w * 0.1 ) );","float sum = 0.0;","sum += getOcclusion(vUv, 0, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 1, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 2, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 3, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 4, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 5, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 6, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 7, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 8, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 9, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 10, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","float aoValue = sum * saoData.y * INV_NUM_SAMPLES;","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = max( aoValue, 0.0 );","}"].join("\n")}},function(e,t,i){function a(e,t){e.traverse(function(e){(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints)&&((t?e.castShadow:e.receiveShadow)||(e.oldVisibility=e.visible,e.visible=!1))})}function r(e){e.traverse(function(e){e.oldVisibility&&(e.visible=e.oldVisibility,e.oldVisibility=void 0)})}i(0),i(2),i(11),e.exports=PIXOTRON.ShadowPass=class{constructor(e){e=e||{},this.linearDepth=void 0!==e.linearDepth?e.linearDepth:1,this.shadowMapResolution=void 0!==e.shadowMapResolution?e.shadowMapResolution:1024,this.shadowRadius=void 0!==e.shadowRadius?e.shadowRadius:1,this.shadowQuality=void 0!==e.shadowQuality?e.shadowQuality:1,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.shadowBiasMultiplier=void 0!==e.shadowBiasMultiplier?e.shadowBiasMultiplier:1,this.numSamples=void 0!==e.numSamples?e.numSamples:100,this.side=void 0!==e.side?e.side:THREE.FrontSide;const t=void 0!==e.nearPlane?e.nearPlane:.1,i=void 0!==e.farPlane?e.farPlane:10,a=void 0!==e.fov?e.fov:110;this.wt=new THREE.PerspectiveCamera(a,1,t,i),this.rt=0,this.xt(this.numSamples),this.H=0,this.Dt=new THREE.Vector3,this.Nt=new THREE.Vector3(0,-1,0),this.gt=new THREE.Vector3,this.Pt=new THREE.Matrix4,this.lights=[],this.enabled=!0,this.enableAccumulation=!0,this.needsUpdate=!0,this.shadowRecieverBBox=null}convergenceMetric(){if(!this.enabled)return 1;let e=!0;return this.lights.forEach(t=>{t.castShadow||(e=!1)}),0!==this.lights.length&&e?this.H/this.Ot.length:1}render(e,t,i){if(this.needsUpdate&&(this.H=0,this.needsUpdate=!1),!this.enableAccumulation&&this.H>0)return;if(this.convergenceMetric()>=1)return;const a=e.getDrawingBufferSize().width,r=e.getDrawingBufferSize().height;this.St||(this.wt.layers.mask=i.layers.mask,this.Mt(a,r)),this.xt(this.numSamples);const o=e.getClearColor(),s=e.getClearAlpha(),n=e.autoClear;let l,h;this.lights.forEach((a,r)=>{this.H=Math.min(this.H,this.Ot.length-1),this.H++,this.Ct(a,this.H-1),this.Ht(e,t,this.Dt,this.St),l=this.H%2==0?this._t:this.yt,h=this.H%2==0?this.yt:this._t,this.It(e,t,i,l,h),this.smoothTransition&&0===r&&1===this.H&&PIXOTRON.blit(e,h,this.zt)}),this.smoothTransition&&(this.lt.uniforms.shadowAccumulationBuffer.value=h,this.lt.uniforms.firstFrameShadowBuffer.value=this.zt,this.lt.uniforms.transition.value=this.convergenceMetric(),PIXOTRON.renderPass(e,this.lt,l)),e.autoClear=n,e.setClearColor(o),e.setClearAlpha(s),this.lights.forEach(e=>{e.shadow.map=this.smoothTransition?l:h})}setSize(e,t){this._t&&this._t.setSize(e,t),this.yt&&this.yt.setSize(e,t),this.St&&this.St.setSize(e,t),this.zt&&this.zt.setSize(e,t),this.Ft.uniforms.shadowBufferSize.value.set(e,t)}Mt(e,t){const i={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.St=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,i),this._t=new THREE.WebGLRenderTarget(e,t,i),this.yt=new THREE.WebGLRenderTarget(e,t,i),this.zt=new THREE.WebGLRenderTarget(e,t,i),this.St.texture.generateMipmaps=!1,this._t.texture.generateMipmaps=!1,this.yt.texture.generateMipmaps=!1,this.zt.texture.generateMipmaps=!1,this.linearDepth?(this.$=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.$.side=this.side):this.$=new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking,side:this.side}),this.Ft=new THREE.ShaderMaterial(PIXOTRON.AccumulativeShadowsShader),this.Ft.uniforms.shadowBufferSize.value=new THREE.Vector2(e,t),this.Ft.uniforms.shadowMap.value=this.St,this.Ft.uniforms.shadowData.value=new THREE.Vector4(0,1,1,1),this.Ft.uniforms.shadowMapResolution.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.Ft.defines.SHADOW_QUALITY=this.shadowQuality,this.Ft.defines.LINEAR_DEPTH=this.linearDepth,this.lt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionShadowShader)}It(e,t,i,o,s){this.wt.matrixWorldInverse.getInverse(this.wt.matrixWorld),this.Pt.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.Pt.multiply(this.wt.projectionMatrix),this.Pt.multiply(this.wt.matrixWorldInverse),this.Ft.uniforms.shadowMatrix.value.copy(this.Pt),this.Ft.uniforms.shadowData.value.x=this.H,this.Ft.uniforms.shadowData.value.y=this.shadowRadius,this.Ft.uniforms.shadowData.value.z=this.shadowBiasMultiplier,this.Ft.uniforms.shadowAccumulationBuffer.value=o,this.Ft.uniforms.vplPosition.value=this.wt.position,this.Ft.uniforms.cameraNearFar.value.x=this.wt.near,this.Ft.uniforms.cameraNearFar.value.y=this.wt.far,e.setClearColor(0),a(t,!1);const n=e.shadowMap.enabled;e.shadowMap.enabled=!1,t.overrideMaterial=this.Ft,e.render(t,i,s,!0),t.overrideMaterial=null,r(t),e.shadowMap.enabled=n}Ht(e,t,i,o){a(t,!0),this.wt.position.copy(i),this.gt.copy(i),this.gt.addScaledVector(this.Nt,10),this.wt.lookAt(this.gt),this.wt.updateMatrixWorld(),t.overrideMaterial=this.$,this.linearDepth&&(this.$.uniforms.cameraNearFar.value.x=this.wt.near,this.$.uniforms.cameraNearFar.value.y=this.wt.far),e.setClearColor(0),e.render(t,this.wt,o,!0),t.overrideMaterial=null,r(t)}Ct(e,t){const i=e.matrixWorld;t%=this.Ot.length-1;const a=this.Ot[t];if(this.Dt.x=(a.x-.5)*e.width,this.Dt.z=0,this.Dt.y=(a.y-.5)*e.height,this.Dt.applyMatrix4(i),this.Nt.set(0,0,1),this.Nt.transformDirection(i),this.shadowRecieverBBox){const e=PIXOTRON.calculateFOV(this.shadowRecieverBBox,this.Dt,this.Nt);this.setFOV(e)}}setShadowRecieverBBox(e){this.shadowRecieverBBox=e}setFOV(e){this.wt.fov=e,this.wt.updateProjectionMatrix()}xt(e){e!==this.rt&&(this.rt=e,this.Ot=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.Ot=PIXOTRON.randomizeArray(this.Ot),this.Ot.splice(0,0,new THREE.Vector2(.5,.5)))}}},function(e,t){e.exports=PIXOTRON.AccumulativeShadowsShader={defines:{SHADOW_QUALITY:1,LINEAR_DEPTH:1},uniforms:{shadowMap:{value:null},shadowAccumulationBuffer:{value:null},shadowBufferSize:{value:null},shadowMatrix:{value:new THREE.Matrix4},vplPosition:{value:new THREE.Vector3},shadowData:{value:new THREE.Vector4},cameraNearFar:{value:new THREE.Vector2},shadowMapResolution:{value:null},normalBias:{value:1}},vertexShader:["varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec3 vplPosition;","uniform mat4 shadowMatrix;","uniform float normalBias;","void main() {","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","viewNormal = normalize(normalMatrix * normal);","vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;","lightVector = vplPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;","lightVector = normalize(lightVector);","shadowCoord = shadowMatrix * worldPosition;","float nDotL = clamp( dot(lightVector, viewNormal), 0.0, 1.0);","worldPosition.xyz += normalize((modelMatrix * vec4( normal, 0.0 )).xyz) * 0.02 * normalBias * pow( 1.0 -  nDotL * nDotL, 4.);","shadowCoord.xy = (shadowMatrix * worldPosition).xy;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec2 shadowBufferSize;","uniform vec2 shadowMapResolution;","uniform sampler2D shadowMap;","uniform sampler2D shadowAccumulationBuffer;","uniform vec4 shadowData;","uniform vec2 cameraNearFar;","float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {","#if LINEAR_DEPTH == 0","float shadowDepth = unpackRGBAToDepth( texture2D( depths, uv ) );","#else","float nDotL = clamp( dot(normalize(lightVector), normalize(viewNormal)), 0.0, 1.0);","float shadowDepth = pow2(unpackRGBAToDepth(texture2D( depths, uv ))) + 0.01 * shadowData.z;","shadowDepth = shadowDepth * ( cameraNearFar.y - cameraNearFar.x ) + cameraNearFar.x;","#endif","return step( compare, shadowDepth );","}","float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {","const vec2 offset = vec2( 0.0, 1.0 );","vec2 texelSize = vec2( 1.0 ) / size;","vec2 centroidUV = floor( uv * size + 0.5 ) / size;","float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );","float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );","float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );","float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );","vec2 f = fract( uv * size + 0.5 );","float a = mix( lb, lt, f.y );","float b = mix( rb, rt, f.y );","float c = mix( a, b, f.x );","return c;","}","void main() {","float shadowValue = 1.0;","float shadowRadius = shadowData.y;","float shadowBiasMultiplier = shadowData.z;","float nDotL = clamp( dot(lightVector, normalize(viewNormal)), 0.0, 1.0);","float shadowBias = 0.02 *  sqrt( 1.0 -  nDotL * nDotL) / clamp(nDotL, 0.0006,  1.0);","shadowBias = clamp(shadowBias, 0.0001,  0.0003) * shadowBiasMultiplier;","vec3 shadowCoordNDC = shadowCoord.xyz/shadowCoord.w;","shadowCoordNDC.z -= shadowBias;","#if LINEAR_DEPTH == 1","float linearDepth = shadowCoord.z + 2.0*cameraNearFar.y*cameraNearFar.x/(cameraNearFar.y - cameraNearFar.x);","linearDepth *= -((cameraNearFar.y - cameraNearFar.x)/(cameraNearFar.y + cameraNearFar.x));","linearDepth = -linearDepth;","#endif","bvec4 inFrustumVec = bvec4 ( shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoordNDC.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","#if LINEAR_DEPTH == 1","shadowCoordNDC.z = linearDepth;","#endif","if(frustumTest) {","#if SHADOW_QUALITY == 0","shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);","#elif SHADOW_QUALITY == 1","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = (","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#elif SHADOW_QUALITY == 2","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = ( ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#endif","}","float previousAccumulation = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, gl_FragCoord.xy/shadowBufferSize ));","float shadowAccumulation = mix(previousAccumulation, shadowValue, 1./shadowData.x);","gl_FragColor = packDepthToRGBA(shadowAccumulation);","}"].join("\n")}},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),i(13),t.default=PIXOTRON.SuperSampleAAPass=class extends THREE.Pass{constructor(){super(),this.needsSwap=!0,this.needsUpdate=!0,this.H=0,this.At=new THREE.ShaderMaterial(PIXOTRON.SuperSampleAAShader)}dispose(){this.pingpongRT&&this.pingpongRT.dispose()}render(e,t,i){const a=e.getClearColor(),r=e.getClearAlpha(),o=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.needsUpdate&&(this.H=0,this.needsUpdate=!1),this.Vt||this.V(e),this.H++,this.At.uniforms.tCurrent.value=i.texture,this.At.uniforms.tSumPrevious.value=this.Vt.texture,this.At.uniforms.accIndex.value=this.H,PIXOTRON.renderPass(e,this.At,t),PIXOTRON.blit(e,t,this.Vt),e.autoClear=o,e.setClearColor(a,r)}setSize(e,t){this.Vt&&this.Vt.setSize(e,t)}V(e){const t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height;this.Vt=new THREE.WebGLRenderTarget(i,a,t)}}},function(e,t,i){PIXOTRON.SuperSampleAAShader={uniforms:{tCurrent:{type:"t",value:null},tSumPrevious:{type:"t",value:null},accIndex:{type:"f",value:0}},vertexShader:"varying vec2 vUv;    void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"varying vec2 vUv;    uniform sampler2D tCurrent;    uniform sampler2D tSumPrevious;    uniform float accIndex;    void main() {      vec4 currentColor = texture2D(tCurrent, vUv);      vec4 previousSum = texture2D(tSumPrevious, vUv);      gl_FragColor = mix(previousSum, currentColor, 1./accIndex);    }    "}},function(e,t,i){i(15),e.exports=PIXOTRON.TemporalAAPass=class extends THREE.Pass{constructor(e,t){super(),this.feedBack=new THREE.Vector2(.8,.9),this.bt=e,this.N=t,this.Ut=new THREE.ShaderMaterial(PIXOTRON.TemporalAAShader),this.Xt=new THREE.Matrix4,this.Bt=new THREE.Matrix4,this.kt=new THREE.Matrix4,this.kt.copy(this.bt.projectionMatrix)}dispose(){this.Lt&&this.Lt.dispose()}setSize(e,t){this.Lt&&this.Lt.setSize(e,t),this.kt.copy(this.bt.projectionMatrix)}render(e,t,i){this.V(e);const a=e.getClearColor(),r=e.getClearAlpha(),o=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.Bt.multiplyMatrices(this.kt,this.bt.matrixWorldInverse),this.Zt(e,i),PIXOTRON.renderPass(e,this.Ut,t),PIXOTRON.blit(e,t,this.Lt),e.setClearColor(a,r),e.autoClear=o,this.Xt.copy(this.Bt)}V(e){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height;if(!this.Lt){const e={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.Lt=new THREE.WebGLRenderTarget(t,i,e)}}Zt(e,t){let i,a;i=this.N.K?this.N.K:this.N.et?this.N.et.texture:null,this.N.et||(a=this.N.tt?this.N.tt.texture:null),this.Ut.uniforms.currentRT.value=t.texture,this.Ut.uniforms.previousRT.value=this.Lt.texture,this.Ut.uniforms.tDepth.value=i||a;let r=this.N.K?0:1;this.N.forceDepthAndNormalPass&&this.N.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(r=2),this.Ut.defines.DEPTH_PACKING_MODE=r,this.Ut.uniforms.currentProjectionViewMatrix.value.copy(this.Bt),this.Ut.uniforms.lastProjectionViewMatrix.value.copy(this.Xt),this.Ut.uniforms.ProjectionMatrix.value.copy(this.kt),this.Ut.uniforms.InverseViewMatrix.value.copy(this.bt.matrixWorld),this.Ut.uniforms.feedBack.value.x=this.feedBack.x,this.Ut.uniforms.feedBack.value.y=this.feedBack.y;const o=this.Ut.uniforms.cameraNearFar.value;o.x=this.bt.near,o.y=this.bt.far;const s=e.getDrawingBufferSize().width,n=e.getDrawingBufferSize().height,l=this.Ut.uniforms.textureSize.value;l.x=s,l.y=n,this.Ut.defines.LINEAR_DEPTH=this.N.Y?1:0}}},function(e,t){e.exports=PIXOTRON.TemporalAAShader={defines:{DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1,QUALITY:1,UNJITTER:0},uniforms:{currentRT:{value:null},previousRT:{value:null},tDepth:{value:null},cameraNearFar:{value:new THREE.Vector2},textureSize:{value:new THREE.Vector2},lastProjectionViewMatrix:{value:new THREE.Matrix4},currentProjectionViewMatrix:{value:new THREE.Matrix4},ProjectionMatrix:{value:new THREE.Matrix4},InverseViewMatrix:{value:new THREE.Matrix4},jitterSample:{value:new THREE.Vector2},feedBack:{value:new THREE.Vector2(.88,.97)}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );        }",fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D currentRT;","uniform sampler2D previousRT;","uniform sampler2D tDepth;","uniform vec2 textureSize;","uniform mat4 lastProjectionViewMatrix;","uniform mat4 currentProjectionViewMatrix;","uniform mat4 ProjectionMatrix;","uniform mat4 InverseViewMatrix;","uniform vec2 cameraNearFar;","uniform vec2 jitterSample;","uniform vec2 feedBack;","#include <packing>","float unpack16(vec2 value) {","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","#if DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 0","return unpackRGBAToDepth( texture2D( tDepth, uv ) );","#else","return pow2(unpackRGBAToDepth(texture2D( tDepth, uv )));","#endif","#elif DEPTH_PACKING_MODE == 2","#if LINEAR_DEPTH == 1","return pow2(unpack16(texture2D( tDepth, uv ).xy));","#else","return pow2(unpack16( texture2D( tDepth, uv ).xy ));","#endif","#else","return texture2D( tDepth, uv ).x;","#endif","}","float getViewZ( const in float depth ) {","\t#if PERSPECTIVE_CAMERA == 1","\treturn perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#else","\treturn orthoDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#endif","}","vec3 find_closest_fragment_3x3(const in vec2 uv) { ","const vec3 offset = vec3(-1.0, 1.0, 0.0);","vec2 texelSize = 1.0/textureSize; ","vec3 dtr = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtc = vec3( 0, 1, decodeDepth( uv + offset.zx * texelSize) );","vec3 dtl = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dml = vec3(-1, 0, decodeDepth( uv + offset.yz * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv ) );","vec3 dmr = vec3( 1, 0, decodeDepth( uv + offset.xz * texelSize) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbc = vec3( 0, -1, decodeDepth( uv + offset.zy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtc.z ) dmin = dtc;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dml.z ) dmin = dml;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dmr.z ) dmin = dmr;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbc.z ) dmin = dbc;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + texelSize.xy * dmin.xy, dmin.z);","}","vec3 find_closest_fragment_5tap(const in vec2 uv) ","{ ","vec2 texelSize = 1.0/textureSize; ","vec2 offset = vec2(1.0, -1.0);","vec3 dtl = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtr = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + dmin.xy * texelSize, dmin.z);","}","vec4 clip_aabb(const in vec4 aabb_min, const in vec4 aabb_max, vec4 p )","{ ","const float FLT_EPS = 1e-8;","vec4 p_clip = 0.5 * (aabb_max + aabb_min); ","vec4 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS; ","vec4 v_clip = p - p_clip;","vec4 v_unit = abs(v_clip / e_clip);","float ma_unit = max(v_unit.x, max(v_unit.y, v_unit.z));","if (ma_unit > 1.0) ","return p_clip + v_clip / ma_unit;","else ","return p;","}","vec2 computeScreenSpaceVelocity(const in vec3 worldPosition) {","vec4 currentPositionClip = currentProjectionViewMatrix * vec4(worldPosition, 1.0);","vec4 prevPositionClip = lastProjectionViewMatrix * vec4(worldPosition, 1.0);","vec2 currentPositionNDC = currentPositionClip.xy / currentPositionClip.w;","vec2 prevPositionNDC = prevPositionClip.xy / prevPositionClip.w;","if(prevPositionNDC.x >= 1.0 || prevPositionNDC.x <= -1.0 || prevPositionNDC.x >= 1.0 || prevPositionNDC.y <= -1.0) {","return vec2(0.0);","}","return 0.5 * (currentPositionNDC - prevPositionNDC);","}","vec4 computeTAA(const in vec2 uv, const in vec2 screenSpaceVelocity) {","vec2 jitterOffset = jitterSample/textureSize;","vec2 uvUnJitter = uv;","vec4 currentColor = texture2D(currentRT, uvUnJitter);","vec4 previousColor = texture2D(previousRT, uv - screenSpaceVelocity);","const vec3 offset = vec3(1., -1., 0.);","vec2 texelSize = 1./textureSize;","float texelSpeed = length( screenSpaceVelocity );","vec4 tl = texture2D(currentRT, uvUnJitter + offset.yx * texelSize);","vec4 tc = texture2D(currentRT, uvUnJitter + offset.zx * texelSize);","vec4 tr = texture2D(currentRT, uvUnJitter + offset.xx * texelSize);","vec4 ml = texture2D(currentRT, uvUnJitter + offset.yz * texelSize);","vec4 mc = currentColor;","vec4 mr = texture2D(currentRT, uvUnJitter + offset.xz * texelSize);","vec4 bl = texture2D(currentRT, uvUnJitter + offset.yy * texelSize);","vec4 bc = texture2D(currentRT, uvUnJitter + offset.zy * texelSize);","vec4 br = texture2D(currentRT, uvUnJitter + offset.xy * texelSize);","vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * mc;","mc += (mc - (corners * 0.166667)) * 2.718282 * 0.3;","mc = max(vec4(0.0), mc);","vec4 min5 = min(tc, min(ml, min(mc, min(mr, bc))));","vec4 max5 = max(tc, max(ml, max(mc, max(mr, bc))));","vec4 cmin = min(min5, min(tl, min(tr, min(bl, br))));","vec4 cmax = max(min5, max(tl, max(tr, max(bl, br))));;","cmin = 0.5 * (cmin + min5);","cmax = 0.5 * (cmax + max5);","previousColor = clip_aabb(cmin, cmax, previousColor);","float lum0 = linearToRelativeLuminance(currentColor.rgb);","float lum1 = linearToRelativeLuminance(previousColor.rgb);","float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));","float unbiased_weight = 1.0 - unbiased_diff;","float unbiased_weight_sqr = unbiased_weight * unbiased_weight;","float k_feedback = mix(feedBack.x, feedBack.y, unbiased_weight_sqr);","return mix(currentColor, previousColor, k_feedback);","}","vec3 getWorldPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return (InverseViewMatrix * vec4(xe, ye, viewDepth, 1.)).xyz;","}","void main() {","vec2 jitterOffset = jitterSample/textureSize;","#if QUALITY == 1","vec3 c_frag = find_closest_fragment_3x3(vUv);","#else","vec3 c_frag = find_closest_fragment_5tap(vUv);","#endif","if( c_frag.z >= 0.999 ) {","gl_FragColor = texture2D(currentRT, vUv - jitterOffset);","}","else {","#if LINEAR_DEPTH == 0","float sampleViewZ = getViewZ( c_frag.z );","#else","float sampleViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, c_frag.z);","#endif","vec3 worldPosition = getWorldPositionFromViewZ(c_frag.xy, sampleViewZ);","vec2 screenSpaceVelocity = computeScreenSpaceVelocity(worldPosition);","gl_FragColor = computeTAA(vUv, screenSpaceVelocity);","//gl_FragColor = vec4(10. * length(screenSpaceVelocity));","}","}"].join("\n")}},function(e,t,i){i(17),e.exports=PIXOTRON.BilateralFilterPass=class{constructor(){this.blurKernelSize=3,this.edgeSharpness=1,this.bilateralFilterMaterial=new THREE.ShaderMaterial(PIXOTRON.SAOBilateralFilterShader),this.bilateralFilterMaterial.uniforms=THREE.UniformsUtils.clone(this.bilateralFilterMaterial.uniforms),this.bilateralFilterMaterial.defines=Object.assign({},this.bilateralFilterMaterial.defines)}render(e,t,i,a){this.V(e),this.Wt(e,t,i,a)}setSize(e,t){this.jt&&this.jt.setSize(e,t),this.bilateralFilterMaterial.uniforms.size.value.set(e,t)}dispose(){this.jt&&(this.jt.dispose(),this.jt=null)}V(e){if(!this.jt){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height,a={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.jt=new THREE.WebGLRenderTarget(t,i,a)}}Wt(e,t,i,a){const r=e.getDrawingBufferSize().width,o=e.getDrawingBufferSize().height;this.bilateralFilterMaterial.uniforms.size.value.set(r,o);const s=a.it?a.it.texture:null;let n;a.et||(n=a.tt?a.tt.texture:null),n?(this.bilateralFilterMaterial.defines.DEPTH_NORMAL_TEXTURE=1,this.bilateralFilterMaterial.uniforms.tNormal.value=n):this.bilateralFilterMaterial.uniforms.tNormal.value=s,this.bilateralFilterMaterial.defines.KERNEL_SAMPLE_RADIUS=this.blurKernelSize,this.bilateralFilterMaterial.defines.LINEAR_DEPTH=a.Y?1:0,this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=t.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(1,0),this.bilateralFilterMaterial.uniforms.edgeSharpness.value=this.edgeSharpness;const l=this.bilateralFilterMaterial.uniforms.cameraNearFar.value;l.x=i.near,l.y=i.far,PIXOTRON.renderPass(e,this.bilateralFilterMaterial,this.jt),this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=this.jt.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(0,1),PIXOTRON.renderPass(e,this.bilateralFilterMaterial,t)}}},function(e,t){e.exports=PIXOTRON.SAOBilateralFilterShader={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SAMPLE_RADIUS:4,LINEAR_DEPTH:1,DEPTH_NORMAL_TEXTURE:0},uniforms:{tOcclusionDepth:{type:"t",value:null},tNormal:{type:"t",value:null},size:{type:"v2",value:new THREE.Vector2(256,256)},kernelDirection:{type:"v2",value:new THREE.Vector2(1,0)},cameraNearFar:{type:"v2",value:new THREE.Vector2(1,0)},edgeSharpness:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D tOcclusionDepth;","uniform sampler2D tNormal;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform float edgeSharpness;","uniform vec2 kernelDirection;","#include <packing>","float getViewZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 unpackNormal(vec2 enc) {","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","vec3 getViewNormal( const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormal, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linearStep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","float unpackRGBToFloat(const in vec3 x) {","const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);","return dot(x, decode);","}","void calculateBilateralWeight( const in vec2 uv, const in vec3 centreNormal, const in float centerDepth,","const in float kernelWeight, inout float totalOcclusion, inout float totalBilateralWeight ) {","vec4 aoDepth = texture2D( tOcclusionDepth, uv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","return;","}","vec3 normal = getViewNormal(uv);","#if LINEAR_DEPTH == 0","depth = -getViewZ( depth );","depth = linearStep(cameraNearFar.x, cameraNearFar.y, depth);","#endif","float normalCloseness = dot(normal, centreNormal);","normalCloseness *= normalCloseness;","float normalError = (1.0 - normalCloseness) * 8.;","float normalWeight = max((1.0 - normalError * edgeSharpness), 0.00);","float depthWeight = max(0.0, 1.0 - edgeSharpness * 4000. * abs(depth - centerDepth)) * kernelWeight;","float bilateralWeight = depthWeight * normalWeight;","totalOcclusion += occlusion * bilateralWeight;","totalBilateralWeight += bilateralWeight;","}","void main() {","vec4 aoDepth = texture2D( tOcclusionDepth, vUv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","discard;","}","vec3 centreNormal = getViewNormal(vUv);","#if LINEAR_DEPTH == 0","float centerViewZ = -getViewZ( depth );","centerViewZ = linearStep(cameraNearFar.x, cameraNearFar.y, centerViewZ);","#else","float centerViewZ = depth;","#endif","float gaussianWeights[4];","gaussianWeights[0] = 0.153170;","gaussianWeights[1] = 0.144893;","gaussianWeights[2] = 0.122649;","gaussianWeights[3] = 0.092902;","float totalBilateralWeight = gaussianWeights[0] + 0.03;","float totalOcclusion = occlusion * totalBilateralWeight;","vec2 uvDelta = 2.0 * kernelDirection / size;","float kernelWeight = gaussianWeights[1] + 0.03;","calculateBilateralWeight( vUv + uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[2] + 0.03;","calculateBilateralWeight( vUv + 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[3] + 0.03;","calculateBilateralWeight( vUv + 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","occlusion = totalOcclusion / totalBilateralWeight;","gl_FragColor = vec4( occlusion, aoDepth.gba );","}"].join("\n")}},function(e,t,i){i(19),e.exports=PIXOTRON.UnrealBloomPass=class extends THREE.Pass{constructor(e,t,i,a,r){super(),this.N=e,this.strength=void 0!==i?i:1,this.radius=a,this.threshold=r,this.resolution=void 0!==t?new THREE.Vector2(t.x,t.y):new THREE.Vector2(256,256);const o={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let s=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(s,n,o),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){let t=new THREE.WebGLRenderTarget(s,n,o);t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t),(t=new THREE.WebGLRenderTarget(s,n,o)).texture.name="UnrealBloomPass.v"+e,t.texture.generateMipmaps=!1,this.renderTargetsVertical.push(t),s=Math.round(s/2),n=Math.round(n/2)}const l=PIXOTRON.BloomExtractShader;this.bloomExtractUniforms=THREE.UniformsUtils.clone(l.uniforms),this.bloomExtractUniforms.bloomThreshold.value=r,this.materialBloomExtract=new THREE.ShaderMaterial({uniforms:this.bloomExtractUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{DEPTH_PACKING_MODE:0,LINEAR_DEPTH:1}}),this.separableBlurMaterials=[];const h=[3,5,7,9,11];s=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(h[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(s,n),s=Math.round(s/2),n=Math.round(n/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=i,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const c=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(c.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.basic=new THREE.MeshBasicMaterial,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let i=Math.round(e/2),a=Math.round(t/2);this.renderTargetBright.setSize(i,a);for(let e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(i,a),this.renderTargetsVertical[e].setSize(i,a),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(i,a),i=Math.round(i/2),a=Math.round(a/2)}render(e,t,i,a,r){this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha();const o=e.autoClear;let s,n;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),r&&e.context.disable(e.context.STENCIL_TEST),this.renderToScreen&&(this.quad.material=this.basic,this.basic.map=i.texture,e.render(this.scene,this.camera,void 0,!0)),s=this.N.K?this.N.K:this.N.et?this.N.et.texture:null,this.N.et||(n=this.N.tt?this.N.tt.texture:null),this.materialBloomExtract.uniforms.tDepth.value=s||n;let l=this.N.K?0:1;this.N.forceDepthAndNormalPass&&this.N.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(l=2),this.materialBloomExtract.defines.DEPTH_PACKING_MODE=l,this.materialBloomExtract.defines.LINEAR_DEPTH=this.N.Y?1:0,this.bloomExtractUniforms.tColor.value=i.texture,this.bloomExtractUniforms.bloomThreshold.value=this.threshold,this.quad.material=this.materialBloomExtract,e.render(this.scene,this.camera,this.renderTargetBright,!0);let h=this.renderTargetBright;for(let t=0;t<this.nMips;t++)this.quad.material=this.separableBlurMaterials[t],this.separableBlurMaterials[t].uniforms.colorTexture.value=h.texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionX,e.render(this.scene,this.camera,this.renderTargetsHorizontal[t],!0),this.separableBlurMaterials[t].uniforms.colorTexture.value=this.renderTargetsHorizontal[t].texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionY,e.render(this.scene,this.camera,this.renderTargetsVertical[t],!0),h=this.renderTargetsVertical[t];this.quad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.render(this.scene,this.camera,this.renderTargetsHorizontal[0],!0),this.quad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&e.context.enable(e.context.STENCIL_TEST),this.renderToScreen?e.render(this.scene,this.camera,void 0,!1):e.render(this.scene,this.camera,i,!1),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=o}getSeperableBlurMaterial(e){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum);\n\t\t\t\t}"})}getCompositeMaterial(e){return new THREE.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"})}},PIXOTRON.UnrealBloomPass.BlurDirectionX=new THREE.Vector2(1,0),PIXOTRON.UnrealBloomPass.BlurDirectionY=new THREE.Vector2(0,1)},function(e,t){e.exports=PIXOTRON.BloomExtractShader={uniforms:{tColor:{type:"t",value:null},tDepth:{type:"t",value:null},bloomThreshold:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <packing>","uniform sampler2D tColor;","uniform sampler2D tDepth;","uniform float bloomThreshold;","varying vec2 vUv;","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth = texture2D( tDepth, uv );","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow(unpackRGBAToDepth(uncodedDepth), 2.);","#else","return unpackRGBAToDepth(uncodedDepth );","#endif","#else","return pow(unpack16(uncodedDepth.xy), 2.);","#endif","}","void main() {","vec4 color = texture2D( tColor, vUv );","float depth = decodeDepth(vUv);","const vec3 c = vec3( 0.299, 0.587, 0.114 );","float luminance = dot( color.xyz, c );","float alpha = smoothstep( bloomThreshold, bloomThreshold + 0.01, luminance );","alpha = depth > 1. - 0.001 ? 0. : alpha;","gl_FragColor = color * alpha;","}"].join("\n")}}]);