var shaderMaterial,camera,scene,shader,PMREMCubeUVPacker;THREE.PMREMCubeUVPacker=(camera=new THREE.OrthographicCamera,scene=new THREE.Scene,(shaderMaterial=new THREE.ShaderMaterial({uniforms:{faceIndex:{value:0},mapSize:{value:0},envMap:{value:null},testColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"precision highp float;        varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );        }",fragmentShader:"precision highp float;        varying vec2 vUv;        uniform samplerCube envMap;        uniform float mapSize;        uniform vec3 testColor;        uniform int faceIndex;                void main() {          vec3 sampleDirection;          vec2 uv = vUv;          uv = uv * 2.0 - 1.0;          uv.y *= -1.0;          if(faceIndex == 0) {            sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));          } else if(faceIndex == 1) {            sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));          } else if(faceIndex == 2) {            sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));          } else if(faceIndex == 3) {            sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));          } else if(faceIndex == 4) {            sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));          } else {            sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));          }          vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );          gl_FragColor = linearToOutputTexel( color );        }",blending:THREE.NoBlending})).type="PMREMCubeUVPacker",shader=shaderMaterial,(PMREMCubeUVPacker=function(e){this.cubeLods=e;var a=4*e[0].width,r=e[0].texture,t={format:r.format,magFilter:r.magFilter,minFilter:r.minFilter,type:r.type,generateMipmaps:r.generateMipmaps,anisotropy:r.anisotropy,encoding:r.encoding===THREE.RGBEEncoding?THREE.RGBM16Encoding:r.encoding};t.encoding===THREE.RGBM16Encoding&&(t.magFilter=THREE.LinearFilter,t.minFilter=THREE.LinearFilter),this.CubeUVRenderTarget=new THREE.WebGLRenderTarget(a,a,t),this.CubeUVRenderTarget.texture.name="PMREMCubeUVPacker.cubeUv",this.CubeUVRenderTarget.texture.mapping=THREE.CubeUVReflectionMapping,this.objects=[];var n=new THREE.PlaneBufferGeometry(1,1),i=[];i.push(new THREE.Vector2(0,0)),i.push(new THREE.Vector2(1,0)),i.push(new THREE.Vector2(2,0)),i.push(new THREE.Vector2(0,1)),i.push(new THREE.Vector2(1,1)),i.push(new THREE.Vector2(2,1));var o=a;a=e[0].width;var c=0,s=4;this.numLods=Math.log(e[0].width)/Math.log(2)-2;for(var u=0;u<this.numLods;u++){var p=.5*(o-o/s);a>16&&(s*=2);for(var m=a>16?6:1,v=0,l=0,E=a,d=0;d<m;d++){for(var g=0;g<6;g++){var h=shader.clone();h.uniforms.envMap.value=this.cubeLods[u].texture,h.envMap=this.cubeLods[u].texture,h.uniforms.faceIndex.value=g,h.uniforms.mapSize.value=E;var M=new THREE.Mesh(n,h);M.position.x=i[g].x*E-p+v,M.position.y=i[g].y*E-p+c+l,M.material.side=THREE.BackSide,M.scale.setScalar(E),this.objects.push(M)}l+=1.75*E,v+=1.25*E,E/=2}c+=2*a,a>16&&(a/=2)}}).prototype={constructor:PMREMCubeUVPacker,update:function(e){var a=4*this.cubeLods[0].width;camera.left=.5*-a,camera.right=.5*a,camera.top=.5*-a,camera.bottom=.5*a,camera.near=0,camera.far=1,camera.updateProjectionMatrix();for(var r=0;r<this.objects.length;r++)scene.add(this.objects[r]);var t=e.gammaInput,n=e.gammaOutput,i=e.toneMapping,o=e.toneMappingExposure,c=e.getRenderTarget();for(e.gammaInput=!1,e.gammaOutput=!1,e.toneMapping=THREE.LinearToneMapping,e.toneMappingExposure=1,e.render(scene,camera,this.CubeUVRenderTarget,!1),e.setRenderTarget(c),e.toneMapping=i,e.toneMappingExposure=o,e.gammaInput=t,e.gammaOutput=n,r=0;r<this.objects.length;r++)scene.remove(this.objects[r])},dispose:function(){for(var e=0,a=this.objects.length;e<a;e++)this.objects[e].material.dispose();this.objects[0].geometry.dispose()}},PMREMCubeUVPacker);