!function(e){var t={};function i(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=e,i.c=t,i.d=function(e,t,a){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:a})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=4)}([function(e,t,i){function a(e){const t=Math.floor(Math.random()*e.length),i=e[t];return e.splice(t,1),i}function r(e,t,i){this.width=e,this.height=t,this.cellSize=i,this.array=new Array(e);for(let i=0;i<e;i++)this.array[i]=new Array(t)}function s(e,t){const i=t*(Math.random()+1),a=6.283185307178*Math.random(),r=e.x+i*Math.cos(a),s=e.y+i*Math.sin(a);return new THREE.Vector2(r,s)}i(2),r.prototype={constructor:r,t:function(e){const t=Math.floor(e.x/this.cellSize),i=Math.floor(e.y/this.cellSize);this.array[t][i]=e},h:function(e,t){const i=Math.floor(e.x/this.cellSize),a=Math.floor(e.y/this.cellSize);for(let r=i-5;r<i+5;r++)for(let i=a-5;i<a+5;i++)if(r>=0&&r<this.width&&i>=0&&i<this.height){const a=this.array[r][i];let s=1e10;if(void 0!==a&&(s=a.distanceTo(e)),s<t)return!0}return!1}},e.exports=(PIXOTRON.lerpDistribution=function(e,t,i){return(t=t||.47)*(1-e)+(i=i||7)*e},PIXOTRON.uniformDistribution=function(){return 1},PIXOTRON.cosineDistribution=function(e){const t=e*Math.PI/2,i=Math.cos(t);return.47*(1-i)+7*i},PIXOTRON.generateQuasiRandomPoints=function(e,t,i,o){i=i||PIXOTRON.uniformDistribution,o=o||PIXOTRON.insideCircle,t<0&&(t=Math.sqrt(e)/e);const n=[],h=[],l=t/Math.sqrt(2),u=new r(Math.ceil(1/l),Math.ceil(1/l),l),c=new THREE.Vector2(.5,.5);let d=!1;do{c.x=Math.random(),c.y=Math.random(),d=o(c.x,c.y)}while(!d);for(h.push(c),n.push(c),u.t(c);0!==h.length&&n.length<e;){const e=a(h);for(let a=0;a<30;a++){const a=e.x-.5,r=e.y-.5,l=i(Math.sqrt(a*a+r*r)),c=s(e,l*t);!o(c.x,c.y)||u.h(c,l*t)||(h.push(c),n.push(c),u.t(c))}}return n})},function(e,t){e.exports=PIXOTRON.SmoothTransitionAOShader={uniforms:{saoAccumulationBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["varying vec2 vUv;","uniform float transition;","uniform sampler2D saoAccumulationBuffer;","void main() {","float aoValue = texture2D( saoAccumulationBuffer, vUv).r;","gl_FragColor = vec4(mix(0., aoValue, transition));","}"].join("\n")},e.exports=PIXOTRON.SmoothTransitionShadowShader={uniforms:{shadowAccumulationBuffer:{value:null},firstFrameShadowBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["#include <packing>","varying vec2 vUv;","uniform float transition;","uniform sampler2D shadowAccumulationBuffer;","uniform sampler2D firstFrameShadowBuffer;","void main() {","float shadowValueFirstFrame = unpackRGBAToDepth(texture2D( firstFrameShadowBuffer, vUv));","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","gl_FragColor = vec4(mix(shadowValueFirstFrame, shadowValue, pow(transition, 4.)));","}"].join("\n")},e.exports=PIXOTRON.SmoothTransitionSoftShadowShadowShader={defines:{SHADOW_MATERIAL:1},uniforms:{shadowAccumulationBuffer:{value:null},transition:{value:0},shadowData:{value:new THREE.Vector3(1,2,1)}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["#include <packing>","varying vec2 vUv;","uniform float transition;","uniform vec3 shadowData;","uniform sampler2D shadowAccumulationBuffer;","void main() {","#if SHADOW_MATERIAL == 1","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","float mask = (1. - shadowValue) * shadowData.x;","mask = pow(mask, shadowData.y);","gl_FragColor =  vec4(mix(vec4(0.), vec4(vec3(0.), mask), pow(transition, 4.)));","#else","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","float mask = (1. - shadowValue);","mask = pow(shadowValue, shadowData.y);","gl_FragColor = vec4(mask + shadowData.x);","#endif","}"].join("\n")}},function(e,t){function i(e){return 0==(e&e-1)&&0!==e}THREE.ShaderChunk.utilshader=["vec2 pack16(float value){","float sMax = 65535.0;","int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);","int digit0 = v/256;","int digit1 = v-digit0*256;","return vec2(float(digit0)/255.0, float(digit1)/255.0);","}","vec2 packNormal(vec3 n){","float p = sqrt(n.z*8.0+8.0);","return vec2(n.xy/p + 0.5);","}","vec3 unpackNormal(vec2 enc){","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","vec3 getViewNormal(const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormalDepth, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linstep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","vec3 packFloatToRGB(const in float x) {","const vec3 code = vec3(1.0, 255.0, 65025.0);","vec3 pack = vec3(code * x);","pack.gb = fract(pack.gb);","pack.rg -= pack.gb * (1.0 / 256.0);","return pack;","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth;","#if DEPTH_PACKING_MODE == 2","uncodedDepth = texture2D( tNormalDepth, uv );","#else","uncodedDepth = texture2D( tDepth, uv );","#endif","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow2(unpackRGBAToDepth(uncodedDepth));","#else","return unpackRGBAToDepth( uncodedDepth );","#endif","#else","return pow2(unpack16(uncodedDepth.xy));","#endif","}"].join("\n"),function(){const e=THREE.CopyShader;PIXOTRON.u=THREE.UniformsUtils.clone(e.uniforms),PIXOTRON.v=new THREE.ShaderMaterial({uniforms:PIXOTRON.u,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,depthWrite:!1,depthTest:!1}),PIXOTRON.R=new THREE.ShaderMaterial({uniforms:PIXOTRON.u,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),PIXOTRON.T=new THREE.Scene,PIXOTRON.D=new THREE.OrthographicCamera(-1,1,1,-1,0,1),PIXOTRON.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),PIXOTRON.v),PIXOTRON.quad.frustumCulled=!1,PIXOTRON.T.add(PIXOTRON.quad)}(),e.exports=PIXOTRON.randomizeArray=function(e){let t,i,a=e.length;for(;0!==a;)i=Math.floor(Math.random()*a),t=e[a-=1],e[a]=e[i],e[i]=t;return e},e.exports=PIXOTRON.createTextureFromRawData=function(e,t){(t=t||{}).type=t.type||THREE.FloatType,t.format=t.format||THREE.LuminanceAlphaFormat,t.minFilter=t.minFilter||THREE.NearestFilter,t.magFilter=t.magFilter||THREE.NearestFilter;const i=new Float32Array(2*e.length);for(let t=0;t<2*e.length;t+=2)i[t]=e[t/2].x-.5,i[t+1]=e[t/2].y-.5;const a=new THREE.DataTexture(i,e.length,1);return a.format=t.format,a.type=t.type,a.minFilter=t.minFilter,a.magFilter=t.magFilter,a.generateMipmaps=!1,a.needsUpdate=!0,a},e.exports=PIXOTRON.jitterCamera=function(e,t,i,a,r){r=void 0!==r?r:.5;const s=(2*t.x-1)*r,o=(2*t.y-1)*r;e.setViewOffset(i,a,s,o,i,a)},e.exports=PIXOTRON.insideCircle=function(e,t,i){const a=e-.5,r=t-.5;return a*a+r*r<=(i=void 0!==i?i:.5)*i},e.exports=PIXOTRON.insideRectangle=function(e,t,i,a){return i=void 0!==i?i:1,a=void 0!==a?a:1,e>=0&&t>=0&&e<=i&&t<=a},e.exports=PIXOTRON.blit=function(e,t,i,a){a=void 0!==a&&a,PIXOTRON.u.tDiffuse.value=t,PIXOTRON.quad.material=PIXOTRON.v,e.render(PIXOTRON.T,PIXOTRON.D,i,a)},e.exports=PIXOTRON.blitTransparent=function(e,t,i,a){a=void 0!==a&&a,PIXOTRON.u.tDiffuse.value=t,PIXOTRON.quad.material=PIXOTRON.R,e.render(PIXOTRON.T,PIXOTRON.D,i,a)},e.exports=PIXOTRON.renderPass=function(e,t,i,a){a=void 0!==a&&a,PIXOTRON.quad.material=t,e.render(PIXOTRON.T,PIXOTRON.D,i,a)},e.exports=PIXOTRON.calculateFOV=function(e,t,i){let a;e.isBox3?a=e:(a=new THREE.Box3).setFromObject(e);const r=new THREE.Vector3;a.getCenter(r);const s=new THREE.Vector3;a.getSize(s);const o=new THREE.Vector3;o.set(s.x/2,s.y/2,s.z/2),o.add(r),o.sub(t),o.normalize();let n=i.dot(o);return o.set(-s.x/2,s.y/2,s.z/2),o.add(r),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(s.x/2,-s.y/2,s.z/2),o.add(r),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(s.x/2,s.y/2,-s.z/2),o.add(r),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(-s.x/2,-s.y/2,-s.z/2),o.add(r),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(-s.x/2,s.y/2,-s.z/2),o.add(r),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(s.x/2,-s.y/2,-s.z/2),o.add(r),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(-s.x/2,-s.y/2,s.z/2),o.add(r),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),180*Math.acos(n)/Math.PI*2},e.exports=PIXOTRON.isPowerOfTwo=function(e){return i(e.width)&&i(e.height)},e.exports=PIXOTRON.makePowerOfTwo=function(e){function t(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}if(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageBitmap){const i=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return i.width=t(e.width),i.height=t(e.height),i.getContext("2d").drawImage(e,0,0,i.width,i.height),i}return e},e.exports=PIXOTRON.getDataFromImage=function(e,t){const i=document.createElement("canvas"),a=t,r=t/(e.width/e.height);i.width=a,i.height=r;const s=i.getContext("2d");return s.drawImage(e,0,0,a,r),s.getImageData(0,0,a,r)},e.exports=PIXOTRON.getPixelFromImageData=function(e,t,i){const a=4*(t+e.width*i),r=e.data;return{r:r[a],g:r[a+1],b:r[a+2],a:r[a+3]}},e.exports=PIXOTRON.squareToUniformDiskConcentric=function(){const e=new THREE.Vector2;return function(t){const i=2*t.x-1,a=2*t.y-1;let r,s;0===i&&0===a?s=r=0:i*i>a*a?(s=i,r=Math.PI/4*(a/i)):(s=a,r=Math.PI/2-i/a*(Math.PI/4));const o=Math.sin(r),n=Math.cos(r);return e.x=s*n,e.y=s*o,e}}(),e.exports=PIXOTRON.squareToCosineHemisphere=function(){const e=new THREE.Vector3;return function(t){const i=PIXOTRON.squareToUniformDiskConcentric(t),a=Math.sqrt(1-i.x*i.x-i.y*i.y);return e.set(i.x,i.y,a),e}}(),e.exports=PIXOTRON.startPerformanceTest=function(e){return PIXOTRON.gpuProfiler&&PIXOTRON.gpuProfiler.start(e)},e.exports=PIXOTRON.endPerformanceTest=function(e,t){const i=PIXOTRON.gpuProfiler&&PIXOTRON.gpuProfiler.result(e);return i&&t.callback&&t.callback({time:i,name:t.name}),i}},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),i(20),t.default=PIXOTRON.SuperSampleAAPass=class extends THREE.Pass{constructor(){super(),this.needsSwap=!0,this.needsUpdate=!0,this.N=0,this.O=new THREE.ShaderMaterial(PIXOTRON.SuperSampleAAShader)}dispose(){this.pingpongRT&&this.pingpongRT.dispose(),this.O.dispose()}render(e,t,i){const a=e.getClearColor(),r=e.getClearAlpha(),s=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.needsUpdate&&(this.N=0,this.needsUpdate=!1),this.P||this.S(e),this.N++,this.O.uniforms.tCurrent.value=i.texture,this.O.uniforms.tSumPrevious.value=this.P.texture,this.O.uniforms.accIndex.value=this.N,PIXOTRON.renderPass(e,this.O,t),PIXOTRON.blit(e,t,this.P),e.autoClear=s,e.setClearColor(a,r)}setSize(e,t){this.P&&this.P.setSize(e,t)}S(e){const t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height;this.P=new THREE.WebGLRenderTarget(i,a,t)}}},function(e,t,i){e.exports=PIXOTRON={},i(2),i(5),i(7),i(8),i(0),i(9),i(11),i(13),i(15),i(17),i(3),i(21),i(23),i(25),i(27),i(28),i(30),e.exports=PIXOTRON.Pixotron=class{constructor(e){(e=e||{}).saoparams=e.saoparams||{},e.shadowparams=e.shadowparams||{},e.gbufferparams=e.gbufferparams||{},e.outlineparams=e.outlineparams||{},this.needsUpdate=!0,this.autoSAOClear=!0,this.autoShadowsClear=!0,this.enableAA=!0,this.M=new PIXOTRON.BilateralFilterPass(3,1),this.H=new PIXOTRON.GBufferPass(e.gbufferparams);const t=e.giParams||{};this.enableGI=!!t.enable,this.enableGI&&this.initializeGI(t),this.C=new PIXOTRON.BVHManager;const i=void 0===e.saoparams.accumulative||e.saoparams.accumulative;this._=i?new PIXOTRON.AccumulativeSAOPass(e.saoparams):new PIXOTRON.SAOPass(e.saoparams),this.I=new PIXOTRON.ShadowPass(e.shadowparams),e.groundShadow&&(this.A=new PIXOTRON.PlaneShadowBakePass(e.groundShadow)),this.X=new PIXOTRON.SuperSampleAAPass,this.F=PIXOTRON.generateQuasiRandomPoints(30,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.V=new PIXOTRON.OutlinePass(e.outlineparams);const a={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.U=new THREE.WebGLRenderTarget(1,1,a),this.L=new THREE.WebGLRenderTarget(1,1,a),this.N=0,this.B=null,this.k=null,this.W=[],this.W.push(this.M),this.W.push(this.H),this.W.push(this._),this.W.push(this.I),this.W.push(this.V),e.groundShadow&&this.W.push(this.A),this.j=0,this.debug=!1}addNodeToAccelerationStructure(e,t){t?this.C.add(e):e.traverse(e=>{e.isMesh&&e.castShadow&&(e.updateMatrixWorld(),this.C.add(e))})}addRenderCompleteCallback(e){this.renderCompleteCallback=e}removeRenderCompleteCallback(){this.renderCompleteCallback=null}blit(e){this.Z&&PIXOTRON.blit(this.renderer,this.Z,e,!1),this.blitHighlights()}dispose(){this.W.forEach(e=>{e.dispose()}),this.G.renderTarget1.dispose(),this.G.renderTarget2.dispose(),this.U.dispose(),this.L.dispose()}enableVPLGeneration(){this.q&&(this.q.K=!0)}getBloomPass(){return this.J}getGBufferPass(){return this.H}getHighLightPass(){return this.V}getRenderPass(){return this.Y}getSAOPass(){return this._}getShadowPass(){return this.I}getTotalRenderTime(){return this.j}getVPLGenerationPass(){return this.q}getShadowPlanePass(){return this.A}highlightObjects(e){this.$=e}initializeGI(e){this.q=new PIXOTRON.VPLGenerationPass(500),this.tt=new PIXOTRON.InstantRadiosityPass,this.W.push(this.q),this.W.push(this.tt)}insertPass(e,t){this.G.insertPass(e,t)}isAccumulationConverged(){const e=this.I.enableAccumulation,t=this._.convergenceMetric()>=1,i=!e||this.I.convergenceMetric()>=1,a=!this.enableGI||this.tt.convergenceMetric()>=1;return i&&t&&a}isSuperSamplingConverged(){return this.N/this.F.length>=1}renderFrame(e,t,i,a){for(this.needsUpdate=!0;!this.isSuperSamplingConverged();)this.render(e,t,i,a)}render(e,t,i,a){if(this.needsUpdate&&(this.et(),this.N=0,this.jitterIndex=0,this.needsUpdate=!1,this.autoSAOClear=!0,this.autoShadowsClear=!0),!this.B||this.B.uuid===i.uuid&&this.k.uuid===t.uuid||(this.B=i,this.k=t,this.Y.camera=this.B,this.Y.scene=this.k,this.it.B=this.B,this.it.st.copy(this.B.projectionMatrix)),this.bInitialized||this.S(e,t,i,a),this.ot(t),this.enableGI&&this.q.generateVPLs(t,this.areaLights[0],10,this.C),this.A&&this.A.render(e,t,i),this.isSuperSamplingConverged()&&this.at(),!this.isSuperSamplingConverged()){this.rt(e,t,i),this.nt();const a=this.isAccumulationConverged();this.X.enabled=a||0!==this.N,this.it.enabled=this.enableAA&&(0===this.N||!a),this.ht(i),this.G.writeBuffer=this.G.renderTarget2,this.G.readBuffer=this.G.renderTarget1,this.j=0,this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.G.render(),this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"Composer Render"}),i.clearViewOffset(),this.jitterIndex++,this.X.enabled&&this.N++}a&&this.lt(this.k,this.B)}setSize(e,t){this.renderer&&(e*=this.renderer.getPixelRatio(),t*=this.renderer.getPixelRatio(),this.renderer.screenBufferSize=new THREE.Vector2(e,t)),this.H.setSize(e,t),this._.setSize(e,t),this.I.setSize(e,t),this.G&&this.G.setSize(e,t),this.needsUpdate=!0}setAntiAliasingFeedBackParams(e,t){this.it&&(this.it.feedBack.x=e,this.it.feedBack.y=t)}updateShadowPlane(e){this.A&&this.A.update(e)}ht(e){if(this.enableAA||this.isAccumulationConverged()){const t=this.renderer.getDrawingBufferSize().width,i=this.renderer.getDrawingBufferSize().height,a=this.F[this.jitterIndex%this.F.length];PIXOTRON.jitterCamera(e,a,t,i)}if(this.isAccumulationConverged()){const e=this.F[this.jitterIndex%this.F.length];this.ct(e)}}nt(){this._.enabled||(this.renderer.saoBuffer=this.L.texture);const e=this,t=!this.I.enabled,i=!function(){let t=!0;return e.areaLights.forEach(e=>{e.castShadow||(t=!1)}),t}(),a=0===this.areaLights.length;(t||i||a)&&this.I.lights.forEach(e=>{e.shadow.map=this.U})}blitHighlights(){if(!this.getHighLightPass()||!this.$)return;if(!this.$[0])return;const e=this.renderer.autoClear;this.renderer.autoClear=!1,PIXOTRON.blitTransparent(this.renderer,this.getHighLightPass().ut,void 0),this.renderer.autoClear=e}dt(){this.j+=this.H.getTotalRenderTime(),this.j+=this._.getTotalRenderTime(),this.j+=this.I.getTotalRenderTime()}at(){this.renderCompleteCallback&&!this.renderCompleteCallbackCalled&&(this.renderCompleteCallback(),this.renderCompleteCallbackCalled=!0)}ot(e){const t=this;this.punctualLights=[],this.areaLights=[],e.traverseVisible(function(e){(e instanceof THREE.DirectionalLight||e instanceof THREE.SpotLight)&&e.castShadow&&t.punctualLights.push(e),e instanceof THREE.RectAreaLight&&e.castShadow&&(e.shadow=e.shadow?e.shadow:{},e.N=e.N?e.N:0,t.areaLights.push(e))}),this.I.lights=this.areaLights}ct(e){this.punctualLights.forEach(t=>{PIXOTRON.jitterCamera(t.shadow.camera,e,t.shadow.mapSize.x,t.shadow.mapSize.y)})}S(e,t,i,a){this.renderer=e,this.B=i,this.k=t,this.Z=a,this.Y=new THREE.RenderPass(t,i),this.G=new THREE.EffectComposer(this.renderer,a);const r=e.getDrawingBufferSize();this.X.setSize(r.width,r.height),this.renderer.screenBufferSize=new THREE.Vector2(r.width,r.height),this.it=new PIXOTRON.TemporalAAPass(i,this.H),this.vt=new THREE.ShaderPass(THREE.CopyShader),this.vt.needsSwap=!1,this.vt.renderToScreen=!a,this.G.addPass(this.Y),this.J=new PIXOTRON.UnrealBloomPass(this.H,new THREE.Vector2(r.width,r.height),.86,1,.98),this.G.addPass(this.J),this.W.push(this.J),this.G.addPass(this.X),this.G.addPass(this.it),this.W.push(this.X),this.W.push(this.it),this.J.enabled=!1,this.G.addPass(this.vt),this.bInitialized=!0;const s=new THREE.MeshBasicMaterial({color:16777215}),o=new THREE.MeshBasicMaterial({color:0});PIXOTRON.renderPass(e,s,this.U),PIXOTRON.renderPass(e,o,this.L),this.ft=e.getContext(),this.pt=this.ft&&this.ft.getExtension("EXT_disjoint_timer_query"),PIXOTRON.gpuProfiler=this.pt&&new PIXOTRON.GPUProfiler(this.ft),this.punctualLights=[],this.areaLights=[],this.jitterIndex=0}rt(e,t,i){const a=e.getDrawingBufferSize().width,r=e.getDrawingBufferSize().height,s=this.F[this.jitterIndex%this.F.length];PIXOTRON.jitterCamera(i,s,a,r),this.H.render(e,t,i),this._.render(e,i,this.H,this.M),this.I.render(e,t,i),this.enableGI&&this.tt.render(e,t,i,this.q,this.areaLights[0]),i.clearViewOffset(),!this.G.renderTarget1.depthTexture&&this.H.Et&&(this.G.renderTarget1.depthTexture=this.H.Et,this.G.renderTarget2.depthTexture=this.H.Et)}lt(e,t){if(this.V&&this.$&&this.$[0]){const i=1===this.jitterIndex||this.wt();this.V.needsUpdate=i,!i&&this.V.isConverged()||this.V.render(this.renderer,e,t,this.$)}this.Rt=this.$}wt(){if(!this.Rt)return!0;if(this.$===this.Rt)return!1;if(null===this.$||null===this.Rt)return!1;if(this.$.length!==this.Rt.length)return!0;for(let e=0;e<this.$.length;++e)if(this.Rt[e]&&this.$[e].id!==this.Rt[e].id)return!0;return!1}et(){this._.needsUpdate=!!this.autoSAOClear,this.I.needsUpdate=!!this.autoShadowsClear,this.X.needsUpdate=!0,this.V&&(this.V.needsUpdate=!0),this.enableGI&&(this.tt.needsUpdate=!0),this.renderCompleteCallbackCalled=!1}}},function(e,t,i){i(6),e.exports=PIXOTRON.TextureAreaLightFilter=class{constructor(e){this.Tt=e,PIXOTRON.isPowerOfTwo(this.Tt.image)||(this.Tt.image=PIXOTRON.makePowerOfTwo(this.Tt.image));const t={format:THREE.RGBAFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter,type:this.Tt.type,generateMipmaps:!1,anisotropy:this.Tt.anisotropy,encoding:this.Tt.encoding},i={x:e.image.width,y:e.image.height},a=Math.max(i.x,i.y);this.xt=Math.log(a)/Math.log(2)+1,this.Dt=[],this.Nt=[],this.Ot=[],this.Ot.push(.1);for(let e=0;e<this.xt;e++){let a=new THREE.WebGLRenderTarget(i.x,i.y,t);this.Dt.push(a),a=new THREE.WebGLRenderTarget(i.x,i.y,t),this.Nt.push(a),i.x=Math.ceil(i.x/2),i.y=Math.ceil(i.y/2),e<2&&this.Ot.push(1),e<5&&this.Ot.push(2),e>5&&this.Ot.push(3)}const r=PIXOTRON.AreaLightTextureFilterShader;this.gt=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,defines:{NUM_SAMPLES:16}})}update(e){let t=this.Tt;const i=new THREE.DataTexture(null,this.Tt.image.width,this.Tt.image.height);i.minFilter=THREE.LinearMipMapLinearFilter;for(let a=0;a<this.xt;a++){this.gt.uniforms.filterRadius.value=this.Ot[a],this.gt.uniforms.texSize.value.set(this.Dt[a].width,this.Dt[a].height),this.gt.uniforms.direction.value.set(1,0),this.gt.uniforms.colorTexture.value=t,PIXOTRON.renderPass(e,this.gt,this.Dt[a],!0),this.gt.uniforms.direction.value.set(0,1),this.gt.uniforms.colorTexture.value=this.Dt[a].texture,PIXOTRON.renderPass(e,this.gt,this.Nt[a],!0),t=this.Nt[a];const r=new Uint8Array(4*t.width*t.height);e.setRenderTarget(t),e.readRenderTargetPixels(t,0,0,t.width,t.height,r),i.mipmaps[a]={data:r,width:t.width,height:t.height}}return i.generateMipmaps=!1,i.needsUpdate=!0,this.Pt(),i}Pt(){for(let e=0;e<this.xt;e++)this.Dt[e].dispose(),this.Dt[e]=null,this.Nt[e].dispose(),this.Nt[e]=null}}},function(e,t){e.exports=PIXOTRON.AreaLightTextureFilterShader={uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)},filterRadius:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D colorTexture;","uniform float filterRadius;","uniform vec2 texSize;","uniform vec2 direction;","void main() {","float INV_NUM_SAMPLES = 1.0/float(NUM_SAMPLES - 1);","vec2 delta = direction * filterRadius * INV_NUM_SAMPLES/ texSize;","float fSigma = filterRadius;","float weightSum = 1.;","vec4 colorSum = texture2D( colorTexture, vUv) * weightSum;","for( int i = 1; i < NUM_SAMPLES; i ++ ) {","float x = float(i);","vec2 uvOffset = delta * x;","vec2 vUv1 = vUv + uvOffset;","float w = 1.;","if( vUv1.x < 0.0 || vUv1.x > 1.0 || vUv1.y < 0.0 || vUv1.y > 1.0 ) {","w = 0.0;","}","colorSum += texture2D( colorTexture, vUv1) * w;","weightSum += w;","vec2 vUv2 = vUv - uvOffset;","w = 1.;","if( vUv2.x < 0.0 || vUv2.x > 1.0 || vUv2.y < 0.0 || vUv2.y > 1.0 ) {","w = 0.0;","}","colorSum += texture2D( colorTexture, vUv2) * w;","weightSum += w;","}","gl_FragColor = vec4(colorSum/weightSum);","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.BVHManager=class{constructor(){this.meshes=[]}buildBVHTree(e){let t=null;e.geometry.index&&(t=e.geometry.index.array);let a=e.geometry.attributes.position.array,c=e.geometry.attributes.uv?e.geometry.attributes.uv.array:void 0;if(t){const e=new Float32Array(3*t.length);for(let i=0;i<t.length;i++){const r=3*t[i];e[3*i]=a[r],e[3*i+1]=a[r+1],e[3*i+2]=a[r+2]}if(a=e,c){const e=new Float32Array(2*t.length);for(let i=0;i<t.length;i++){const a=2*t[i];e[2*i]=c[a],e[2*i+1]=c[a+1]}c=e}}return new class{constructor(e,t,a){this.positions=e,this.uvs=t,this._maxTrianglesPerNode=a||10,this._bboxArray=function(e){let t,i,a,r,s,o,n,h,u,c,d,m,v,f,p;const x=e.length/9,g=new Float32Array(7*x);for(let w=0;w<x;w++)t=e[9*w],i=e[9*w+1],a=e[9*w+2],r=e[9*w+3],s=e[9*w+4],o=e[9*w+5],n=e[9*w+6],h=e[9*w+7],u=e[9*w+8],l(g,w,w,c=Math.min(Math.min(t,r),n),d=Math.min(Math.min(i,s),h),m=Math.min(Math.min(a,o),u),v=Math.max(Math.max(t,r),n),f=Math.max(Math.max(i,s),h),p=Math.max(Math.max(a,o),u));return g}(e),this._bboxHelper=new Float32Array(this._bboxArray.length),this._bboxHelper.set(this._bboxArray);const r=e.length/9,s=this.calcExtents(0,r,i);for(this._rootNode=new u(s[0],s[1],0,r,0),this._nodesToSplit=[this._rootNode];this._nodesToSplit.length>0;){const e=this._nodesToSplit.pop();this.splitNode(e)}}calcExtents(e,t,i){if(i=i||0,e>=t)return[{x:0,y:0,z:0},{x:0,y:0,z:0}];let a=Number.MAX_VALUE,r=Number.MAX_VALUE,s=Number.MAX_VALUE,o=-Number.MAX_VALUE,n=-Number.MAX_VALUE,h=-Number.MAX_VALUE;for(let i=e;i<t;i++)a=Math.min(this._bboxArray[7*i+1],a),r=Math.min(this._bboxArray[7*i+2],r),s=Math.min(this._bboxArray[7*i+3],s),o=Math.max(this._bboxArray[7*i+4],o),n=Math.max(this._bboxArray[7*i+5],n),h=Math.max(this._bboxArray[7*i+6],h);return[{x:a-i,y:r-i,z:s-i},{x:o+i,y:n+i,z:h+i}]}splitNode(e){if(e.elementCount()<=this._maxTrianglesPerNode||0===e.elementCount())return;const t=e._startIndex,a=e._endIndex,r=[[],[],[]],s=[[],[],[]],o=[e.centerX(),e.centerY(),e.centerZ()],n=[e._extentsMax.x-e._extentsMin.x,e._extentsMax.y-e._extentsMin.y,e._extentsMax.z-e._extentsMin.z],l=[];l.length=3;for(let e=t;e<a;e++){l[0]=.5*(this._bboxArray[7*e+1]+this._bboxArray[7*e+4]),l[1]=.5*(this._bboxArray[7*e+2]+this._bboxArray[7*e+5]),l[2]=.5*(this._bboxArray[7*e+3]+this._bboxArray[7*e+6]);for(let t=0;t<3;t++)l[t]<o[t]?r[t].push(e):s[t].push(e)}const c=[];if(c.length=3,c[0]=0===r[0].length||0===s[0].length,c[1]=0===r[1].length||0===s[1].length,c[2]=0===r[2].length||0===s[2].length,c[0]&&c[1]&&c[2])return;const d=[0,1,2];let m,v;d.sort(function(e,t){return n[t]-n[e]});for(let e=0;e<3;e++){const t=d[e];if(!c[t]){m=r[t],v=s[t];break}}const f=t,p=f+m.length,x=p,g=a;let w,T=e._startIndex;const E=m.concat(v);for(let e=0;e<E.length;e++)w=E[e],h(this._bboxArray,w,this._bboxHelper,T),T++;const R=this._bboxHelper.subarray(7*e._startIndex,7*e._endIndex);this._bboxArray.set(R,7*e._startIndex);const D=this.calcExtents(f,p,i),P=this.calcExtents(x,g,i),S=new u(D[0],D[1],f,p,e._level+1),N=new u(P[0],P[1],x,g,e._level+1);e._node0=S,e._node1=N,e.clearShapes(),this._nodesToSplit.push(S),this._nodesToSplit.push(N)}intersectRay(e,t,i){const a=[this._rootNode],h=[],l=[];let u;const c=new THREE.Vector3(1/t.x,1/t.y,1/t.z);for(;a.length>0;){const t=a.pop();if(s(e,c,t))for(t._node0&&a.push(t._node0),t._node1&&a.push(t._node1),u=t._startIndex;u<t._endIndex;u++)h.push(this._bboxArray[7*u])}const d=new THREE.Vector3,m=new THREE.Vector3,v=new THREE.Vector3,f=new THREE.Vector2,p=new THREE.Vector2,x=new THREE.Vector2,g=new THREE.Vector3,w=new THREE.Vector3,T=new THREE.Vector2,E=new THREE.Vector3(e.x,e.y,e.z),R=new THREE.Vector3(t.x,t.y,t.z);for(u=0;u<h.length;u++){const e=h[u];d.fromArray(this.positions,9*e),m.fromArray(this.positions,9*e+3),v.fromArray(this.positions,9*e+6);const t=r(d,m,v,E,R,i);t&&(this.uvs&&(f.fromArray(this.uvs,6*e),p.fromArray(this.uvs,6*e+2),x.fromArray(this.uvs,6*e+4),o(t,d,m,v,f,p,x,g,T)),n(d,m,v,w),l.push({point:t,uv:T,face:{index:e,a:d.clone(),b:m.clone(),c:v.clone(),normal:w}}))}return l}}(a,c,7)}add(e){this.meshes[e.uuid]||(this.meshes.push({id:e.uuid,val:e}),e.bvh=this.buildBVHTree(e))}intersectRay(e){const t=new THREE.Ray,i=new THREE.Matrix4;let a=[];for(let r=0;r<this.meshes.length;r++){const s=this.meshes[r].val;t.origin.copy(e.origin),t.direction.copy(e.direction),i.getInverse(s.matrixWorld),t.origin.applyMatrix4(i),t.direction.transformDirection(i);const o=s.bvh.intersectRay(t.origin,t.direction,!0);o.length>0&&o.forEach(function(t){t.object=s,t.point.applyMatrix4(s.matrixWorld),t.distance=e.origin.distanceToSquared(t.point)}),a=a.concat(o)}return a.sort(function(e,t){return e.distance>t.distance}),a}};const i=1e-6;function a(e,t,i,a){const r={min:0,max:0};return a>=0?(r.min=(e-i)*a,r.max=(t-i)*a):(r.min=(t-i)*a,r.max=(e-i)*a),r}const r=function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Vector3;return function(r,s,o,n,h,l){t.subVectors(s,r),i.subVectors(o,r),a.crossVectors(t,i);let u,c=h.dot(a);if(c>0){if(l)return null;u=1}else{if(!(c<0))return null;u=-1,c=-c}e.subVectors(n,r);const d=u*h.dot(i.crossVectors(e,i));if(d<0)return null;const m=u*h.dot(t.cross(e));if(m<0)return null;if(d+m>c)return null;const v=-u*e.dot(a);if(v<0)return null;const f=v/c;return(new THREE.Vector3).copy(h).multiplyScalar(f).add(n)}}();function s(e,t,i){const r=a(i._extentsMin.x,i._extentsMax.x,e.x,t.x),s=a(i._extentsMin.y,i._extentsMax.y,e.y,t.y);if(r.min>s.max||s.min>r.max)return!1;(s.min>r.min||r.min!=r.min)&&(r.min=s.min),(s.max<r.max||r.max!=r.max)&&(r.max=s.max);const o=a(i._extentsMin.z,i._extentsMax.z,e.z,t.z);return!(r.min>o.max||o.min>r.max||((o.min>r.min||r.min!=r.min)&&(r.min=o.min),(o.max<r.max||r.max!=r.max)&&(r.max=o.max),r.max<0))}function o(e,t,i,a,r,s,o,n,h){return THREE.Triangle.getBarycoord(e,t,i,a,n),r.multiplyScalar(n.x),s.multiplyScalar(n.y),o.multiplyScalar(n.z),r.add(s).add(o),h.copy(r),h}function n(e,t,i,a){const r=a||new THREE.Vector3,s=new THREE.Vector3;r.subVectors(i,t),s.subVectors(e,t),r.cross(s);const o=r.lengthSq();return o>0?r.multiplyScalar(1/Math.sqrt(o)):r.set(0,0,0)}function h(e,t,i,a){i[7*a]=e[7*t],i[7*a+1]=e[7*t+1],i[7*a+2]=e[7*t+2],i[7*a+3]=e[7*t+3],i[7*a+4]=e[7*t+4],i[7*a+5]=e[7*t+5],i[7*a+6]=e[7*t+6]}function l(e,t,i,a,r,s,o,n,h){e[7*t]=i,e[7*t+1]=a,e[7*t+2]=r,e[7*t+3]=s,e[7*t+4]=o,e[7*t+5]=n,e[7*t+6]=h}class u{constructor(e,t,i,a,r){this._extentsMin=e,this._extentsMax=t,this._startIndex=i,this._endIndex=a,this._level=r,this._node0=null,this._node1=null}elementCount(){return this._endIndex-this._startIndex}centerX(){return.5*(this._extentsMin.x+this._extentsMax.x)}centerY(){return.5*(this._extentsMin.y+this._extentsMax.y)}centerZ(){return.5*(this._extentsMin.z+this._extentsMax.z)}clearShapes(){this._startIndex=-1,this._endIndex=-1}}},function(e,t){PIXOTRON.queryId=-1,e.exports=PIXOTRON.GPUProfiler=class{constructor(e){this.ft=e,this.pt=this.ft.getExtension("EXT_disjoint_timer_query"),this.queryPool={},this.pt||console.warn("GPUProfiler::EXT_disjoint_timer_query not supported!")}start(e){const t=this.popAvailableQuery(e);return this.pt&&t&&t.start(this.pt),t.id}result(e){let t;const i=this.queryPool[e];if(i)return this.end(i),this.available(i)&&(t=this.value(i)),t}end(e){this.pt&&e&&e.end(this.pt)}available(e){if(this.pt)return this.pt.getQueryObjectEXT(e.St,this.pt.QUERY_RESULT_AVAILABLE_EXT)}value(e){if(this.pt){let t;return this.ft.getParameter(this.pt.GPU_DISJOINT_EXT)||(t=1e-6*this.pt.getQueryObjectEXT(e.St,this.pt.QUERY_RESULT_EXT),e.dirty=!1),t}}Mt(e){let t=this.queryPool[e];return t||(t=new class{constructor(e){this.dirty=!1,this.id=++PIXOTRON.queryId,this.St=e.createQueryEXT()}start(e){this.dirty||e.beginQueryEXT(e.TIME_ELAPSED_EXT,this.St)}end(e){this.dirty||e.endQueryEXT(e.TIME_ELAPSED_EXT),this.dirty=!0}}(this.pt),this.queryPool[t.id]=t),t}}},function(e,t,i){i(10),e.exports=PIXOTRON.GBufferPass=class{constructor(e){e=e||{},this.forceDepthAndNormalPass=void 0===e.forceDepthAndNormalPass||e.forceDepthAndNormalPass,this.packingMode=void 0!==e.packingMode?e.packingMode:PIXOTRON.GBufferPass.DEPTH_NORMAL_16,this.Ht=new THREE.MeshNormalMaterial,this.Ct=new THREE.ShaderMaterial(PIXOTRON.PackingShader_DepthNormal16),this.yt=void 0===e.linearDepth||e.linearDepth,this.yt?(this._t=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.forceDepthAndNormalPass=!0):(this._t=new THREE.MeshDepthMaterial,this._t.depthPacking=THREE.RGBADepthPacking),this.debug=!1,this.j=0}dispose(){this.It&&this.It.dispose(),this.zt&&this.zt.dispose(),this.At&&this.At.dispose(),this.Ht.dispose(),this.Ct.dispose(),this._t.dispose()}getTotalRenderTime(){return this.j}setSize(e,t){this.It&&this.It.setSize(e,t),this.zt&&this.zt.setSize(e,t),this.At&&this.At.setSize(e,t)}render(e,t,i){this.Xt||this.S(e);const a=e.getClearColor(),r=e.getClearAlpha(),s=e.autoClear,o=e.shadowMap.enabled;e.shadowMap.enabled=!1,e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.Ft(e,t,i),e.autoClear=s,e.shadowMap.enabled=o,e.setClearColor(a,r)}S(e){const t=e.extensions.get("WEBGL_depth_texture"),i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height;if(!this.forceDepthAndNormalPass&&t&&!this.At){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.At=new THREE.WebGLRenderTarget(i,a,e),this.Et||(this.Et=new THREE.DepthTexture,this.Et.type=THREE.UnsignedShortType),this.At.depthTexture=this.Et}if(!t||this.forceDepthAndNormalPass){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.packingMode===PIXOTRON.GBufferPass.NONE&&(this.zt||(this.zt=new THREE.WebGLRenderTarget(i,a,e),this.zt.depthTexture=this.Et),this.At||(this.At=new THREE.WebGLRenderTarget(i,a,e),this.At.depthTexture=this.Et)),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(this.It||(this.It=new THREE.WebGLRenderTarget(i,a,e),this.It.depthTexture=this.Et))}this.Xt=!0}Ft(e,t,i){t.traverse(function(e){if(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints){let t=e.material&&e.material.transparent||e.castAO;(t=(t=e.material&&e.material.transparent&&!e.material.isShadowMaterial||!!e.castAO)||e.material.alphaTest>0)&&(e.aoVisibility=e.visible,e.visible=!1)}}),this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.j=0;const a=e.extensions.get("WEBGL_depth_texture");a&&!this.forceDepthAndNormalPass&&(t.overrideMaterial=this.Ht,e.render(t,i,this.At,!0),t.overrideMaterial=null),a&&!this.forceDepthAndNormalPass||(this.packingMode===PIXOTRON.GBufferPass.NONE&&(t.overrideMaterial=this.Ht,e.render(t,i,this.At,!0),t.overrideMaterial=null,t.overrideMaterial=this._t,this._t.isMeshDepthMaterial||(this._t.uniforms.cameraNearFar.value.x=i.near,this._t.uniforms.cameraNearFar.value.y=i.far),e.render(t,i,this.zt,!0),t.overrideMaterial=null),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(t.overrideMaterial=this.Ct,this.Ct.uniforms.cameraNearFar.value.x=i.near,this.Ct.uniforms.cameraNearFar.value.y=i.far,e.render(t,i,this.It,!0),t.overrideMaterial=null));const r=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"GBuffer Pass"});r&&(this.j+=r),t.traverse(function(e){e.aoVisibility&&(e.visible=e.aoVisibility,e.aoVisibility=void 0)})}},PIXOTRON.GBufferPass.NONE=0,PIXOTRON.GBufferPass.DEPTH_NORMAL_16=1},function(e,t){e.exports=PIXOTRON.PackingShader_DepthNormal16={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewNormal;      varying vec3 viewPosition;      void main() {        viewNormal = normalMatrix * normal;        viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      }",fragmentShader:"varying vec3 viewNormal;    uniform vec2 cameraNearFar;    varying vec3 viewPosition;      vec2 pack16(float value){          float sMax = 65535.0;          int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);          int digit0 = v/256;          int digit1 = v-digit0*256;          return vec2(float(digit0)/255.0, float(digit1)/255.0);      }            vec2 packNormal(vec3 n){          float p = sqrt(n.z*8.0+8.0);          return vec2(n.xy/p + 0.5);      }            float linstep(float edge0, float edge1, float value){        return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);      }            void main() {        float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);        vec2 packedZ = pack16(pow(linearZ, 0.5));        vec2 packedNormal = packNormal(normalize(viewNormal));        gl_FragColor = vec4(packedZ.x, packedZ.y, packedNormal.x, packedNormal.y);      }"},e.exports=PIXOTRON.PackingShader_Depth32={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewPosition;    void main() {      viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"#include <packing>  uniform vec2 cameraNearFar;  varying vec3 viewPosition;    float linstep(float edge0, float edge1, float value){      return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);    }        void main() {      float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);      vec4 packedZ = packDepthToRGBA(pow(linearZ, 0.5));      gl_FragColor = packedZ;    }"}},function(e,t,i){i(0),i(12),i(1),e.exports=PIXOTRON.AccumulativeSAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.bias=void 0!==e.bias?e.bias:.001,this.numSamples=void 0!==e.numSamples?e.numSamples:600,this.Vt=void 0!==e.samplesPerFrame?e.samplesPerFrame:4,this.Ut=void 0!==e.downscaleLevel?e.downscaleLevel:1,this.Ut=this.Ut<1?1:this.Ut,this.blurEnabled=!0,this.edgeSharpness=10,this.debug=!1,this.enabled=!0,this.needsUpdate=!0,this.bt=0,this.Lt(this.numSamples),this.Bt=new THREE.ShaderMaterial(PIXOTRON.AccumulativeSAOShader),this.Bt.uniforms=THREE.UniformsUtils.clone(this.Bt.uniforms),this.Bt.defines.SAMPLES_PER_FRAME=this.Vt,this.kt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionAOShader),this.N=0,this.Wt=[],this.j=0}convergenceMetric(){return this.enabled?this.N*this.Vt/(this.jt-1):1}dispose(){this.Zt&&(this.Zt.dispose(),this.Gt.dispose(),this.Bt.dispose(),this.kt.dispose())}getTotalRenderTime(){return this.j}render(e,t,i,a){if(this.needsUpdate&&(this.N=0,this.needsUpdate=!1),this.convergenceMetric()>=1)return;this.N++,this.N=Math.min(this.N,this.jt-1),this.Zt||this.S(e),this.Lt(this.numSamples),this.qt(this.N-1);const r=e.getClearColor(),s=e.getClearAlpha(),o=e.autoClear;e.autoClear=!1;const n=e.getDrawingBufferSize().width/this.Ut,h=e.getDrawingBufferSize().height/this.Ut;this.Bt.uniforms.size.value.set(n,h),this.Kt(n,h),this.Jt(t,i);const l=this.N%2==0?this.Gt:this.Zt,u=this.N%2==0?this.Zt:this.Gt;this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.j=0,this.Qt(e,l,u);const c=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"Acc SAO Render"});if(c&&(this.j+=c),this.blurEnabled&&this.convergenceMetric()>.9){this.blurQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.blurQueryId),a.edgeSharpness=this.edgeSharpness,a.render(e,u,t,i);const r=this.debug&&PIXOTRON.endPerformanceTest(this.blurQueryId,{callback:this.debugCallback,name:"Acc SAO Blur"});r&&(this.j+=r)}this.Yt(e,l,u),e.autoClear=o,e.setClearColor(r),e.setClearAlpha(s),e.saoBuffer=this.smoothTransition?l:u}setDownscaleLevel(e){this.Ut=e||1,this.Ut=this.Ut<1?1:this.Ut,this.needsUpdate=!0}setSize(e,t){this.Gt&&this.Gt.setSize(e,t),this.Zt&&this.Zt.setSize(e,t),this.Bt.uniforms.size.value.set(e,t)}S(e){const t=e.getDrawingBufferSize().width/this.Ut,i=e.getDrawingBufferSize().height/this.Ut;if(!this.Zt){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.Zt=new THREE.WebGLRenderTarget(t,i,e),this.Gt=new THREE.WebGLRenderTarget(t,i,e)}}Qt(e,t,i){this.Bt.uniforms.tAOSumPrevious.value=t,PIXOTRON.renderPass(e,this.Bt,i)}Yt(e,t,i){if(this.smoothTransition){this.kt.uniforms.saoAccumulationBuffer.value=i,this.kt.uniforms.transition.value=this.convergenceMetric(),this.transitionQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.transitionQueryId),PIXOTRON.renderPass(e,this.kt,t);const a=this.debug&&PIXOTRON.endPerformanceTest(this.transitionQueryId,{callback:this.debugCallback,name:"Acc SAO Transition"});a&&(this.j+=a)}}Kt(e,t){(this.Zt.width!==e||this.Zt.height!==t)&&this.Zt.setSize(e,t)}Jt(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),a=this.Bt.uniforms.saoData.value;a.x=i,a.y=this.intensity,a.z=this.occlusionWorldRadius,a.w=this.N;const r=this.Bt.uniforms.saoBiasEpsilon.value;r.x=this.bias,r.y=.001;const s=this.Bt.uniforms.cameraNearFar.value;let o;s.x=e.near,s.y=e.far,this.Bt.uniforms.ProjectionMatrix.value=e.projectionMatrix,o=t.Et?t.Et:t.zt?t.zt.texture:null;const n=t.At?t.At.texture:null;let h;t.zt||(h=t.It?t.It.texture:null);let l=t.Et?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(l=2),this.Bt.defines.DEPTH_PACKING_MODE=l,this.Bt.defines.DEPTH_NORMAL_TEXTURE=h?1:0,this.Bt.defines.LINEAR_DEPTH=t.yt?1:0,this.Bt.uniforms.quasiRandomSamples.value=this.Wt,h?this.Bt.uniforms.tNormalDepth.value=h:(this.Bt.uniforms.tNormal.value=n,this.Bt.uniforms.tDepth.value=o)}qt(e){let t=this.Vt*e,i=0;for(i=0;i<this.Vt;i++)this.Wt[i]=this.$t[t++],void 0===this.Wt[i]&&(this.Wt[i]=this.$t[t%this.Vt])}Lt(e){e!==this.bt&&(this.bt=e,this.$t=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.lerpDistribution,PIXOTRON.insideCircle),this.$t=PIXOTRON.randomizeArray(this.$t),this.jt=this.$t.length)}}},function(e,t){e.exports=PIXOTRON.AccumulativeSAOShader={blending:THREE.NoBlending,defines:{SAMPLES_PER_FRAME:4,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1},uniforms:{tAOSumPrevious:{type:"t",value:null},tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},quasiRandomSamples:{type:"v2v",value:null},saoBiasEpsilon:{type:"v2",value:new THREE.Vector2},size:{type:"v2",value:new THREE.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tAOSumPrevious;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec4 saoBiasEpsilon;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform vec2 quasiRandomSamples[SAMPLES_PER_FRAME];","const float f_sampleCount = float( SAMPLES_PER_FRAME );","#include <utilshader>","float getViewDepth( const in float ndcDepth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float getOcclusionFromPositionNormal( const in vec3 centerPosition, const in vec3 centerNormal, const in vec3 samplePosition ) {","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","return max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( d2 + saoBiasEpsilon.y ), 0.0 );","}","vec4 getOcclusion( const in vec3 centerPosition ) {","vec3 centerNormal = getViewNormal( vUv );","float screenOcclusionRadius = 200. * saoData.z * saoData.x / -centerPosition.z;","if( screenOcclusionRadius < 1. ) {","discard;","}","float random = rand( vUv );","float randomAngle = random * PI2 + 2. * PI2 * (saoData.w - 1.0);","float cosAngle = cos(randomAngle); float sinAngle = sin(randomAngle);","mat2 randomRotationMatrix = mat2(cosAngle, sinAngle, -sinAngle, cosAngle);","float occlusionSum = 0.0;","for( int i = 0; i < SAMPLES_PER_FRAME; i ++ ) {","vec2 randomSample = randomRotationMatrix * (quasiRandomSamples[i] - vec2(0.5)) * screenOcclusionRadius/size;","vec2 sampleUv = vUv + randomSample;","float sampleDepthNDC = decodeDepth( sampleUv );","if( sampleDepthNDC >= ( 1.0 - EPSILON ) ) {","continue;","}","#if LINEAR_DEPTH == 0","float sampleViewDepth = getViewDepth( sampleDepthNDC );","vec3 samplePosition = getViewPositionFromViewZ( sampleUv, sampleViewDepth );","#else","sampleDepthNDC = mix(-cameraNearFar.x, -cameraNearFar.y, sampleDepthNDC);","vec3 samplePosition = getViewPositionFromViewZ(sampleUv, sampleDepthNDC);","#endif","float occlusion = getOcclusionFromPositionNormal( centerPosition, centerNormal, samplePosition );","occlusionSum += occlusion;","}","float occlusion = occlusionSum * saoData.y * 2.0 / f_sampleCount;","return vec4(clamp(occlusion,0., 1.));","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewDepth = getViewDepth( centerDepth );","#else","float centerViewDepth = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 viewPosition = getViewPositionFromViewZ(vUv, centerViewDepth);","float occlusion = getOcclusion( viewPosition ).r;","float prevOcclusionSum = texture2D(tAOSumPrevious, vUv).r;","float finalOcclusion = mix(prevOcclusionSum, occlusion, 1./saoData.w);","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = clamp(finalOcclusion, 0., 1.);","}"].join("\n")}},function(e,t,i){i(0),i(14),e.exports=PIXOTRON.SAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.bias=void 0!==e.bias?e.bias:.001,this.Ut=void 0!==e.downscaleLevel?e.downscaleLevel:1,this.Ut=this.Ut<1?1:this.Ut,this.blurEnabled=!0,this.edgeSharpness=1,this.debug=!1,this.enabled=!0,this.needsUpdate=!0,this.te=new THREE.ShaderMaterial(PIXOTRON.SAOShader),this.te.uniforms=THREE.UniformsUtils.clone(this.te.uniforms),this.te.defines=Object.assign({},this.te.defines),this.N=0,this.j=0}dispose(){this.Zt&&(this.Zt.dispose(),this.Zt=null,this.te.dispose())}getTotalRenderTime(){return this.j}setDownscaleLevel(e){this.Ut=e||1,this.Ut=this.Ut<1?1:this.Ut,this.needsUpdate=!0}setSize(e,t){this.Zt&&this.Zt.setSize(e,t),this.te.uniforms.size.value.set(e,t)}convergenceMetric(){return this.enabled?this.N>1?1:0:1}render(e,t,i,a){this.needsUpdate&&(this.N=0,this.needsUpdate=!1),this.Zt||this.S(e);const r=e.getDrawingBufferSize().width/this.Ut,s=e.getDrawingBufferSize().height/this.Ut;this.te.uniforms.size.value.set(r,s),this.Kt(r,s),this.Jt(t,i);const o=e.getClearColor(),n=e.getClearAlpha(),h=e.autoClear;e.autoClear=!1,this.j=0,this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),PIXOTRON.renderPass(e,this.te,this.Zt);const l=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"SAO Render"});if(l&&(this.j+=l),this.blurEnabled){this.blurQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.blurQueryId),a.edgeSharpness=this.edgeSharpness,a.render(e,this.Zt,t,i);const r=this.debug&&PIXOTRON.endPerformanceTest(this.blurQueryId,{callback:this.debugCallback,name:"SAO Blur"});r&&(this.j+=r)}e.autoClear=h,e.setClearColor(o),e.setClearAlpha(n),e.saoBuffer=this.Zt}S(e){const t=e.getDrawingBufferSize().width/this.Ut,i=e.getDrawingBufferSize().height/this.Ut;if(!this.Zt){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.Zt=new THREE.WebGLRenderTarget(t,i,e)}}Kt(e,t){(this.Zt.width!==e||this.Zt.height!==t)&&this.Zt.setSize(e,t)}Jt(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),a=this.te.uniforms.saoData.value;a.x=i,a.y=this.intensity,a.z=this.occlusionWorldRadius,a.w=this.N++;const r=this.te.uniforms.saoBiasEpsilon.value;r.x=this.bias,r.y=.001;const s=this.te.uniforms.cameraNearFar.value;let o;s.x=e.near,s.y=e.far,this.te.uniforms.ProjectionMatrix.value=e.projectionMatrix,o=t.Et?t.Et:t.zt?t.zt.texture:null;const n=t.At?t.At.texture:null;let h;t.zt||(h=t.It?t.It.texture:null);let l=t.Et?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(l=2),this.te.defines.DEPTH_PACKING_MODE=l,this.te.defines.DEPTH_NORMAL_TEXTURE=h?1:0,this.te.defines.LINEAR_DEPTH=t.yt?1:0,h?this.te.uniforms.tNormalDepth.value=h:(this.te.uniforms.tNormal.value=n,this.te.uniforms.tDepth.value=o)}}},function(e,t){e.exports=PIXOTRON.SAOShader={defines:{NUM_SAMPLES:11,NUM_SPIRAL_TURNS:3,DEPTH_NORMAL_TEXTURE:0,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},size:{type:"v2",value:new THREE.Vector2(512,512)},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},saoBiasEpsilon:{type:"v2",value:new THREE.Vector2}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform vec2 cameraNearFar;","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec2 saoBiasEpsilon;","uniform vec2 size;","#include <utilshader>","const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );","float getViewZFromNDCZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float random3(vec3 v) { ","v  = fract(v * 443.8975);","v += dot(v, v.yzx + 19.19);","return fract((v.x + v.y) * v.z);","}","vec3 getPositionFromOffset(const in vec2 uv, const in vec2 offset, const in float screenSpaceRadius) {","vec2 uvOffset = uv + floor(screenSpaceRadius * offset)/size;","float d = decodeDepth(uvOffset);","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( d );","return getViewPositionFromViewZ( uvOffset, centerViewZ );","#else","d = mix(-cameraNearFar.x, -cameraNearFar.y, d);","return getViewPositionFromViewZ(uvOffset, d);","#endif","}","float getOcclusion(const in vec2 uv, const in int id, const in float randomAngle, const in float occlusionSphereRadius, const in vec3 centerPosition, const in vec3 centerNormal) {","float screenSpaceRadius = (float(id) + mod(randomAngle, 1.) + 0.5) * INV_NUM_SAMPLES; ","float angle = screenSpaceRadius * (float(NUM_SPIRAL_TURNS) * 6.28) + randomAngle; ","screenSpaceRadius = (screenSpaceRadius * occlusionSphereRadius);","vec2 offset = vec2(cos(angle), sin(angle));","vec3 samplePosition = getPositionFromOffset(uv, offset, screenSpaceRadius);","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","float ao = max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( d2 + saoBiasEpsilon.y ), 0.0 );","return ao;","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( centerDepth );","#else","float centerViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 centerPosition = getViewPositionFromViewZ( vUv, centerViewZ );","vec3 centerNormal = getViewNormal(vUv);","float occlusionSphereScreenRadius = 200. * saoData.z/ (-centerPosition.z);","if( occlusionSphereScreenRadius < 1. ) {","discard;","}","float randomAngle = 6.2 * random3( vec3( vUv, saoData.w * 0.1 ) );","float sum = 0.0;","sum += getOcclusion(vUv, 0, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 1, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 2, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 3, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 4, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 5, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 6, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 7, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 8, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 9, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 10, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","float aoValue = sum * saoData.y * INV_NUM_SAMPLES;","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = max( aoValue, 0.0 );","}"].join("\n")}},function(e,t,i){function a(e,t){e.traverse(function(e){(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints)&&((t?e.castShadow:e.receiveShadow)||(e.oldVisibility=e.visible,e.visible=!1))})}function r(e){e.traverse(function(e){e.oldVisibility&&(e.visible=e.oldVisibility,e.oldVisibility=void 0)})}i(0),i(1),i(16),e.exports=PIXOTRON.ShadowPass=class{constructor(e){e=e||{},this.linearDepth=void 0!==e.linearDepth?e.linearDepth:1,this.shadowMapResolution=void 0!==e.shadowMapResolution?e.shadowMapResolution:1024,this.shadowRadius=void 0!==e.shadowRadius?e.shadowRadius:1,this.shadowQuality=void 0!==e.shadowQuality?e.shadowQuality:1,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.shadowBiasMultiplier=void 0!==e.shadowBiasMultiplier?e.shadowBiasMultiplier:1,this.numSamples=void 0!==e.numSamples?e.numSamples:100,this.side=void 0!==e.side?e.side:THREE.FrontSide,this.Ut=void 0!==e.downscaleLevel?e.downscaleLevel:1,this.Ut=this.Ut<1?1:this.Ut;const t=void 0!==e.nearPlane?e.nearPlane:.1,i=void 0!==e.farPlane?e.farPlane:10,a=void 0!==e.fov?e.fov:110;this.ee=new THREE.PerspectiveCamera(a,1,t,i),this.bt=0,this.ie(this.numSamples),this.N=0,this.se=0,this.oe=new THREE.Vector3,this.ae=new THREE.Vector3(0,-1,0),this.re=new THREE.Vector3,this.ne=new THREE.Matrix4,this.lights=[],this.enabled=!0,this.enableAccumulation=!0,this.needsUpdate=!0,this.shadowRecieverBBox=null,this.debug=!1,this.j=0}convergenceMetric(){if(!this.enabled)return 1;let e=0;return this.lights.forEach(t=>{t.castShadow&&e++}),0!==e?this.N/(e*this.he.length):1}dispose(){this.le&&(this.le.dispose(),this.ce.dispose(),this.ue.dispose(),this.de.dispose(),this._t.dispose()),this.ve&&this.ve.dispose(),this.kt&&this.kt.dispose()}getTotalRenderTime(){return this.j}render(e,t,i){if(this.needsUpdate&&(this.N=0,this.se=0,this.needsUpdate=!1,this.lights.forEach(e=>{e.N=0})),!this.enableAccumulation&&this.N>0)return;if(this.convergenceMetric()>=1)return;const a=e.getDrawingBufferSize().width/this.Ut,r=e.getDrawingBufferSize().height/this.Ut;this.le||(this.ee.layers.mask=i.layers.mask,this.me(a,r)),this.fe(a,r),this.ie(this.numSamples);const s=e.getClearColor(),o=e.getClearAlpha(),n=e.autoClear;let h,l;if(this.j=0,this.lights.forEach(a=>{this.N=Math.min(this.N,this.lights.length*this.he.length),this.N++,a.N++,this.se+=a.intensity,this.pe(a),this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.Ee(e,t,this.oe,this.le),h=this.N%2==0?this.ce:this.ue,l=this.N%2==0?this.ue:this.ce,this.we(e,t,i,h,l,a),this.smoothTransition&&this.N===this.lights.length&&PIXOTRON.blit(e,l,this.de);const r=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"Shadow Pass"});r&&(this.j+=r)}),this.smoothTransition){this.smoothTransitionQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.smoothTransitionQueryId),this.kt.uniforms.shadowAccumulationBuffer.value=l,this.kt.uniforms.firstFrameShadowBuffer.value=this.de,this.kt.uniforms.transition.value=this.convergenceMetric(),PIXOTRON.renderPass(e,this.kt,h);const t=this.debug&&PIXOTRON.endPerformanceTest(this.smoothTransitionQueryId,{callback:this.debugCallback,name:"Shadow Transition"});t&&(this.j+=t)}e.autoClear=n,e.setClearColor(s),e.setClearAlpha(o),this.lights.forEach(e=>{e.shadow.map=this.smoothTransition?h:l})}setDownscaleLevel(e){this.Ut=e||1,this.Ut=this.Ut<1?1:this.Ut,this.needsUpdate=!0}setSize(e,t){this.ce&&this.ce.setSize(e,t),this.ue&&this.ue.setSize(e,t),this.le&&this.le.setSize(e,t),this.de&&this.de.setSize(e,t),this.ve&&this.ve.uniforms.shadowBufferSize.value.set(e,t)}fe(e,t){(this.ce.width!==e||this.ce.height!==t)&&(this.ce.setSize(e,t),this.ue.setSize(e,t),this.de.setSize(e,t),this.ve.uniforms.shadowBufferSize.value=new THREE.Vector2(e,t))}me(e,t){const i={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.le=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,i),this.ce=new THREE.WebGLRenderTarget(e,t,i),this.ue=new THREE.WebGLRenderTarget(e,t,i),this.de=new THREE.WebGLRenderTarget(e,t,i),this.le.texture.generateMipmaps=!1,this.ce.texture.generateMipmaps=!1,this.ue.texture.generateMipmaps=!1,this.de.texture.generateMipmaps=!1,this.linearDepth?(this._t=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this._t.uniforms=THREE.UniformsUtils.clone(this._t.uniforms),this._t.side=this.side):this._t=new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking,side:this.side}),this.ve=new THREE.ShaderMaterial(PIXOTRON.AccumulativeShadowsShader),this.ve.uniforms=THREE.UniformsUtils.clone(this.ve.uniforms),this.ve.uniforms.shadowBufferSize.value=new THREE.Vector2(e,t),this.ve.uniforms.shadowMap.value=this.le,this.ve.uniforms.shadowData.value=new THREE.Vector4(0,1,1,1),this.ve.uniforms.shadowMapResolution.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.ve.defines.SHADOW_QUALITY=this.shadowQuality,this.ve.defines.LINEAR_DEPTH=this.linearDepth,this.kt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionShadowShader),this.kt.uniforms=THREE.UniformsUtils.clone(this.kt.uniforms)}we(e,t,i,s,o,n){this.ee.matrixWorldInverse.getInverse(this.ee.matrixWorld),this.ne.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.ne.multiply(this.ee.projectionMatrix),this.ne.multiply(this.ee.matrixWorldInverse),this.ve.uniforms.shadowMatrix.value.copy(this.ne),this.ve.uniforms.shadowData.value.x=this.se,this.ve.uniforms.shadowData.value.y=this.shadowRadius,this.ve.uniforms.shadowData.value.z=this.shadowBiasMultiplier,this.ve.uniforms.shadowData.value.w=n.intensity,this.ve.uniforms.shadowAccumulationBuffer.value=s,this.ve.uniforms.vplPosition.value=this.ee.position,this.ve.uniforms.cameraNearFar.value.x=this.ee.near,this.ve.uniforms.cameraNearFar.value.y=this.ee.far,e.setClearColor(0),a(t,!1);const h=e.shadowMap.enabled;e.shadowMap.enabled=!1,t.overrideMaterial=this.ve,e.render(t,i,o,!0),t.overrideMaterial=null,r(t),e.shadowMap.enabled=h}Ee(e,t,i,s){a(t,!0),this.ee.position.copy(i),this.re.copy(i),this.re.addScaledVector(this.ae,10),this.ee.lookAt(this.re),this.ee.updateMatrixWorld(),t.overrideMaterial=this._t,this.linearDepth&&(this._t.uniforms.cameraNearFar.value.x=this.ee.near,this._t.uniforms.cameraNearFar.value.y=this.ee.far),e.setClearColor(0),e.render(t,this.ee,s,!0),t.overrideMaterial=null,r(t)}pe(e){let t=e.N-1;const i=e.matrixWorld;t%=this.he.length-1;const a=this.he[t];if(this.oe.x=(a.x-.5)*e.width,this.oe.z=0,this.oe.y=(a.y-.5)*e.height,this.oe.applyMatrix4(i),this.ae.set(0,0,-1),this.ae.transformDirection(i),this.shadowRecieverBBox){const e=PIXOTRON.calculateFOV(this.shadowRecieverBBox,this.oe,this.ae);this.setFOV(e)}}setShadowRecieverBBox(e){this.shadowRecieverBBox=e}setFOV(e){this.ee.fov=e,this.ee.updateProjectionMatrix()}ie(e){e!==this.bt&&(this.bt=e,this.he=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.he=PIXOTRON.randomizeArray(this.he),this.he.splice(0,0,new THREE.Vector2(.5,.5)))}}},function(e,t){e.exports=PIXOTRON.AccumulativeShadowsShader={defines:{SHADOW_QUALITY:1,LINEAR_DEPTH:1},uniforms:{shadowMap:{value:null},shadowAccumulationBuffer:{value:null},shadowBufferSize:{value:null},shadowMatrix:{value:new THREE.Matrix4},vplPosition:{value:new THREE.Vector3},shadowData:{value:new THREE.Vector4},cameraNearFar:{value:new THREE.Vector2},shadowMapResolution:{value:null},normalBias:{value:1}},vertexShader:["varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec3 vplPosition;","uniform mat4 shadowMatrix;","uniform float normalBias;","void main() {","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","viewNormal = normalize(normalMatrix * normal);","vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;","lightVector = vplPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;","lightVector = normalize(lightVector);","shadowCoord = shadowMatrix * worldPosition;","float nDotL = clamp( dot(lightVector, viewNormal), 0.0, 1.0);","worldPosition.xyz += normalize((modelMatrix * vec4( normal, 0.0 )).xyz) * 0.02 * normalBias * pow( 1.0 -  nDotL * nDotL, 4.);","shadowCoord.xy = (shadowMatrix * worldPosition).xy;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec2 shadowBufferSize;","uniform vec2 shadowMapResolution;","uniform sampler2D shadowMap;","uniform sampler2D shadowAccumulationBuffer;","uniform vec4 shadowData;","uniform vec2 cameraNearFar;","float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {","#if LINEAR_DEPTH == 0","float shadowDepth = unpackRGBAToDepth( texture2D( depths, uv ) );","#else","float nDotL = clamp( dot(normalize(lightVector), normalize(viewNormal)), 0.0, 1.0);","float shadowDepth = pow2(unpackRGBAToDepth(texture2D( depths, uv ))) + 0.01 * shadowData.z;","shadowDepth = shadowDepth * ( cameraNearFar.y - cameraNearFar.x ) + cameraNearFar.x;","#endif","return step( compare, shadowDepth );","}","float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {","const vec2 offset = vec2( 0.0, 1.0 );","vec2 texelSize = vec2( 1.0 ) / size;","vec2 centroidUV = floor( uv * size + 0.5 ) / size;","float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );","float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );","float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );","float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );","vec2 f = fract( uv * size + 0.5 );","float a = mix( lb, lt, f.y );","float b = mix( rb, rt, f.y );","float c = mix( a, b, f.x );","return c;","}","void main() {","float shadowValue = 1.0;","float shadowRadius = shadowData.y;","float shadowBiasMultiplier = shadowData.z;","float nDotL = clamp( dot(lightVector, normalize(viewNormal)), 0.0, 1.0);","float shadowBias = 0.02 *  sqrt( 1.0 -  nDotL * nDotL) / clamp(nDotL, 0.0006,  1.0);","shadowBias = clamp(shadowBias, 0.0001,  0.0003) * shadowBiasMultiplier;","vec3 shadowCoordNDC = shadowCoord.xyz/shadowCoord.w;","shadowCoordNDC.z -= shadowBias;","#if LINEAR_DEPTH == 1","float linearDepth = shadowCoord.z + 2.0*cameraNearFar.y*cameraNearFar.x/(cameraNearFar.y - cameraNearFar.x);","linearDepth *= -((cameraNearFar.y - cameraNearFar.x)/(cameraNearFar.y + cameraNearFar.x));","linearDepth = -linearDepth;","#endif","bvec4 inFrustumVec = bvec4 ( shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoordNDC.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","#if LINEAR_DEPTH == 1","shadowCoordNDC.z = linearDepth;","#endif","if(frustumTest) {","#if SHADOW_QUALITY == 0","shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);","#elif SHADOW_QUALITY == 1","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = (","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#elif SHADOW_QUALITY == 2","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = ( ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#endif","}","float previousAccumulation = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, gl_FragCoord.xy/shadowBufferSize ));","float t = shadowData.w/shadowData.x;","float shadowAccumulation = mix(previousAccumulation, shadowValue, t);","gl_FragColor = packDepthToRGBA(shadowAccumulation);","}"].join("\n")}},function(e,t,i){i(0),i(1),i(18),i(19),e.exports=PIXOTRON.PlaneShadowBakePass=class{constructor(e){e=e||{},this.linearDepth=void 0!==e.linearDepth?e.linearDepth:1,this.shadowMapResolution=void 0!==e.shadowMapResolution?e.shadowMapResolution:1024,this.shadowRadius=void 0!==e.shadowRadius?e.shadowRadius:1,this.shadowQuality=void 0!==e.shadowQuality?e.shadowQuality:1,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.shadowBiasMultiplier=void 0!==e.shadowBiasMultiplier?e.shadowBiasMultiplier:1,this.numSamples=void 0!==e.numSamples?e.numSamples:2e3,this.numSamplesPerFrame=void 0!==e.numSamplesPerFrame?e.numSamplesPerFrame:2,this.darkness=void 0!==e.darkness?e.darkness:1,this.falloff=void 0!==e.falloff?e.falloff:2,this.size=void 0!==e.size?e.size:1,this.lightDirection=e.lightDirection?e.lightDirection:new THREE.Vector3(0,1,0),this.lightSolidAngle=e.lightSolidAngle?e.lightSolidAngle:45,this.onComplete=e.onComplete,this.onProgress=e.onProgress,this.enable=void 0===e.enable||e.enable,this.Re=void 0===e.enableBlur||e.enableBlur;const t=void 0===e.bShadowMaterial||e.bShadowMaterial,i=void 0!==e.nearPlane?e.nearPlane:.1,a=void 0!==e.farPlane?e.farPlane:10;this.ee=new THREE.OrthographicCamera(-3,3,3,-3,i,a),this.boundingRadius=10,this.bt=0,this.ie(this.numSamples),this.N=0,this.oe=new THREE.Vector3,this.ae=new THREE.Vector3(0,-1,0),this.re=new THREE.Vector3,this.ne=new THREE.Matrix4,this.needsUpdate=!0,this.Te=new THREE.Mesh(new THREE.PlaneBufferGeometry(1,1),new THREE.MeshBasicMaterial({color:16777215})),this.Te.rotation.x=-Math.PI/2,this.Te.receiveShadow=!0,this.xe=new THREE.Scene,this.xe.add(this.Te);const r=t?new THREE.MeshBasicMaterial({color:16777215,transparent:!0}):new THREE.MeshStandardMaterial({roughness:1,metalness:0});this.De=new THREE.Mesh(new THREE.PlaneBufferGeometry(1,1),r);const s=this.De.geometry.attributes.uv.array;this.De.geometry.addAttribute("uv2",new THREE.BufferAttribute(s,2)),this.De.rotation.x=-Math.PI/2,this.De.receiveShadow=!0,this.Ne=!1}convergenceMetric(){return this.N/this.he.length}dispose(){this.le.dispose(),this.ce.dispose(),this.ue.dispose(),this.De.geometry.dispose()}getShadowPlane(){return this.De}update(e){this.Oe=new THREE.Box3,e.traverse(e=>{e.isMesh&&e.castShadow&&this.Oe.expandByObject(e)});const t=new THREE.Sphere;this.Oe.getBoundingSphere(t);const i=2.5*t.radius*this.size;if(0===i)return;this.Te.scale.set(i,i,i);const a=new THREE.Vector3;this.Oe.getCenter(a),this.Te.position.set(a.x,this.Oe.min.y,a.z),this.De.position.set(a.x,this.Oe.min.y,a.z),this.De.scale.copy(this.Te.scale),this.boundingRadius=2*t.radius,this.ee.left=-t.radius,this.ee.right=t.radius,this.ee.bottom=-t.radius,this.ee.top=t.radius,this.ee.far=this.boundingRadius+10,this.ee.updateProjectionMatrix(),this.needsUpdate=!0,this.Ne=!1}render(e,t,i){if(!this.enable)return;this.Oe||this.update(t),this.needsUpdate&&(this.N=0,this.needsUpdate=!1);const a=this.convergenceMetric();if(a>=1)return void(this.onComplete&&!this.Ne&&(this.onComplete(),this.Ne=!0));this.onProgress&&this.onProgress(a),this.le||(this.ee.layers.mask=i.layers.mask,this.me()),this.ie(this.numSamples);const r=e.getClearColor(),s=e.getClearAlpha(),o=e.autoClear;let n,h;for(let a=0;a<this.numSamplesPerFrame;a++)this.N=Math.min(this.N,this.he.length-1),this.N++,this.ge(),this.Ee(e,t,this.oe,this.le),n=this.N%2==0?this.ce:this.ue,h=this.N%2==0?this.ue:this.ce,this.we(e,t,i,n,h);this.Re&&this.Pe(e,h,n),this.kt.uniforms.shadowAccumulationBuffer.value=h,this.kt.uniforms.transition.value=this.smoothTransition?this.convergenceMetric():1;const l=this.kt.uniforms.shadowData.value;l.x=this.De.material.isMeshBasicMaterial?1-this.darkness:this.darkness,l.y=this.falloff,PIXOTRON.renderPass(e,this.kt,n),e.autoClear=o,e.setClearColor(r),e.setClearAlpha(s),this.De.material.isMeshBasicMaterial?this.De.material.map=n.texture:this.De.material.aoMap=n.texture}setSize(e,t){this.ce&&this.ce.setSize(e,t),this.ue&&this.ue.setSize(e,t),this.le&&this.le.setSize(e,t),this.ve.uniforms.shadowBufferSize.value.set(e,t)}Pe(e,t,i){this.Se||(this.Se=new THREE.ShaderMaterial(PIXOTRON.BlurShader)),this.Se.uniforms.tDiffuse.value=t,this.Se.uniforms.direction.value=new THREE.Vector3(1,0),this.Se.uniforms.size.value.x=i.width,this.Se.uniforms.size.value.y=i.height,PIXOTRON.renderPass(e,this.Se,i),this.Se.uniforms.tDiffuse.value=i,this.Se.uniforms.direction.value=new THREE.Vector3(0,1),this.Se.uniforms.size.value.x=i.width,this.Se.uniforms.size.value.y=i.height,PIXOTRON.renderPass(e,this.Se,t)}me(){const e={format:THREE.RGBAFormat,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter};this.le=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.ce=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.ue=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.le.texture.generateMipmaps=!1,this.ce.texture.generateMipmaps=!1,this.ue.texture.generateMipmaps=!1,this.linearDepth?(this._t=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this._t.uniforms=THREE.UniformsUtils.clone(this._t.uniforms)):this._t=new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking}),this.ve=new THREE.ShaderMaterial(PIXOTRON.SoftShadowPlaneShader),this.ve.uniforms=THREE.UniformsUtils.clone(this.ve.uniforms),this.ve.uniforms.shadowBufferSize.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.ve.uniforms.shadowMap.value=this.le,this.ve.uniforms.shadowData.value=new THREE.Vector4(0,1,1,1),this.ve.uniforms.shadowMapResolution.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.ve.defines.SHADOW_QUALITY=this.shadowQuality,this.ve.defines.LINEAR_DEPTH=this.linearDepth,this.kt=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionSoftShadowShadowShader),this.kt.defines.SHADOW_MATERIAL=this.De.material.isMeshBasicMaterial?1:0,this.kt.uniforms=THREE.UniformsUtils.clone(this.kt.uniforms)}we(e,t,i,a,r){this.ee.matrixWorldInverse.getInverse(this.ee.matrixWorld),this.ne.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.ne.multiply(this.ee.projectionMatrix),this.ne.multiply(this.ee.matrixWorldInverse),this.ve.uniforms.shadowMatrix.value.copy(this.ne),this.ve.uniforms.shadowData.value.x=this.N,this.ve.uniforms.shadowData.value.y=this.shadowRadius,this.ve.uniforms.shadowData.value.z=this.shadowBiasMultiplier,this.ve.uniforms.shadowAccumulationBuffer.value=a,this.ve.uniforms.vplPosition.value=this.ee.position,this.ve.uniforms.cameraNearFar.value.x=this.ee.near,this.ve.uniforms.cameraNearFar.value.y=this.ee.far,this.ve.uniforms.lightVector.value.x=-this.ae.x,this.ve.uniforms.lightVector.value.y=-this.ae.y,this.ve.uniforms.lightVector.value.z=-this.ae.z,this.ve.uniforms.weightSum.value=1/this.he.length,e.setClearColor(0);const s=e.shadowMap.enabled;e.shadowMap.enabled=!1,this.xe.overrideMaterial=this.ve,e.render(this.xe,i,r,!0),this.xe.overrideMaterial=null,e.shadowMap.enabled=s}Ee(e,t,i,a){!function(e,t){e.traverse(function(e){(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints)&&(e.castShadow||(e.oldVisibility=e.visible,e.visible=!1))})}(t),this.ee.position.copy(i),this.re.copy(i),this.re.addScaledVector(this.ae,10),this.ee.lookAt(this.re),this.ee.updateMatrixWorld(),t.overrideMaterial=this._t,this.linearDepth&&(this._t.uniforms.cameraNearFar.value.x=this.ee.near,this._t.uniforms.cameraNearFar.value.y=this.ee.far),e.setClearColor(0),e.render(t,this.ee,a,!0),t.overrideMaterial=null,t.traverse(function(e){e.oldVisibility&&(e.visible=e.oldVisibility,e.oldVisibility=void 0)})}sampleUniformCone(e,t,i){const a=1-e.x+e.x*t,r=Math.sqrt(1-a*a),s=2*e.y*Math.PI;i.x=Math.cos(s)*r,i.y=Math.sin(s)*r,i.z=a}ge(){const e=this.boundingRadius,t=this.he[this.N-1];let i=this.lightSolidAngle>45?45:this.lightSolidAngle;i=this.lightSolidAngle<0?0:i;const a=Math.cos(i*Math.PI/180);this.sampleUniformCone(t,a,this.ae),this.ae.multiplyScalar(-1),this.ae.normalize();const r=new THREE.Matrix4;this.lightDirection.normalize(),r.lookAt(this.lightDirection,new THREE.Vector3(0,0,0),new THREE.Vector3(0,1,0)),this.ae.transformDirection(r),this.ae.normalize();const s=new THREE.Vector3(-e*this.ae.x,-e*this.ae.y,-e*this.ae.z);this.oe.copy(s),this.oe.add(this.Te.position)}ie(e){e!==this.bt&&(this.bt=e,this.he=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectngle),this.he=PIXOTRON.randomizeArray(this.he))}}},function(e,t){e.exports=PIXOTRON.SoftShadowPlaneShader={defines:{SHADOW_QUALITY:0,LINEAR_DEPTH:1},uniforms:{shadowMap:{value:null},shadowAccumulationBuffer:{value:null},shadowBufferSize:{value:null},shadowMatrix:{value:new THREE.Matrix4},vplPosition:{value:new THREE.Vector3},lightVector:{value:new THREE.Vector3},shadowData:{value:new THREE.Vector4},cameraNearFar:{value:new THREE.Vector2},shadowMapResolution:{value:null},normalBias:{value:1},weightSum:{value:0}},vertexShader:["varying vec3 viewNormal;","varying vec4 shadowCoord;","uniform vec3 vplPosition;","uniform mat4 shadowMatrix;","uniform float normalBias;","void main() {","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","viewNormal = normalize(normalMatrix * normal);","vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;","//lightVector = vplPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;","//lightVector = normalize(lightVector);","shadowCoord = shadowMatrix * worldPosition;","// nDotL = clamp( dot(lightVector, viewNormal), 0.0, 1.0);","//worldPosition.xyz += normalize((modelMatrix * vec4( normal, 0.0 )).xyz) * 0.02 * normalBias * pow( 1.0 -  nDotL * nDotL, 4.);","//shadowCoord.xy = (shadowMatrix * worldPosition).xy;","//gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","gl_Position = vec4( 2. * uv.x - 1., 2. * uv.y - 1., 0., 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec3 viewNormal;","uniform vec3 lightVector;","varying vec4 shadowCoord;","uniform vec2 shadowBufferSize;","uniform vec2 shadowMapResolution;","uniform sampler2D shadowMap;","uniform sampler2D shadowAccumulationBuffer;","uniform vec4 shadowData;","uniform vec2 cameraNearFar;","uniform float weightSum;","float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {","#if LINEAR_DEPTH == 0","float shadowDepth = unpackRGBAToDepth( texture2D( depths, uv ) );","#else","float shadowDepth = pow2(unpackRGBAToDepth(texture2D( depths, uv ))) + 0.01 * shadowData.z;","shadowDepth = shadowDepth * ( cameraNearFar.y - cameraNearFar.x ) + cameraNearFar.x;","#endif","return step( compare, shadowDepth );","}","float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {","const vec2 offset = vec2( 0.0, 1.0 );","vec2 texelSize = vec2( 1.0 ) / size;","vec2 centroidUV = floor( uv * size + 0.5 ) / size;","float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );","float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );","float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );","float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );","vec2 f = fract( uv * size + 0.5 );","float a = mix( lb, lt, f.y );","float b = mix( rb, rt, f.y );","float c = mix( a, b, f.x );","return c;","}","void main() {","float shadowValue = 1.0;","float shadowRadius = shadowData.y;","float shadowBiasMultiplier = shadowData.z;","float nDotL = clamp( dot(lightVector, normalize(viewNormal)), 0.0, 1.0);","float shadowBias = 0.02 *  sqrt( 1.0 -  nDotL * nDotL) / clamp(nDotL, 0.0006,  1.0);","shadowBias = clamp(shadowBias, 0.0001,  0.0003) * shadowBiasMultiplier;","vec3 shadowCoordNDC = shadowCoord.xyz;///shadowCoord.w;","shadowCoordNDC.z -= shadowBias;","#if LINEAR_DEPTH == 1","float linearDepth = shadowCoord.z + (cameraNearFar.y + cameraNearFar.x)/(cameraNearFar.y - cameraNearFar.x);","linearDepth *= -(cameraNearFar.y - cameraNearFar.x) * 0.5;","linearDepth = -linearDepth;","#endif","bvec4 inFrustumVec = bvec4 ( shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoordNDC.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","#if LINEAR_DEPTH == 1","shadowCoordNDC.z = linearDepth;","#endif","if(frustumTest) {","#if SHADOW_QUALITY == 0","shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);","#elif SHADOW_QUALITY == 1","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = (","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#elif SHADOW_QUALITY == 2","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = ( ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#endif","}","float previousAccumulation = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, gl_FragCoord.xy/shadowBufferSize ));","if(shadowData.x == 1.) {","previousAccumulation = 0.;","}","float shadowAccumulation = previousAccumulation + shadowValue * weightSum;//mix(previousAccumulation, shadowValue, 1./shadowData.x);","gl_FragColor = packDepthToRGBA(shadowAccumulation);","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.BlurShader={uniforms:{tDiffuse:{value:null},size:{value:new THREE.Vector3},direction:{value:new THREE.Vector3(1,0)},step:{value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <packing>","uniform sampler2D tDiffuse;","uniform vec2 size;","uniform vec2 direction;","uniform float step;","varying vec2 vUv;","void main() {","float sum = 0.0;","vec2 uvDelta = step * direction / size;","//sum += texture2D( tDiffuse, vUv - 3. * uvDelta ) * 0.0918;","//sum += texture2D( tDiffuse, vUv - 2. * uvDelta ) * 0.2;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vUv - 1. * uvDelta )) * 0.3333;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vec2( vUv.x, vUv.y ) )) * 0.3333;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vUv + 1. * uvDelta )) * 0.3333;","//sum += texture2D( tDiffuse, vUv + 2. * uvDelta ) * 0.2;","//sum += texture2D( tDiffuse, vUv + 3. * uvDelta ) * 0.0918;","gl_FragColor = packDepthToRGBA(sum);//texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );","}"].join("\n")}},function(e,t,i){PIXOTRON.SuperSampleAAShader={uniforms:{tCurrent:{type:"t",value:null},tSumPrevious:{type:"t",value:null},accIndex:{type:"f",value:0}},vertexShader:"varying vec2 vUv;    void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"varying vec2 vUv;    uniform sampler2D tCurrent;    uniform sampler2D tSumPrevious;    uniform float accIndex;    void main() {      vec4 currentColor = texture2D(tCurrent, vUv);      vec4 previousSum = texture2D(tSumPrevious, vUv);      gl_FragColor = mix(previousSum, currentColor, 1./accIndex);    }    "}},function(e,t,i){i(22),e.exports=PIXOTRON.TemporalAAPass=class extends THREE.Pass{constructor(e,t){super(),this.feedBack=new THREE.Vector2(.8,.9),this.B=e,this.H=t,this.Me=new THREE.ShaderMaterial(PIXOTRON.TemporalAAShader),this.He=new THREE.Matrix4,this.Ce=new THREE.Matrix4,this.st=new THREE.Matrix4,this.st.copy(this.B.projectionMatrix)}dispose(){this.ye&&(this.ye.dispose(),this.Me.dispose())}setSize(e,t){this.ye&&this.ye.setSize(e,t),this.st.copy(this.B.projectionMatrix)}render(e,t,i){this.S(e);const a=e.getClearColor(),r=e.getClearAlpha(),s=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.Ce.multiplyMatrices(this.st,this.B.matrixWorldInverse),this._e(e,i),PIXOTRON.renderPass(e,this.Me,t),PIXOTRON.blit(e,t,this.ye),e.setClearColor(a,r),e.autoClear=s,this.He.copy(this.Ce)}S(e){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height;if(!this.ye){const e={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.ye=new THREE.WebGLRenderTarget(t,i,e)}}_e(e,t){let i,a;i=this.H.Et?this.H.Et:this.H.zt?this.H.zt.texture:null,this.H.zt||(a=this.H.It?this.H.It.texture:null),this.Me.uniforms.currentRT.value=t.texture,this.Me.uniforms.previousRT.value=this.ye.texture,this.Me.uniforms.tDepth.value=i||a;let r=this.H.Et?0:1;this.H.forceDepthAndNormalPass&&this.H.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(r=2),this.Me.defines.DEPTH_PACKING_MODE=r,this.Me.uniforms.currentProjectionViewMatrix.value.copy(this.Ce),this.Me.uniforms.lastProjectionViewMatrix.value.copy(this.He),this.Me.uniforms.ProjectionMatrix.value.copy(this.st),this.Me.uniforms.InverseViewMatrix.value.copy(this.B.matrixWorld),this.Me.uniforms.feedBack.value.x=this.feedBack.x,this.Me.uniforms.feedBack.value.y=this.feedBack.y;const s=this.Me.uniforms.cameraNearFar.value;s.x=this.B.near,s.y=this.B.far;const o=e.getDrawingBufferSize().width,n=e.getDrawingBufferSize().height,h=this.Me.uniforms.textureSize.value;h.x=o,h.y=n,this.Me.defines.LINEAR_DEPTH=this.H.yt?1:0}}},function(e,t){e.exports=PIXOTRON.TemporalAAShader={defines:{DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1,QUALITY:1,UNJITTER:0},uniforms:{currentRT:{value:null},previousRT:{value:null},tDepth:{value:null},cameraNearFar:{value:new THREE.Vector2},textureSize:{value:new THREE.Vector2},lastProjectionViewMatrix:{value:new THREE.Matrix4},currentProjectionViewMatrix:{value:new THREE.Matrix4},ProjectionMatrix:{value:new THREE.Matrix4},InverseViewMatrix:{value:new THREE.Matrix4},jitterSample:{value:new THREE.Vector2},feedBack:{value:new THREE.Vector2(.88,.97)}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );        }",fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D currentRT;","uniform sampler2D previousRT;","uniform sampler2D tDepth;","uniform vec2 textureSize;","uniform mat4 lastProjectionViewMatrix;","uniform mat4 currentProjectionViewMatrix;","uniform mat4 ProjectionMatrix;","uniform mat4 InverseViewMatrix;","uniform vec2 cameraNearFar;","uniform vec2 jitterSample;","uniform vec2 feedBack;","#include <packing>","float unpack16(vec2 value) {","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","#if DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 0","return unpackRGBAToDepth( texture2D( tDepth, uv ) );","#else","return pow2(unpackRGBAToDepth(texture2D( tDepth, uv )));","#endif","#elif DEPTH_PACKING_MODE == 2","#if LINEAR_DEPTH == 1","return pow2(unpack16(texture2D( tDepth, uv ).xy));","#else","return pow2(unpack16( texture2D( tDepth, uv ).xy ));","#endif","#else","return texture2D( tDepth, uv ).x;","#endif","}","float getViewZ( const in float depth ) {","\t#if PERSPECTIVE_CAMERA == 1","\treturn perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#else","\treturn orthoDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#endif","}","vec3 find_closest_fragment_3x3(const in vec2 uv) { ","const vec3 offset = vec3(-1.0, 1.0, 0.0);","vec2 texelSize = 1.0/textureSize; ","vec3 dtr = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtc = vec3( 0, 1, decodeDepth( uv + offset.zx * texelSize) );","vec3 dtl = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dml = vec3(-1, 0, decodeDepth( uv + offset.yz * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv ) );","vec3 dmr = vec3( 1, 0, decodeDepth( uv + offset.xz * texelSize) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbc = vec3( 0, -1, decodeDepth( uv + offset.zy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtc.z ) dmin = dtc;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dml.z ) dmin = dml;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dmr.z ) dmin = dmr;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbc.z ) dmin = dbc;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + texelSize.xy * dmin.xy, dmin.z);","}","vec3 find_closest_fragment_5tap(const in vec2 uv) ","{ ","vec2 texelSize = 1.0/textureSize; ","vec2 offset = vec2(1.0, -1.0);","vec3 dtl = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtr = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + dmin.xy * texelSize, dmin.z);","}","vec4 clip_aabb(const in vec4 aabb_min, const in vec4 aabb_max, vec4 p )","{ ","const float FLT_EPS = 1e-8;","vec4 p_clip = 0.5 * (aabb_max + aabb_min); ","vec4 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS; ","vec4 v_clip = p - p_clip;","vec4 v_unit = abs(v_clip / e_clip);","float ma_unit = max(v_unit.x, max(v_unit.y, v_unit.z));","if (ma_unit > 1.0) ","return p_clip + v_clip / ma_unit;","else ","return p;","}","vec2 computeScreenSpaceVelocity(const in vec3 worldPosition) {","vec4 currentPositionClip = currentProjectionViewMatrix * vec4(worldPosition, 1.0);","vec4 prevPositionClip = lastProjectionViewMatrix * vec4(worldPosition, 1.0);","vec2 currentPositionNDC = currentPositionClip.xy / currentPositionClip.w;","vec2 prevPositionNDC = prevPositionClip.xy / prevPositionClip.w;","if(prevPositionNDC.x >= 1.0 || prevPositionNDC.x <= -1.0 || prevPositionNDC.x >= 1.0 || prevPositionNDC.y <= -1.0) {","return vec2(0.0);","}","return 0.5 * (currentPositionNDC - prevPositionNDC);","}","vec4 computeTAA(const in vec2 uv, const in vec2 screenSpaceVelocity) {","vec2 jitterOffset = jitterSample/textureSize;","vec2 uvUnJitter = uv;","vec4 currentColor = texture2D(currentRT, uvUnJitter);","vec4 previousColor = texture2D(previousRT, uv - screenSpaceVelocity);","const vec3 offset = vec3(1., -1., 0.);","vec2 texelSize = 1./textureSize;","float texelSpeed = length( screenSpaceVelocity );","vec4 tl = texture2D(currentRT, uvUnJitter + offset.yx * texelSize);","vec4 tc = texture2D(currentRT, uvUnJitter + offset.zx * texelSize);","vec4 tr = texture2D(currentRT, uvUnJitter + offset.xx * texelSize);","vec4 ml = texture2D(currentRT, uvUnJitter + offset.yz * texelSize);","vec4 mc = currentColor;","vec4 mr = texture2D(currentRT, uvUnJitter + offset.xz * texelSize);","vec4 bl = texture2D(currentRT, uvUnJitter + offset.yy * texelSize);","vec4 bc = texture2D(currentRT, uvUnJitter + offset.zy * texelSize);","vec4 br = texture2D(currentRT, uvUnJitter + offset.xy * texelSize);","vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * mc;","mc += (mc - (corners * 0.166667)) * 2.718282 * 0.3;","mc = max(vec4(0.0), mc);","vec4 min5 = min(tc, min(ml, min(mc, min(mr, bc))));","vec4 max5 = max(tc, max(ml, max(mc, max(mr, bc))));","vec4 cmin = min(min5, min(tl, min(tr, min(bl, br))));","vec4 cmax = max(min5, max(tl, max(tr, max(bl, br))));;","cmin = 0.5 * (cmin + min5);","cmax = 0.5 * (cmax + max5);","previousColor = clip_aabb(cmin, cmax, previousColor);","float lum0 = linearToRelativeLuminance(currentColor.rgb);","float lum1 = linearToRelativeLuminance(previousColor.rgb);","float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));","float unbiased_weight = 1.0 - unbiased_diff;","float unbiased_weight_sqr = unbiased_weight * unbiased_weight;","float k_feedback = mix(feedBack.x, feedBack.y, unbiased_weight_sqr);","return mix(currentColor, previousColor, k_feedback);","}","vec3 getWorldPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return (InverseViewMatrix * vec4(xe, ye, viewDepth, 1.)).xyz;","}","void main() {","vec2 jitterOffset = jitterSample/textureSize;","#if QUALITY == 1","vec3 c_frag = find_closest_fragment_3x3(vUv);","#else","vec3 c_frag = find_closest_fragment_5tap(vUv);","#endif","if( c_frag.z >= 0.999 ) {","gl_FragColor = texture2D(currentRT, vUv - jitterOffset);","}","else {","#if LINEAR_DEPTH == 0","float sampleViewZ = getViewZ( c_frag.z );","#else","float sampleViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, c_frag.z);","#endif","vec3 worldPosition = getWorldPositionFromViewZ(c_frag.xy, sampleViewZ);","vec2 screenSpaceVelocity = computeScreenSpaceVelocity(worldPosition);","gl_FragColor = computeTAA(vUv, screenSpaceVelocity);","//gl_FragColor = vec4(10. * length(screenSpaceVelocity));","}","}"].join("\n")}},function(e,t,i){i(24),e.exports=PIXOTRON.BilateralFilterPass=class{constructor(){this.blurKernelSize=3,this.edgeSharpness=1,this.bilateralFilterMaterial=new THREE.ShaderMaterial(PIXOTRON.SAOBilateralFilterShader),this.bilateralFilterMaterial.uniforms=THREE.UniformsUtils.clone(this.bilateralFilterMaterial.uniforms),this.bilateralFilterMaterial.defines=Object.assign({},this.bilateralFilterMaterial.defines),this.bilateralFilterMaterial.defines.USE_NORMAL_WEIGHT=1}render(e,t,i,a){this.S(e),this.Ie(e,t,i,a)}setSize(e,t){this.ze&&this.ze.setSize(e,t),this.bilateralFilterMaterial.uniforms.size.value.set(e,t)}dispose(){this.ze&&(this.ze.dispose(),this.ze=null),this.bilateralFilterMaterial.dispose()}S(e){if(!this.ze){const t=e.getDrawingBufferSize().width,i=e.getDrawingBufferSize().height,a={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.ze=new THREE.WebGLRenderTarget(t,i,a)}}Ie(e,t,i,a){const r=e.getDrawingBufferSize().width,s=e.getDrawingBufferSize().height;this.bilateralFilterMaterial.uniforms.size.value.set(r,s);const o=a.At?a.At.texture:null;let n;a.zt||(n=a.It?a.It.texture:null),n?(this.bilateralFilterMaterial.defines.DEPTH_NORMAL_TEXTURE=1,this.bilateralFilterMaterial.uniforms.tNormal.value=n):this.bilateralFilterMaterial.uniforms.tNormal.value=o,this.bilateralFilterMaterial.defines.KERNEL_SAMPLE_RADIUS=this.blurKernelSize,this.bilateralFilterMaterial.defines.LINEAR_DEPTH=a.yt?1:0,this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=t.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(1,0),this.bilateralFilterMaterial.uniforms.edgeSharpness.value=this.edgeSharpness;const h=this.bilateralFilterMaterial.uniforms.cameraNearFar.value;h.x=i.near,h.y=i.far,PIXOTRON.renderPass(e,this.bilateralFilterMaterial,this.ze),this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=this.ze.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(0,1),PIXOTRON.renderPass(e,this.bilateralFilterMaterial,t)}}},function(e,t){e.exports=PIXOTRON.SAOBilateralFilterShader={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SAMPLE_RADIUS:4,LINEAR_DEPTH:1,DEPTH_NORMAL_TEXTURE:0},uniforms:{tOcclusionDepth:{type:"t",value:null},tNormal:{type:"t",value:null},size:{type:"v2",value:new THREE.Vector2(256,256)},kernelDirection:{type:"v2",value:new THREE.Vector2(1,0)},cameraNearFar:{type:"v2",value:new THREE.Vector2(1,0)},edgeSharpness:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D tOcclusionDepth;","uniform sampler2D tNormal;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform float edgeSharpness;","uniform vec2 kernelDirection;","#include <packing>","float getViewZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 unpackNormal(vec2 enc) {","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","vec3 getViewNormal( const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormal, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linearStep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","float unpackRGBToFloat(const in vec3 x) {","const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);","return dot(x, decode);","}","void calculateBilateralWeight( const in vec2 uv, const in vec3 centreNormal, const in float centerDepth,","const in float kernelWeight, inout float totalOcclusion, inout float totalBilateralWeight ) {","vec4 aoDepth = texture2D( tOcclusionDepth, uv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","return;","}","vec3 normal = getViewNormal(uv);","#if LINEAR_DEPTH == 0","depth = -getViewZ( depth );","depth = linearStep(cameraNearFar.x, cameraNearFar.y, depth);","#endif","float normalWeight = 1.;","#if USE_NORMAL_WEIGHT == 1","float normalCloseness = dot(normal, centreNormal);","normalCloseness *= normalCloseness;","float normalError = (1.0 - normalCloseness) * 8.;","normalWeight = max((1.0 - normalError * edgeSharpness), 0.00);","#endif","float depthWeight = max(0.0, 1.0 - edgeSharpness * 4000. * abs(depth - centerDepth)) * kernelWeight;","float bilateralWeight = depthWeight * normalWeight;","totalOcclusion += occlusion * bilateralWeight;","totalBilateralWeight += bilateralWeight;","}","void main() {","vec4 aoDepth = texture2D( tOcclusionDepth, vUv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","discard;","}","vec3 centreNormal = getViewNormal(vUv);","#if LINEAR_DEPTH == 0","float centerViewZ = -getViewZ( depth );","centerViewZ = linearStep(cameraNearFar.x, cameraNearFar.y, centerViewZ);","#else","float centerViewZ = depth;","#endif","float gaussianWeights[4];","gaussianWeights[0] = 0.153170;","gaussianWeights[1] = 0.144893;","gaussianWeights[2] = 0.122649;","gaussianWeights[3] = 0.092902;","float totalBilateralWeight = gaussianWeights[0] + 0.03;","float totalOcclusion = occlusion * totalBilateralWeight;","vec2 uvDelta = 2.0 * kernelDirection / size;","float kernelWeight = gaussianWeights[1] + 0.03;","calculateBilateralWeight( vUv + uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[2] + 0.03;","calculateBilateralWeight( vUv + 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[3] + 0.03;","calculateBilateralWeight( vUv + 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","occlusion = totalOcclusion / totalBilateralWeight;","gl_FragColor = vec4( occlusion, aoDepth.gba );","}"].join("\n")}},function(e,t,i){i(26),e.exports=PIXOTRON.UnrealBloomPass=class extends THREE.Pass{constructor(e,t,i,a,r){super(),this.H=e,this.strength=void 0!==i?i:1,this.radius=a,this.threshold=r,this.resolution=void 0!==t?new THREE.Vector2(t.x,t.y):new THREE.Vector2(256,256);const s={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let o=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(o,n,s),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){let t=new THREE.WebGLRenderTarget(o,n,s);t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t),(t=new THREE.WebGLRenderTarget(o,n,s)).texture.name="UnrealBloomPass.v"+e,t.texture.generateMipmaps=!1,this.renderTargetsVertical.push(t),o=Math.round(o/2),n=Math.round(n/2)}const h=PIXOTRON.BloomExtractShader;this.bloomExtractUniforms=THREE.UniformsUtils.clone(h.uniforms),this.bloomExtractUniforms.bloomThreshold.value=r,this.materialBloomExtract=new THREE.ShaderMaterial({uniforms:this.bloomExtractUniforms,vertexShader:h.vertexShader,fragmentShader:h.fragmentShader,defines:{DEPTH_PACKING_MODE:0,LINEAR_DEPTH:1}}),this.separableBlurMaterials=[];const l=[3,5,7,9,11];o=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(o,n),o=Math.round(o/2),n=Math.round(n/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=i,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const u=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(u.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.basic=new THREE.MeshBasicMaterial,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let i=Math.round(e/2),a=Math.round(t/2);this.renderTargetBright.setSize(i,a);for(let e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(i,a),this.renderTargetsVertical[e].setSize(i,a),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(i,a),i=Math.round(i/2),a=Math.round(a/2)}render(e,t,i,a,r){this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha();const s=e.autoClear;let o,n;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),r&&e.context.disable(e.context.STENCIL_TEST),this.renderToScreen&&(this.quad.material=this.basic,this.basic.map=i.texture,e.render(this.scene,this.camera,void 0,!0)),o=this.H.Et?this.H.Et:this.H.zt?this.H.zt.texture:null,this.H.zt||(n=this.H.It?this.H.It.texture:null),this.materialBloomExtract.uniforms.tDepth.value=o||n;let h=this.H.Et?0:1;this.H.forceDepthAndNormalPass&&this.H.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(h=2),this.materialBloomExtract.defines.DEPTH_PACKING_MODE=h,this.materialBloomExtract.defines.LINEAR_DEPTH=this.H.yt?1:0,this.bloomExtractUniforms.tColor.value=i.texture,this.bloomExtractUniforms.bloomThreshold.value=this.threshold,this.quad.material=this.materialBloomExtract,e.render(this.scene,this.camera,this.renderTargetBright,!0);let l=this.renderTargetBright;for(let t=0;t<this.nMips;t++)this.quad.material=this.separableBlurMaterials[t],this.separableBlurMaterials[t].uniforms.colorTexture.value=l.texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionX,e.render(this.scene,this.camera,this.renderTargetsHorizontal[t],!0),this.separableBlurMaterials[t].uniforms.colorTexture.value=this.renderTargetsHorizontal[t].texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionY,e.render(this.scene,this.camera,this.renderTargetsVertical[t],!0),l=this.renderTargetsVertical[t];this.quad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.render(this.scene,this.camera,this.renderTargetsHorizontal[0],!0),this.quad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&e.context.enable(e.context.STENCIL_TEST),this.renderToScreen?e.render(this.scene,this.camera,void 0,!1):e.render(this.scene,this.camera,i,!1),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=s}getSeperableBlurMaterial(e){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum);\n\t\t\t\t}"})}getCompositeMaterial(e){return new THREE.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"})}},PIXOTRON.UnrealBloomPass.BlurDirectionX=new THREE.Vector2(1,0),PIXOTRON.UnrealBloomPass.BlurDirectionY=new THREE.Vector2(0,1)},function(e,t){e.exports=PIXOTRON.BloomExtractShader={uniforms:{tColor:{type:"t",value:null},tDepth:{type:"t",value:null},bloomThreshold:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <packing>","uniform sampler2D tColor;","uniform sampler2D tDepth;","uniform float bloomThreshold;","varying vec2 vUv;","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth = texture2D( tDepth, uv );","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow(unpackRGBAToDepth(uncodedDepth), 2.);","#else","return unpackRGBAToDepth(uncodedDepth );","#endif","#else","return pow(unpack16(uncodedDepth.xy), 2.);","#endif","}","void main() {","vec4 color = texture2D( tColor, vUv );","float depth = decodeDepth(vUv);","const vec3 c = vec3( 0.299, 0.587, 0.114 );","float luminance = dot( color.xyz, c );","float alpha = smoothstep( bloomThreshold, bloomThreshold + 0.01, luminance );","alpha = depth > 1. - 0.001 ? 0. : alpha;","gl_FragColor = color * alpha;","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.VPLGenerationPass=class{constructor(e){this.maxVPL=e,this.Ae=0,this.Xe=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.Fe=[];for(let e=0;e<this.Xe.length;e++){const t=this.Xe[e];this.Fe.push(new THREE.Vector2(t.x,t.y))}this.Ve=new THREE.Ray,this.Ue=new THREE.Raycaster,this.N=0,this.be=!1,this.Le=[],this.Be=new THREE.SphereBufferGeometry(.05,5,5),this.ke=[],this.K=!1,this.needsUpdate=!0}getVPLBuffer(){return this.ke}getNumVPL(){return this.Xe.length}generateVPLs(e,t,i,a){if(!this.K)return;if(this.needsUpdate&&(this.et(),this.needsUpdate=!1),this.Ae>=this.getNumVPL())return this.needsUpdate=!1,void(this.We.visible=!0);this.We||(this.We=new THREE.Object3D,this.We.visible=!1,e.add(this.We)),performance.now();let r=0;for(let s=0;s<i;s++){const o=this.Ve.origin,n=this.Ve.direction;if(this.Ue.set(this.Ve.origin,this.Ve.direction),!this.je(t,o,n,this.N*i+s))break;const h=a?a.intersectRay(this.Ve,e):this.Ue.intersectObject(e,!0);if(h.length>0){const e=h[0];if(e.object instanceof THREE.Mesh){const t=new THREE.Color,i=new THREE.Vector3,a=new THREE.Vector3;i.copy(e.point),a.copy(e.face.normal),a.transformDirection(e.object.matrixWorld);const s=this.Ze(e.object.material.map,e.uv,64);t.copy(e.object.material.color),t.multiply(s),this.ke.push({position:i,normal:a,intensity:new THREE.Vector3(t.r,t.g,t.b)}),this.be&&this.Ge(i,t),r++}}}this.N++,this.Ae+=r,this.be&&r>0&&(performance.now(),this.Ae)}Ge(e,t){const i=new THREE.MeshBasicMaterial;i.color.copy(t);const a=new THREE.Mesh(this.Be,i);a.position.copy(e),this.We.add(a)}et(){this.N=0,this.Ae=0,this.ke=[]}Ze(e,t,i){if(!e||!e.image)return new THREE.Color(16777215);let a=this.Le[e.uuid];a||(i=i||32,a=PIXOTRON.getDataFromImage(e.image,i),this.Le[e.uuid]=a);let r=t.x,s=t.y;void 0!==e.repeat&&(r*=e.repeat.x,s*=e.repeat.y),r*=a.width,s*=a.height,e.wrapS===THREE.RepeatWrapping&&(r%=a.width),e.wrapS===THREE.ClampToEdgeWrapping&&(r=Math.min(r,a.width-1)),e.wrapT===THREE.RepeatWrapping&&(s%=a.height),e.wrapT===THREE.ClampToEdgeWrapping&&(s=Math.min(s,a.height-1));const o=Math.floor(r),n=Math.floor(s),h=PIXOTRON.getPixelFromImageData(a,o,n);return h.r=Math.pow(h.r/255,1),h.g=Math.pow(h.g/255,1),h.b=Math.pow(h.b/255,1),new THREE.Color(h.r,h.g,h.b)}je(e,t,i,a){if(a<this.Xe.length){const r=this.Xe[a];t.x=(2*r.x-1)*e.width*.5,t.z=0,t.y=(2*r.y-1)*e.height*.5,t.applyMatrix4(e.matrixWorld);const s=this.Fe[a],o=PIXOTRON.squareToCosineHemisphere(s);return i.copy(o),i.transformDirection(e.matrixWorld),!0}return!1}}},function(e,t,i){i(29),e.exports=PIXOTRON.InstantRadiosityPass=class{constructor(){this.qe=10,this.Ke=0,this.N=0,this.Je=!1,this.needsUpdate=!0,this.enabled=!0}convergenceMetric(){const e=this.Qe.getNumVPL();return this.enabled?this.N*this.qe/e:1}render(e,t,i,a,r){this.needsUpdate&&(this.et(),this.N=0,this.needsUpdate=!1),this.Qe=a;const s=a.getNumVPL(),o=a.getVPLBuffer();if(0===o.length)return;if(this.convergenceMetric()>=1)return;if(!this.bbox){this.bbox=new THREE.Box3,this.bbox.setFromObject(t);const e=new THREE.Vector3;this.bbox.getSize(e),this.minDistance=Math.max(Math.max(e.x,e.y),e.z)/9}this.Ye||this.S(e),this.N++,t.overrideMaterial=this.$e;const n=this.N%2==0?this.Ye:this.ti,h=this.N%2==0?this.ti:this.Ye;this.$e.uniforms.accumulationBuffer.value=n.texture,this.$e.uniforms.currentFrameCount.value=this.N,this.ei(o,s,r),e.render(t,i,h,!0),t.overrideMaterial=null,e.indirectDiffuseBuffer=h.texture}S(e){const t=e.getDrawingBufferSize(),i=t.width,a=t.height;let r=THREE.UnsignedByteType;if(!this.Je){const t=e.extensions,i=t.get("OES_texture_half_float");r=i?THREE.HalfFloatType:r,i||(r=t.get("OES_texture_float")?THREE.FloatType:r)}const s={type:r,format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter};this.Ye=new THREE.WebGLRenderTarget(i,a,s),this.Ye.texture.generateMipmaps=!1,this.ti=new THREE.WebGLRenderTarget(i,a,s),this.ti.texture.generateMipmaps=!1,this.$e=new THREE.ShaderMaterial(PIXOTRON.VPLAccumulationShader),this.$e.defines.VPL_COUNT=this.qe,this.$e.uniforms.viewPort.value=new THREE.Vector2(i,a),this.$e.uniforms.currentFrameCount.value=this.N,this.$e.uniforms.minDistance.value=this.minDistance,(r===THREE.UnsignedByteType||this.Je)&&(this.$e.dithering=!0)}et(){this.N=0,this.Ke=0}ei(e,t,i){let a=e.length-this.Ke;a=Math.min(a,this.qe);const r=new THREE.Vector3(0,0,0),s=[];for(let o=0;o<a;o++){const a=e[o+this.Ke];if(o>=e.length)s.push({position:r,direction:r,intensity:r});else{const e=new THREE.Vector3;e.copy(a.intensity),e.multiplyScalar(i.intensity/t),s.push({position:a.position,direction:a.normal,intensity:e})}}for(let e=0;e<this.qe-a;e++)s.push({position:r,direction:r,intensity:r});this.Ke+=a,this.$e.uniforms.vplLights.value=s}}},function(e,t){e.exports=PIXOTRON.VPLAccumulationShader={vertexShader:["varying vec3 worldPosition;","varying vec3 worldNormal;","void main() {","   worldPosition = (modelMatrix * vec4( position.xyz, 1.0)).xyz;","   worldNormal = (modelMatrix * vec4(normal, 0.0)).xyz;","   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <dithering_pars_fragment>","varying vec3 worldPosition;","varying vec3 worldNormal;","uniform vec2 viewPort;","uniform sampler2D accumulationBuffer;","uniform float currentFrameCount;","uniform float minDistance;","struct VPL {","   vec3 position;","   vec3 direction;","   vec3 intensity;","};","uniform VPL vplLights[VPL_COUNT];","float getLightIrradiance(const in vec3 lightPos, const in vec3 lightDir) {","vec3 lightVector = lightPos - worldPosition;","vec3 direction = normalize( lightVector );","float lightDistance = length( lightVector );","float distanceFalloff = 1.0 /max( lightDistance * lightDistance, minDistance * minDistance );","float csTheta_i = dot( direction, -lightDir );","float csTheta_o = dot( normalize(worldNormal), direction );","return max(csTheta_i, 0.) * max( csTheta_o, 0.0 ) * distanceFalloff / PI;","}","void main() {","vec3 colorSum = vec3(0.0);","for( int i = 0; i < VPL_COUNT; i++) {","VPL vpl = vplLights[i];","vec3 lightPosition = vpl.position;","vec3 lightDirection = vpl.direction;","vec3 lightIntensity = vpl.intensity;","vec3 lightColor = lightIntensity * getLightIrradiance( lightPosition, lightDirection );","colorSum += lightColor;","}","vec3 previousColor = texture2D( accumulationBuffer, gl_FragCoord.xy/viewPort ).rgb;","if( currentFrameCount == 1. ){","previousColor = vec3(0.);","}","vec3 newColor = previousColor + colorSum;","gl_FragColor = vec4( newColor , 1.0);","#include <dithering_fragment>","}"].join("\n"),uniforms:{vplLights:{value:null},viewPort:{value:null},accumulationBuffer:{value:null},currentFrameCount:{value:0},minDistance:{value:0}},defines:{VPL_COUNT:0}}},function(e,t,i){i(31),i(3),e.exports=PIXOTRON.OutlinePass=class{constructor(e){e=e||{},this.highlightColor=void 0!==e.highlightColor?e.highlightColor:new THREE.Color(1,.25,0),this.edgeThickness=void 0!==e.edgeThickness?e.edgeThickness:1,this.edgeStrength=void 0!==e.edgeStrength?e.edgeStrength:1,this.transpareny=void 0!==e.transpareny?e.transpareny:.1,this.enableAA=void 0===e.enableAA||e.enableAA,this.ii=new THREE.MeshBasicMaterial({color:this.highlightColor,side:THREE.DoubleSide}),this.N=0,this.si=new THREE.ShaderMaterial(PIXOTRON.EdgeDetectionShader),this.enabled=!0,this.needsUpdate=!0}ht(e,t){if(!this.enableAA)return;const i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height,r=this.F[this.N%this.F.length];PIXOTRON.jitterCamera(t,r,i,a)}dispose(){this.oi.dispose(),this.ut.dispose()}getRenderTarget(){return this.ut}setSize(e,t){this.oi.setSize(e,t),this.ut.setSize(e,t)}isConverged(){return this.X?this.N/this.F.length>=1:1}render(e,t,i,a){if(this.enabled&&a&&a.length>0){this.needsUpdate&&(this.et(),this.needsUpdate=!1),this.oi||this.S(e),this.enableAA&&!this.X&&(this.X=new PIXOTRON.SuperSampleAAPass,this.F=PIXOTRON.generateQuasiRandomPoints(30,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle));const r=e.getClearAlpha(),s=e.getClearColor(),o=e.autoClear;e.autoClear=!0,e.setClearColor(0,1);const n=t.background;t.background=null,this.ht(e,i),this.ai(t,a,!1),t.overrideMaterial=this.ii,e.render(t,i,this.oi,!0),t.overrideMaterial=null,this.ai(t,a,!0),i.clearViewOffset(),t.background=n,0!==this.N&&this.enableAA&&(this.X.render(e,this.ut,this.oi),PIXOTRON.blit(e,this.ut,this.oi)),this.si.uniforms.maskTexture.value=this.oi.texture,this.si.uniforms.texSize.value.x=this.oi.width,this.si.uniforms.texSize.value.y=this.oi.height,this.si.uniforms.edgeThickness.value=this.edgeThickness,this.si.uniforms.highlightColor.value=this.highlightColor,this.si.uniforms.transpareny.value=this.transpareny,this.si.uniforms.edgeStrength.value=this.edgeStrength,PIXOTRON.renderPass(e,this.si,this.ut),e.setClearColor(s,r),e.autoClear=o,this.N++}}ai(e,t,i){const a=[];function r(e){e.isMesh&&a.push(e)}for(let e=0;e<t.length;e++)t[e].traverse(r);e.traverse(function(e){if(e.isMesh||e.isLine||e.isSprite){let t=!1;for(let i=0;i<a.length;i++)if(a[i].id===e.id){t=!0;break}if(!t){const t=e.visible;i&&!e.bVisible||(e.visible=i),e.bVisible=t}}})}S(e){const t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},i=e.getDrawingBufferSize().width,a=e.getDrawingBufferSize().height;this.oi=new THREE.WebGLRenderTarget(i,a,t),this.oi.texture.generateMipmaps=!1,this.ut=new THREE.WebGLRenderTarget(i,a,t),this.ut.texture.generateMipmaps=!1}et(){this.N=0,this.X&&(this.X.needsUpdate=!0)}}},function(e,t,i){const a=i(32).default,r=i(33).default;e.exports=PIXOTRON.EdgeDetectionShader={uniforms:{maskTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},highlightColor:{value:new THREE.Vector3(1,1,1)},edgeThickness:{value:1},edgeStrength:{value:1},transpareny:{value:.5}},vertexShader:a,fragmentShader:r}},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.default="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.default="varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform vec2 texSize;\nuniform vec3 highlightColor;\nuniform float edgeThickness;\nuniform float edgeStrength;\nuniform float transpareny;\n\nvoid main() {\n    vec2 invSize = 1.0 / texSize;\n    vec4 uvOffset = edgeThickness * vec4(1.0, 0.0, -1.0, 1.0) * vec4(invSize, invSize);\n    vec4 c = texture2D(maskTexture, vUv);\n    vec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);\n    vec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);\n    vec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);\n    vec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);\n    float diff1 = (c1.r - c2.r) * 0.5;\n    float diff2 = (c3.r - c4.r) * 0.5;\n    float d = length(vec2(diff1, diff2));\n    gl_FragColor = vec4(c.rgb, transpareny) + edgeStrength * vec4(highlightColor, 1.0) * vec4(d);\n}"}]);