import RapiAccess from '../../../common-core/src/rapi-access';
import EnvironmentLoader from '../../../common-core/src/services/environment-loader';
import DataSyncer from '../../../common-core/src/services/data-syncer';
import SinglePromiseFactory from '../utils/single-promise-factory';
import { RapiMaterial } from '../../../typings/rapi-types';
import CacheHolder from '../services/cache-holder';
import { Context } from '../di/context';
export default class MeshGenerator implements Context {
    _creator_: string;
    waitingForMaterials: Array<Promise<void>>;
    protected _rapiAccess: RapiAccess;
    protected _environmentLoader: EnvironmentLoader;
    protected _dataSyncer: DataSyncer;
    protected _singlePromiseFactory: SinglePromiseFactory;
    protected _cacheHolder: CacheHolder;
    private _plannerMeshGenerator;
    protected _materialLoaded: () => void;
    protected _maxAnisotrophy: number;
    protected _textureLoader: import("three").TextureLoader;
    protected _previewMaterial: THREE.MeshStandardMaterial;
    constructor(creator: string);
    protected _generateGeometry(meshId: string, vertices: Int32Array, indices: Int32Array, uvCoords: Float32Array, normals: Float32Array): THREE.Geometry;
    changeMaterialOfMesh(mesh: THREE.Mesh, material: THREE.Material): void;
    protected _createMaterial(materialId: string, resolve: () => void, reject: (error: Error) => void, width?: number, height?: number): void;
    private _loadBenchmarkTextures;
    protected _loadTextures(rapiMaterial: RapiMaterial, material: THREE.MeshPhysicalMaterial, width?: number, height?: number): Promise<void>;
    protected _loadMaterial(materialId: string, width?: number, height?: number): Promise<THREE.Material>;
    protected _assignMaterial(mesh: THREE.Mesh, materialId: string): Promise<void>;
    maxAnisotrophy: number;
    clear(): void;
    getPreviewMaterial(): THREE.MeshStandardMaterial;
    protected _assignRGB(mesh: THREE.Mesh, rgbValue: number): Promise<void>;
    protected _assignItem(mesh: THREE.Mesh, catalogItemId: string): Promise<void>;
    protected _generateMesh(meshId: string, material: any, vertices: Int32Array, indices: Int32Array, uvCoords: Float32Array, normals: Float32Array, newGeometryInstance?: boolean): THREE.Mesh;
    setMaterialLoadedListener(fun: () => void): void;
    removeMaterialLoadedListener(): void;
}
