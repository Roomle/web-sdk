const toRadiant=function(e){return e*(Math.PI/180)},getIdealDistance=function(e,t,a,r,n,o){e=Math.sqrt(e*e+a*a);const s=n/o,i=2*Math.atan(Math.tan(r*Math.PI/180/2)*s)*180/Math.PI,l=toRadiant(r),E=t/2/Math.tan(l/2),c=e/(2*Math.atan(Math.PI*i/360));return Math.max(E,c)},round=function(e){return Math.round(1e3*e)/1e3},getDelta=function(e,t){return Math.abs(e.y-t.y)+Math.abs(e.x-t.x)},getAngle=function(e,t){return Math.atan2(t.y-e.y,t.x-e.x)},to360Degrees=function(e){let t=function(e){return e*(180/Math.PI)}(e);return t<0&&(t=180+(180+t)),t},PREVIEW_LINE_MATERIAL_OPACITY=.4,PREVIEW_MATERIAL_COLOR="#DDDDDD",PREVIEW_MATERIAL_ROUGHNESS=1,PREVIEW_MATERIAL_METALNESS=0,PREVIEW_MATERIAL_OPACITY=1,DOCK_PREVIEW_MATERIAL_COLOR="#DDDDDD",DOCK_PREVIEW_MATERIAL_ROUGHNESS=1,DOCK_PREVIEW_MATERIAL_METALNESS=0,DOCK_PREVIEW_MATERIAL_OPACITY=.6,DOCK_PREVIEW_MATERIAL_OPACITY_HOVERED=.9,getScreenXY=(e,t,a,r)=>{if(!e||!t||0===a||0===r)return new THREE.Vector3;let n=e.clone(),o=a/2,s=r/2;return n.project(t),n.x=Math.floor(n.x*o+o),n.y=Math.floor(-n.y*s+s),n.z=e.distanceTo(t.position),n},kernelBoxToThreeBox=(e,t)=>{t||(t=new THREE.Vector3(0,0,0));let a=new THREE.Vector3(e.size.x/1e3,e.size.z/1e3,e.size.y/1e3),r=new THREE.Vector3(e.origin.x/1e3,e.origin.z/1e3,e.origin.y/-1e3),n=new THREE.Vector3(0,0,-a.z).add(r).sub(t),o=new THREE.Vector3(a.x,a.y,0).add(r).add(t);return new THREE.Box3(n,o)},kernelDimensioningToThree=e=>(e.from=e.from/1e3,e.to=e.to/1e3,1===e.type.value?(e.type={value:2},e.from*=-1,e.to*=-1):2===e.type.value&&(e.type={value:1}),e),setShadows=(e,t,a)=>{e.castShadow=a,e.receiveShadow=t,e.children.forEach(e=>{setShadows(e,t,a)})},position3VectorsAreEqual=(e,t)=>{let a=round(e.x),r=round(e.y),n=round(e.z),o=round(t.x),s=round(t.y),i=round(t.z);return a===o&&r===s&&n===i},rotationQuaternionsAreEqual=(e,t)=>{let a=round(e.w),r=round(e.x),n=round(e.y),o=round(e.z),s=round(t.w),i=round(t.x),l=round(t.y),E=round(t.z);return a===s&&r===i&&n===l&&o===E},position2VectorsAreEqual=(e,t)=>{let a=round(e.x),r=round(e.y),n=round(t.x),o=round(t.y);return a===n&&r===o};let whiteTexture=null;const getWhiteTexture=()=>{if(whiteTexture)return whiteTexture;const e=new Uint8Array(4);for(let t=0;t<1;t++){const a=4*t;e[a]=255,e[a+1]=255,e[a+2]=255,e[a+3]=255}const t=new THREE.DataTexture(e,1,1,THREE.RGBAFormat);return t.needsUpdate=!0,t},createColorTexture=(e,t,a,r)=>{const n=new Uint8Array(4),o=Math.floor(255*e),s=Math.floor(255*t),i=Math.floor(255*a),l=Math.floor(255*r);for(let e=0;e<4;e++){const t=4*e;n[t]=o,n[t+1]=s,n[t+2]=i,n[t+3]=l}const E=new THREE.DataTexture(n,1,1,THREE.RGBAFormat);return E.needsUpdate=!0,E},createColorCubeTexture=(e,t,a,r)=>{const n=new THREE.CubeTexture;n.format=THREE.RGBAFormat,n.generateMipmaps=!1;for(let o=0;o<6;++o){const s=createColorTexture(e,t,a,r);s.format=n.format,s.type=n.type,s.minFilter=n.minFilter,s.magFilter=n.magFilter,s.generateMipmaps=n.generateMipmaps,s.needsUpdate=!0,n.images[o]=s}return n.needsUpdate=!0,n},createMaterial=(e,t)=>{let a=new THREE.MeshPhysicalMaterial({metalness:1===e.shading.metallic?1:.5,reflectivity:e.shading.metallic||.5,roughness:e.shading.roughness||.5,transparent:e.shading.alpha<1,opacity:e.shading.alpha,depthWrite:e.shading.alpha>=1,aoMapIntensity:e.shading.occlusion||1});if(e.shading.basecolor){const t=new THREE.Color(e.shading.basecolor.r,e.shading.basecolor.g,e.shading.basecolor.b);a.color.copy(t.copyGammaToLinear(t))}return t&&t.setEnvMap(a),e.shading.doubleSided?a.side=THREE.DoubleSide:a.side=THREE.FrontSide,e.shading.alphaCutoff?a.alphaTest=e.shading.alphaCutoff:a.alphaTest=0,whiteTexture||(whiteTexture=getWhiteTexture()),a.map=whiteTexture,a},getMaterialShading=e=>{let t=e.color.clone().copyLinearToGamma(e.color),a={alpha:e.opacity,metallic:e.reflectivity,basecolor:{r:t.r,g:t.g,b:t.b},roughness:e.roughness,doubleSided:e.side===THREE.DoubleSide,alphaCutoff:e.alphaTest};return 1===e.metalness?a.metallic=1:a.metallic=e.reflectivity,a};let textureLoader=null;const addTexture=(e,t,a,r,n,o)=>(textureLoader||((textureLoader=new THREE.TextureLoader).crossOrigin=""),new Promise((s,i)=>{textureLoader.load(e,e=>{e.anisotropy=r,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,e.repeat.set(n,o),"XYZ"===t.mapping?(a.normalMap=e,a.map===getWhiteTexture()&&(a.map=null)):"ORM"===t.mapping?(a.aoMap=e,a.roughnessMap=e,a.metalnessMap=e):a.map=e,"RGBA"===t.mapping&&(a.transparent=!0),a.needsUpdate=!0,s()},i)})),getGUI=(e=!0)=>(window.__RML_GUI__||(window.__RML_GUI__=new dat.GUI({autoPlace:e})),window.__RML_GUI__),setWallTransparencyBasedOnCamera=(e,t,a=!0)=>{let r=e.getWorldDirection(new THREE.Vector3),n=Math.abs(r.y);n<.5&&!t.transparent&&setWallTransparency(t,!0,a),n>.5&&t.transparent&&setWallTransparency(t,!1,a)},setWallTransparency=(e,t,a=!0)=>{if(!e.userData.tween)if(t)if(e.transparent=!0,a){let t={opacity:1};e.userData.tween=!0,new TWEEN.Tween(t).to({opacity:.2},400).easing(TWEEN.Easing.Sinusoidal.In).onUpdate(()=>{e.opacity=t.opacity}).onComplete(()=>{e.userData.tween=!1}).start()}else e.opacity=.2;else if(a){let t={opacity:.2};e.userData.tween=!0,new TWEEN.Tween(t).to({opacity:1},400).easing(TWEEN.Easing.Sinusoidal.In).onUpdate(()=>{e.opacity=t.opacity}).onComplete(()=>{e.transparent=!1,e.userData.tween=!1}).start()}else e.opacity=1,e.transparent=!1},getColorFromInt=e=>{let t=new THREE.Color;return t.setRGB((e>>16)/255,(e>>8&255)/255,(e>>0&255)/255),t},fadeIn=e=>{e.traverse(e=>{if(e instanceof THREE.Mesh&&TWEEN){let t=e.material;if(0===t.opacity)return;let a={opacity:0,transparent:!0},r={opacity:t.opacity,transparent:t.transparent};t.transparent=a.transparent,t.opacity=a.opacity,new TWEEN.Tween(a).to(r,500).easing(TWEEN.Easing.Linear.None).onUpdate(()=>{t.opacity=a.opacity}).onComplete(()=>{t.transparent=r.transparent}).start()}})},checkGLB=(e,t)=>{let a=(new THREE.Box3).setFromObject(e),r=a.getSize(new THREE.Vector3),n=Math.min(r.x,r.y,r.z),o=!0;return n>5&&(console.warn("GLB seems to be too big ("+n+")",t),o=!1),a.min.y<-.01&&(console.warn("GLB seems to be under the floor ("+a.min.y+"): ",t),o=!1),o},dispose=e=>{"Mesh"===e.type?disposeMesh(e):disposeObject(e)},disposeObject=e=>{e&&e.children&&0!==e.children.length&&e.children.forEach(e=>{disposeMesh(e)})},disposeMesh=e=>{e&&(e.material&&disposeMaterial(e.material),e.geometry&&disposeGeometry(e.geometry),e.children&&e.children.length>0&&disposeObject(e))},disposeGeometry=e=>{e&&e.dispose()},disposeMaterial=e=>{e&&(e.map&&e.map.dispose(),e.normalMap&&e.normalMap.dispose(),e.dispose())};let boundingBoxMaterial;const getBoundingBoxMaterial=()=>(boundingBoxMaterial||((boundingBoxMaterial=new THREE.MeshBasicMaterial).visible=!1),boundingBoxMaterial),getSelectionGeometry=(e,t)=>{let a=t.x/2,r=t.z/2,n=new THREE.Vector3(-a,.01,r),o=[n,new THREE.Vector3(n.x,n.y,n.z+.2),new THREE.Vector3(n.x-.2,n.y,n.z+.2),new THREE.Vector3(n.x-.2,n.y,n.z)],s=[new THREE.Face3(3,2,0),new THREE.Face3(2,1,0)],i=new THREE.Geometry;return i.vertices.push(...o),i.faces.push(...s),i.computeFaceNormals(),i.computeVertexNormals(),i},vectorIsZero=e=>0===e.x&&0===e.y&&0===e.z,getMaterialId=(e,t)=>{let a="";return e.materialId&&""!==e.materialId?a=e.materialId:e.catalogItemId&&""!==e.catalogItemId?a=e.catalogItemId:e.rgbValue>0?a="rbg"+JSON.stringify(e.rgbValue):e.length>0?a=e:t&&1===t.value?a="default_wall_material_"+e.getSourceType().value:t&&7===t.value&&(a="default_ceiling_material_"+e.getSourceType().value),a},vectorIsEqual=(e,t,a=.01)=>!(!e||!t)&&Math.abs(e.x-t.x)<=a&&Math.abs(e.y-t.y)<=a&&Math.abs(e.z-t.z)<=a;class AsyncGuard{constructor(e){this.info=e,this._init()}_init(){this._promise=new Promise((e,t)=>{this._resolve=e,this._reject=t})}resolve(e){e&&this._resolve(e),this._resolve()}reject(e){this._reject(e)}wait(){return this._promise}reset(){this._init()}}export{getScreenXY as a,getGUI as b,toRadiant as c,dispose as d,kernelBoxToThreeBox as e,kernelDimensioningToThree as f,PREVIEW_MATERIAL_COLOR as g,createColorCubeTexture as h,PREVIEW_MATERIAL_OPACITY as i,AsyncGuard as j,disposeObject as k,disposeMaterial as l,disposeGeometry as m,disposeMesh as n,DOCK_PREVIEW_MATERIAL_OPACITY as o,DOCK_PREVIEW_MATERIAL_ROUGHNESS as p,DOCK_PREVIEW_MATERIAL_METALNESS as q,DOCK_PREVIEW_MATERIAL_COLOR as r,DOCK_PREVIEW_MATERIAL_OPACITY_HOVERED as s,PREVIEW_LINE_MATERIAL_OPACITY as t,position3VectorsAreEqual as u,position2VectorsAreEqual as v,getIdealDistance as w,to360Degrees as x,getAngle as y,setShadows as z,vectorIsEqual as A,fadeIn as B,createMaterial as C,addTexture as D,PREVIEW_MATERIAL_ROUGHNESS as E,PREVIEW_MATERIAL_METALNESS as F,vectorIsZero as G,getMaterialId as H,getBoundingBoxMaterial as I,getColorFromInt as J,getSelectionGeometry as K,checkGLB as L,setWallTransparencyBasedOnCamera as M,setWallTransparency as N,rotationQuaternionsAreEqual as O,getDelta as P,getMaterialShading as Q};
//# sourceMappingURL=chunk-36924942.js.map
